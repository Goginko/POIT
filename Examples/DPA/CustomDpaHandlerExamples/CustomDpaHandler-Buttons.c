// *********************************************************************
//   Custom DPA Handler code - Handling buttons                        *
// *********************************************************************
// Copyright (c) IQRF Tech s.r.o.
//
// File:    $RCSfile: CustomDpaHandler-Buttons.c,v $
// Version: $Revision: 1.7 $
// Date:    $Date: 2020/02/20 17:18:58 $
//
// Revision history:
//   2019/01/10  Release for DPA 4.00
//
// *********************************************************************

// Online DPA documentation https://doc.iqrf.org/DpaTechGuide/

// Default IQRF include (modify the path according to your setup)
#include "IQRF.h"

// Default DPA header (modify the path according to your setup)
#include "DPA.h"
// Default Custom DPA Handler header (modify the path according to your setup)
#include "DPAcustomHandler.h"

//############################################################################################

// Button descriptor
typedef struct
{
  // Timer to measure debouncing, recommended to be the 1st field to save the code
  uns8  Timer;
  // Last button state [must be initialized to 0xFF if the initial state of the button is not sure to be HIGH]
  uns8  LastState;
  // Button's PIC port: 0 = PORTA, 1 = PORTB, ... [must be initialized]
  uns8  Port;
  // Button's bit mask (only one bit must be set) [must be initialized]
  uns8  ButtonMask;
  // Debounce interval measured in the timer ticks + 1 [must be initialized]
  uns8  DebounceDelay;
  // 0 if button is HIGH, 1 if button is LOW
  uns8  ButtonIsLow;
} TButton;

// Handles the button and sets ButtonIsLow appropriately
void HandleButton( uns16 pButton @ FSR0 );

// Must be the 1st defined function in the source code in order to be placed at the correct FLASH location!
//############################################################################################
bit CustomDpaHandler()
//############################################################################################
{
  // Handler presence mark
  clrwdt();

  // We demonstrate 2 buttons by 1 physical button but with different debouncing value
  static TButton ButtonFast, ButtonSlow;

  // Detect DPA event to handle (unused event handlers can be commented out or even deleted)
  switch ( GetDpaEvent() )
  {
    // -------------------------------------------------
    case DpaEvent_Interrupt:
      // Do an extra quick background interrupt work
      // ! The time spent handling this event is critical.If there is no interrupt to handle return immediately otherwise keep the code as fast as possible.
      // ! Make sure the event is the 1st case in the main switch statement at the handler routine.This ensures that the event is handled as the 1st one.
      // ! It is desirable that this event is handled with immediate return even if it is not used by the custom handler because the Interrupt event is raised on every MCU interrupt and the “empty” return handler ensures the shortest possible interrupt routine response time.
      // ! Only global variables or local ones marked by static keyword can be used to allow reentrancy.
      // ! Make sure race condition does not occur when accessing those variables at other places.
      // ! Make sure( inspect.lst file generated by C compiler ) compiler does not create any hidden temporary local variable( occurs when using division, multiplication or bit shifts ) at the event handler code.The name of such variable is usually Cnumbercnt.
      // ! Do not call any OS functions except setINDFx().
      // ! Do not use any OS variables especially for writing access.
      // ! All above rules apply also to any other function being called from the event handler code, although calling any function from Interrupt event is not recommended because of additional MCU stack usage.

      //  If TMR6 interrupt occurred
      if ( TMR6IF )
      {
        // Unmask interrupt
        TMR6IF = FALSE;

        // Handle buttons
        HandleButton( &ButtonFast );
        HandleButton( &ButtonSlow );

        // Demonstration of the fast button
        if ( ButtonFast.ButtonIsLow.0 )
          setLEDR();
        else
          stopLEDR();

        // Demonstration of the slow button
        if ( ButtonSlow.ButtonIsLow.0 )
          setLEDG();
        else
          stopLEDG();
      }

      return Carry;

      // -------------------------------------------------
    case DpaEvent_Init:
      // Do a one time initialization before main loop starts

      // Initialize buttons' descriptors (CC5X does not support initialization of the static variables)

      // Fast button @ IQRF standard button
      ButtonFast.LastState = 0xFF;
      ButtonFast.Port = 1;                  // PORTB
      ButtonFast.ButtonMask = 0b0001.0000;  // PORTB.4
      ButtonFast.DebounceDelay = 2 + 1 /* x64ms */;

      // Slow button @ IQRF standard button
      ButtonSlow.LastState = 0xFF;
      ButtonSlow.Port = 1;                  // PORTB
      ButtonSlow.ButtonMask = 0b0001.0000;  // PORTB.4
      ButtonSlow.DebounceDelay = 15 + 1 /* x64ms */;

      // Setup TMR6 for 64 ms interval
      PR6 = 250 - 1;
      T6CON = 0b0.1111.1.11;
      TMR6IE = TRUE;
      break;

      // -------------------------------------------------
    case DpaEvent_AfterSleep:
      // Called on wake-up from sleep
      TMR6IE = TRUE;
      TMR6ON = TRUE;
      break;

      // -------------------------------------------------
    case DpaEvent_BeforeSleep:
      // Called before going to sleep (the same handling as DpaEvent_DisableInterrupts event)
      // -------------------------------------------------
    case DpaEvent_DisableInterrupts:
      // Called when device needs all hardware interrupts to be disabled (before Reset, Restart, LoadCode, Remove bond, and Run RFPGM)
      // Must not use TMR6 any more
      TMR6ON = FALSE;
      TMR6IE = FALSE;
      break;
  }

  return FALSE;
}

//############################################################################################
void HandleButton( uns16 pButton @ FSR0 )
//############################################################################################
{
  // FSR0 points to the button's descriptor
  // (Local variables must be static as they are used inside interrupt routine)

  // Timer is active (non zero)?
  W = FSR0[offsetof( TButton, Timer )];
  if ( W != 0 ) // Note: must not modify W
  {
    // Yes, decrement the timer
    FSR0 += offsetof( TButton, Timer ); // Note: Timer is the 1st field of TButton so this generates no code and must not modify W
    setINDF0( W - 1 );
    FSR0 += -(int8)offsetof( TButton, Timer ); // Note: Timer is the 1st field of TButton so this generates no code, casting fixes CC5X bug
  }

  // FSR1 will point to the button's port
  FSR1L = FSR0[offsetof( TButton, Port )] + ( &PORTA & 0xFF );
  FSR1H = &PORTA >> 8;

  // Current state of the button, only the button bit is used, other bits are masked to zero
  static uns8 state;
  state = *FSR1 & FSR0[offsetof( TButton, ButtonMask )];

  // Button state changed?
  if ( ( state ^ FSR0[offsetof( TButton, LastState )] ) != 0 )
  {
    FSR0 += offsetof( TButton, Timer ); // Note: Timer is the 1st field of TButton so this generates no code and must not modify W
    // Initialize timer for debouncing
    setINDF0( FSR0[offsetof( TButton, DebounceDelay ) - offsetof( TButton, Timer )] );
    // Adjust pointer to LastState field
    FSR0 += (int8)( offsetof( TButton, LastState ) - offsetof( TButton, Timer ) );  // Note: casting fixes CC5X bug
    // Store the current state as the last one
    setINDF0( state );
    return; // Note: saves Flash by direct GOTO setINDF0
  }

  // Timer is almost over?
  if ( FSR0[offsetof( TButton, Timer )] != 1 )
    // No
    return;

  // The button state was stable for the debounce interval, prepare the pointer to store the new state
  FSR0 += offsetof( TButton, ButtonIsLow );
  // Ready for new state "button is HIGH"
  W = FALSE;
  // Is button LOW?
  if ( state == 0 ) // Note: must not modify W
    // Ready for new state "button is LOW"
    W = TRUE;

  // Set the button external state
  setINDF0( W );
}

//############################################################################################
// Default Custom DPA Handler header; 2nd include to implement Code bumper to detect too long code of the Custom DPA Handler (modify the path according to your setup) 
#include "DPAcustomHandler.h"
//############################################################################################

