// *********************************************************************
//   Custom DPA Handler code example - User data en/decryption         *
// *********************************************************************
// Copyright (c) IQRF Tech s.r.o.
//
// File:    $RCSfile: CustomDpaHandler-UserEncryption.c,v $
// Version: $Revision: 1.14 $
// Date:    $Date: 2020/02/20 17:18:58 $
//
// Revision history:
//   2017/03/13  Release for DPA 3.00
//
// *********************************************************************

// On-line DPA documentation https://doc.iqrf.org/DpaTechGuide/

/* This example shows the usage of the user data en/decryption using AES-128

User peripheral PNUM=0x20 and 2 commands are implemented:
* PCMD=0 returns first 16 bytes of peripheral RAM encrypted by User key
* PCMD=1 writes 16 bytes of data encrypted by the User key to the peripheral RAM

The initial content of the peripheral RAM after the device is restarted is 0,1,2,3,4,5,6,7,8,"AES-128".

You can use a public on-line AES tools to en/decrypt to play with the commands.

[Example 1]
* Restart module
* Run PCMD=0. It returns the initial text from peripheral RAM encrypted by the User key (initial value is 00000000000000000000000000000000). Returned data is ce61d785c84e30883973340aea2e6dcf
* Go to http://testprotect.com/appendix/AEScalc
* Enter 00000000000000000000000000000000 to "AES key (in hex):"
* Enter ce61d785c84e30883973340aea2e6dcf to "Input Data (in hex):"
* Press "Decrypt it", the result is 0001020304050607084145532d313238, which corresponds to the expected 0,1,2,3,4,5,6,7,8,"AES-128"

[Example 2]
* Go to http://testprotect.com/appendix/AEScalc
* Enter 00000000000000000000000000000000 to "AES key (in hex):"
* Enter aaBBccDDeeFFaaBBccDDeeFFaaBBccDD to "Input Data (in hex):"
* Press "Encrypt it", the result is e37967714d9be9e66bc03629427de452
* Run PCMD=1 with data "e37967714d9be9e66bc03629427de452"
* Read 16 bytes from address 0 of peripheral Ram. The result is expected aaBBccDDeeFFaaBBccDDeeFFaaBBccDD

Note: another AES tool that works well is http://aes.online-domain-tools.com/

*/

// Default IQRF include (modify the path according to your setup)
#include "IQRF.h"

// Default DPA header (modify the path according to your setup)
#include "DPA.h"
// Default Custom DPA Handler header (modify the path according to your setup)
#include "DPAcustomHandler.h"

//############################################################################################

// Must be the 1st defined function in the source code in order to be placed at the correct FLASH location!
//############################################################################################
bit CustomDpaHandler()
//############################################################################################
{
  // Handler presence mark
  clrwdt();

  // Detect DPA event to handle
  switch ( GetDpaEvent() )
  {
    // -------------------------------------------------
    case DpaEvent_Interrupt:
      // Do an extra quick background interrupt work
      // ! The time spent handling this event is critical.If there is no interrupt to handle return immediately otherwise keep the code as fast as possible.
      // ! Make sure the event is the 1st case in the main switch statement at the handler routine.This ensures that the event is handled as the 1st one.
      // ! It is desirable that this event is handled with immediate return even if it is not used by the custom handler because the Interrupt event is raised on every MCU interrupt and the “empty” return handler ensures the shortest possible interrupt routine response time.
      // ! Only global variables or local ones marked by static keyword can be used to allow reentrancy.
      // ! Make sure race condition does not occur when accessing those variables at other places.
      // ! Make sure( inspect.lst file generated by C compiler ) compiler does not create any hidden temporary local variable( occurs when using division, multiplication or bit shifts ) at the event handler code.The name of such variable is usually Cnumbercnt.
      // ! Do not call any OS functions except setINDFx().
      // ! Do not use any OS variables especially for writing access.
      // ! All above rules apply also to any other function being called from the event handler code, although calling any function from Interrupt event is not recommended because of additional MCU stack usage.

      return Carry;

      // -------------------------------------------------
    case DpaEvent_Init:
      // Do a one time initialization before main loop starts

      // Initialize en/decrypted user data
      PeripheralRam[0x0] = 0;
      PeripheralRam[0x1] = 1;
      PeripheralRam[0x2] = 2;
      PeripheralRam[0x3] = 3;
      PeripheralRam[0x4] = 4;
      PeripheralRam[0x5] = 5;
      PeripheralRam[0x6] = 6;
      PeripheralRam[0x7] = 7;
      PeripheralRam[0x8] = 8;
      PeripheralRam[0x9] = 'A';
      PeripheralRam[0xA] = 'E';
      PeripheralRam[0xB] = 'S';
      PeripheralRam[0xC] = '-';
      PeripheralRam[0xD] = '1';
      PeripheralRam[0xE] = '2';
      PeripheralRam[0xF] = '8';
      break;

      // -------------------------------------------------
    case DpaEvent_DpaRequest:
      // Called to interpret DPA request for peripherals
      // -------------------------------------------------
      // Peripheral enumeration
      if ( IsDpaEnumPeripheralsRequest() )
      {
        // We implement 1 user peripheral
        _DpaMessage.EnumPeripheralsAnswer.UserPerNr = 1;
        FlagUserPer( _DpaMessage.EnumPeripheralsAnswer.UserPer, PNUM_USER + 0 );
        _DpaMessage.EnumPeripheralsAnswer.HWPID = 0x000F;
        _DpaMessage.EnumPeripheralsAnswer.HWPIDver = 0x1234;

DpaHandleReturnTRUE:
        return TRUE;
      }
      // -------------------------------------------------
      // Get information about peripheral
      else if ( IsDpaPeripheralInfoRequest() )
      {
        if ( _PNUM == PNUM_USER + 0 )
        {
          _DpaMessage.PeripheralInfoAnswer.PerT = PERIPHERAL_TYPE_USER_AREA;
          _DpaMessage.PeripheralInfoAnswer.PerTE = PERIPHERAL_TYPE_EXTENDED_READ_WRITE;
          goto DpaHandleReturnTRUE;
        }

        break;
      }
      // -------------------------------------------------
      else
      {
        // Handle peripheral command
        if ( _PNUM == PNUM_USER + 0 )
        {
          switch ( _PCMD )
          {
            // Read data
            case 0x00:
            {
              // No input data
              if ( _DpaDataLength != 0 )
                DpaApiReturnPeripheralError( ERROR_DATA_LEN );

              // Copy data to the result, the result length is 16 bytes (one AES block)
              copyMemoryBlock( PeripheralRam, _DpaMessage.Response.PData, _DpaDataLength = 16 );
              // Encrypt data (_DpaMessage.Response.PData is actually bufferRF)
              encryptBufferRF( 1 );
              return TRUE;
            }

            // Write data
            case 0x01:
            {
              // Exactly one AES block of input data is expected
              if ( _DpaDataLength != 16 )
                DpaApiReturnPeripheralError( ERROR_DATA_LEN );

              // Decrypt data to write (_DpaMessage.Response.PData is actually bufferRF)
              decryptBufferRF( 1 );
              // Copy written data to the buffer
              copyMemoryBlock( _DpaMessage.Request.PData, PeripheralRam, 16 );
              // No data is written
              _DpaDataLength = 0;
              return TRUE;
            }

            // Invalid command
            default:
              DpaApiReturnPeripheralError( ERROR_PCMD );
          }
        }
      }
  }

  return FALSE;
}

//############################################################################################
// Default Custom DPA Handler header; 2nd include to implement Code bumper to detect too long code of the Custom DPA Handler (modify the path according to your setup) 
#include "DPAcustomHandler.h"
//############################################################################################
