// *********************************************************************
//   Custom DPA Handler code example - Scanning RSSI of neighbors      *
// *********************************************************************
// Copyright (c) IQRF Tech s.r.o.
//
// File:    $RCSfile: CustomDpaHandler-ScanRSSI.c,v $
// Version: $Revision: 1.33 $
// Date:    $Date: 2020/02/20 17:18:58 $
//
// Revision history:
//   2017/03/13  Release for DPA 3.00
//   2015/08/05  Release for DPA 2.20
//
// *********************************************************************

// Online DPA documentation https://doc.iqrf.org/DpaTechGuide/

// Default IQRF include (modify the path according to your setup)
#include "IQRF.h"

// Uncomment to compile Custom DPA Handler for Coordinator
//#define COORDINATOR_CUSTOM_HANDLER

// Default DPA header (modify the path according to your setup)
#include "DPA.h"
// Default Custom DPA Handler header (modify the path according to your setup)
#include "DPAcustomHandler.h"

// This example implements measurement of RSSI among all nodes of the IQRF network. This handler must be uploaded to all Nodes and with COORDINATOR_CUSTOM_HANDLER symbol defined to the coordinator too.
// To measure the RSSIs use FRC with command FRC_AcknowledgedBroadcastBits = 0x02 with DPA request for custom peripheral PNUM=0x20, PCMD=0, HWPID=0x001F and data corresponding to the TScanRSSI structure.
// When FRC is finished then the same peripheral at C must called. C then sends TScanPacket packet. Then come short 10 timeslots when all Ns send their TScanPacket packets. Timeslots are ordered according to the Ns' VRNs. 
// When the measurement is finished then PNUM=0x20, PCMD=1 and PNUM=0x20, PCMD=2 are used to read RSSI levels from all nodes. 
// The result is a bit array of bit pairs i.e. 2 bits for every node at the network. Bit pairs are ordered according the node address. Bits 0b00 indicated that the node of such address was not "listened" at all.
// 0b01 means low RSSI, 0b10 means middle RSSI and 0b11 specifies high RSSI
// ! Please note that this example stores RSSI levels in the bufferAUX memory buffer which is not generally recommended because bufferAUX is used internally by DPA for certain purposes (i.e. storing batches). 
// ! Therefore it is important to read levels immediately after RSSI is measure otherwise levels might be overwritten.
// This example works only at STD mode, not at LP mode

// Structure holding data for custom peripheral PNUM=0x20, PCMD=0. This command initiates measurement of RSSI among nodes. It must be used only as a part of FRC_AcknowledgedBroadcastBits.
typedef struct
{
  // Maximum VRN in the network (equals number of discovered nodes in the network)
  uns8 MaxVrn;
  // TX power used to measure RSSI
  uns8 TxPower;
  // If RSSI is equal of less than this number, it gets the level 1
  uns8 RssiLow;
  // If RSIS is equal of less than this number, it gets the level 2. If RSSI is greater then it gets code 3.
  uns8 RssiMid;
} TScanRSSI;

// Structure of the packet used to measure RSSI.
typedef struct
{
  // Packet header. equals 'N'
  uns8 Header;
  // Address of the node that sent the packet
  uns8 Address;
} TScanPacket;

// Must be the 1st defined function in the source code in order to be placed at the correct FLASH location!
//############################################################################################
bit CustomDpaHandler()
//############################################################################################
{
  // Handler presence mark
  clrwdt();

#ifndef COORDINATOR_CUSTOM_HANDLER
  // Place for local static variables used only within CustomDpaHandler() among more events
  static uns8 timer10msCounter;
#endif

  // Detect DPA event to handle
  switch ( GetDpaEvent() )
  {
#ifndef COORDINATOR_CUSTOM_HANDLER
    // -------------------------------------------------
    case DpaEvent_Interrupt:
      // Do an extra quick background interrupt work
      // ! The time spent handling this event is critical.If there is no interrupt to handle return immediately otherwise keep the code as fast as possible.
      // ! Make sure the event is the 1st case in the main switch statement at the handler routine.This ensures that the event is handled as the 1st one.
      // ! It is desirable that this event is handled with immediate return even if it is not used by the custom handler because the Interrupt event is raised on every MCU interrupt and the “empty” return handler ensures the shortest possible interrupt routine response time.
      // ! Only global variables or local ones marked by static keyword can be used to allow reentrancy.
      // ! Make sure race condition does not occur when accessing those variables at other places.
      // ! Make sure( inspect.lst file generated by C compiler ) compiler does not create any hidden temporary local variable( occurs when using division, multiplication or bit shifts ) at the event handler code.The name of such variable is usually Cnumbercnt.
      // ! Do not call any OS functions except setINDFx().
      // ! Do not use any OS variables especially for writing access.
      // ! All above rules apply also to any other function being called from the event handler code, although calling any function from Interrupt event is not recommended because of additional MCU stack usage.

      //  If TMR6 interrupt occurred
      if ( TMR6IF )
      {
        // Unmask interrupt
        TMR6IF = 0;
        // Increment count
        timer10msCounter++;
      }

      return Carry;

      // -------------------------------------------------
    case DpaEvent_Init:
      // Do a one time initialization before main loop starts
    {
      // Setup TMR6 to generate ticks on the background (ticks every 10ms)
#if F_OSC == 16000000
      PR6 = 250 - 1;
      T6CON = 0b0.1001.1.10;	// Prescaler 16, Postscaler 10, 16 * 10 * 250 = 40000 = 4MHz * 10ms
#else
#error Unsupported oscillator frequency
#endif

      TMR6IE = TRUE;
    }
    break;

    // -------------------------------------------------
    case DpaEvent_AfterSleep:
      // Called on wake-up from sleep
      TMR6IE = TRUE;
      TMR6ON = TRUE;
      break;

      // -------------------------------------------------
    case DpaEvent_BeforeSleep:
      // Called before going to sleep	(the same handling as DpaEvent_DisableInterrupts event)

      // -------------------------------------------------
    case DpaEvent_DisableInterrupts:
      // Called when device needs all hardware interrupts to be disabled (before Reset, Restart, LoadCode, Remove bond, and Run RFPGM)
      // Must not use TMR6 any more
      TMR6ON = FALSE;
      TMR6IE = FALSE;
      break;

#endif

      // -------------------------------------------------
    case DpaEvent_DpaRequest:
      // Called to interpret DPA request for peripherals
      // -------------------------------------------------
      // Peripheral enumeration
      if ( IsDpaEnumPeripheralsRequest() )
      {
        // We implement 1 user peripheral
        _DpaMessage.EnumPeripheralsAnswer.UserPerNr = 1;
        FlagUserPer( _DpaMessage.EnumPeripheralsAnswer.UserPer, PNUM_USER + 0 );
        _DpaMessage.EnumPeripheralsAnswer.HWPID = 0x001F;
        _DpaMessage.EnumPeripheralsAnswer.HWPIDver = 0x0000;

DpaHandleReturnTRUE:
        return TRUE;
      }
      // -------------------------------------------------
      // Get information about peripheral
      else if ( IsDpaPeripheralInfoRequest() )
      {
        if ( _PNUM == PNUM_USER + 0 )
        {
          _DpaMessage.PeripheralInfoAnswer.PerT = PERIPHERAL_TYPE_USER_AREA;
          _DpaMessage.PeripheralInfoAnswer.PerTE = PERIPHERAL_TYPE_EXTENDED_READ_WRITE;
          goto DpaHandleReturnTRUE;
        }

        break;
      }
      // -------------------------------------------------
      else
      {
        // Handle peripheral
        if ( _PNUM == PNUM_USER + 0 )
        {
          switch ( _PCMD )
          {
            // Initiate RSSI measurement
            case 0:
            {
              // Check data length
              if ( _DpaDataLength != sizeof( TScanRSSI ) )
                DpaApiReturnPeripheralError( ERROR_DATA_LEN );

#ifndef COORDINATOR_CUSTOM_HANDLER
              // At Node it can be called only from FRC acknowledged broadcast, otherwise it is not synchronized!
              if ( _NADR != BROADCAST_ADDRESS )
                DpaApiReturnPeripheralError( ERROR_NADR );
              // NOde with temporary address does not measure
              if ( ntwADDR == TEMPORARY_ADDRESS )
                DpaApiReturnPeripheralError( ERROR_FAIL );
#endif
              // Request data
              TScanRSSI ScanRSSI @ _DpaMessage.Request.PData;
              // Copy of request data
              TScanRSSI ScanRSSICopy;
              // Make a copy
              copyMemoryBlock( &ScanRSSI, &ScanRSSICopy, sizeof( ScanRSSICopy ) );

              // Set non-network RF settings
              setNonetMode();
              setNetworkFilteringOff();
              setRFmode( _WPE | _RX_STD | _TX_STD | _STDL );
              setRFpower( ScanRSSICopy.TxPower );

              // Scanning packet
              TScanPacket ScanPacket @ bufferRF;

#ifndef COORDINATOR_CUSTOM_HANDLER
              // Clear bufferAUX
              clearBufferINFO();
              swapBufferINFO();

              // Give C some extra time to sent its ScanPacket packet
              waitDelay( 3 );

              // We use the shortest RX timeout
              toutRF = 1;
              // Initialize timer, maximize gap before measurement starts
              timer10msCounter = MAX_ADDRESS + 2;
              // We did not send out packet yet
              bit sent = FALSE;
              // Loop all timeslots
              for ( ;; )
              {
                // If we receive ScanPacket from other node
                if ( checkRF( 0 ) && RFRXpacket() && DLEN == sizeof( ScanPacket ) && ScanPacket.Header == 'N' && ScanPacket.Address <= MAX_ADDRESS )
                {
                  // bits variable stores the RSSI level from 1 to 3 according to the thresholds RssiLow and RssiMid
                  uns8 bits @ userReg0;
                  bits = 0b01;
                  if ( lastRSSI > ScanRSSICopy.RssiLow )
                  {
                    bits++;
                    if ( lastRSSI > ScanRSSICopy.RssiMid )
                      bits++;
                  }

                  // Shift level to the correct bit position according to the node address value
                  uns8 temp @ userReg1;
                  temp = ScanPacket.Address % 4;
                  while ( temp != 0 )
                  {
                    temp--;
                    bits <<= 2;
                  }

                  // Compute byte address according to the node address value
                  FSR0 = ScanPacket.Address / 4;
                  FSR0 += bufferAUX;

                  // Combine bits with already stored ones
                  setINDF0( *FSR0 | bits );
                }

                // Any timeslots pending?
                if ( timer10msCounter != ScanRSSICopy.MaxVrn + 1 )
                {
                  // Is it my timeslot and the packet was not sent yet?
                  if ( timer10msCounter == ntwVRN && !sent )
                  {
                    // Packet will be sent
                    sent = TRUE;
#endif
                    // Prepare the packet
                    ScanPacket.Header = 'N';
#ifndef COORDINATOR_CUSTOM_HANDLER
                    ScanPacket.Address = ntwADDR;
#else
                    ScanPacket.Address = COORDINATOR_ADDRESS;
#endif
                    DLEN = sizeof( ScanPacket );
                    PIN = 0;
                    // Send the packet
                    RFTXpacket();

#ifndef COORDINATOR_CUSTOM_HANDLER
                  }
                }
                else
                  // Timeslots are over. Exit the loop.
                  break;
              }
#endif
              // Restore RF settings
              DpaApiSetRfDefaults();
              setNetworkFilteringOn();
              // REstore network settings
#ifndef COORDINATOR_CUSTOM_HANDLER
              setNodeMode();
#else
              setCoordinatorMode();
#endif

              goto DpaHandleReturnTRUE;
            }

#ifndef COORDINATOR_CUSTOM_HANDLER
            case 2:
              // Return 2nd part of the RSSI bitmaps
              memoryOffsetFrom = DPA_MAX_DATA_LENGTH;

            case 1:
              // Check data length
              if ( _DpaDataLength != 0 )
                DpaApiReturnPeripheralError( ERROR_DATA_LEN );

              // Copy result from bufferAUX to the DPA response @ bufferRF
              swapBufferINFO();
              copyBufferINFO2RF();
              swapBufferINFO();

              // Return correct data length
              if ( _PCMD == 2 )
                _DpaDataLength = ( MAX_ADDRESS + 1 ) / 4 - DPA_MAX_DATA_LENGTH;
              else
                _DpaDataLength = DPA_MAX_DATA_LENGTH;

              goto DpaHandleReturnTRUE;
#endif
          }
        }
      }
  }

  return FALSE;
}
//############################################################################################
// Default Custom DPA Handler header; 2nd include to implement Code bumper to detect too long code of the Custom DPA Handler (modify the path according to your setup) 
#include "DPAcustomHandler.h"
//############################################################################################
