// ********************************************************************************
//   Custom DPA Handler code example - Standard HW UART RX + SW TX                *
// ********************************************************************************
// Copyright (c) IQRF Tech s.r.o.
//
// File:    $RCSfile: CustomDpaHandler-UartHwRxSwTx.c,v $
// Version: $Revision: 1.15 $
// Date:    $Date: 2020/02/20 17:18:58 $
//
// Revision history:
//   2019/12/11  Release for DPA 4.11
//   2018/10/25  Release for DPA 3.03
//   2017/03/14  Release for DPA 3.00
//
// ********************************************************************************

// Online DPA documentation https://doc.iqrf.org/DpaTechGuide/

// Default IQRF include (modify the path according to your setup)
#include "IQRF.h"

// Default DPA header (modify the path according to your setup)
#include "DPA.h"
// Default Custom DPA Handler header (modify the path according to your setup)
#include "DPAcustomHandler.h"
// PIC instructions (header from CC5X)
#include "hexcodes.h"

// This example shows how to use standard DPA UART RX but SW TX in order to make HW TX pin free for other use (e.g. PWM).
// This example works only at STD mode, not at LP mode.
// !!! Make sure the UART peripheral baud rate set at the Node configuration matches BaudRateValue value from below

// Fixed baud-rate
#define	BaudRateValue	57600L
#define	BaudRateDPA		DpaBaud_57600

// SW TX pin
#define	SWTX	  LATA.0
#define	SWTXtris  TRISA.0

// Default HW TX pin, that will not be used for UART
#define	HWTX	  LATC.6
#define	HWTXtris  TRISC.6

// Division macro with rounding
#define DIV(Dividend,Divisor) (((Dividend+((Divisor)>>1))/(Divisor)))
// Instructions by one baud 
#define	INSTRperBAUDmul(mul)	( DIV( ( (F_OSC) * (mul) ), ( 4L * (BaudRateValue) ) ) )
#define	INSTRperBAUD			INSTRperBAUDmul(1L)

// Delay macro
#define	SwUartDelayInst(instr) \
#if (instr) != 0 \
#if (instr) < 0 \
#error SwUartDelayInst is negative \
#elif (instr) == 3 \
  nop(); \
  nop2(); \
#elif (instr) == 4 \
  nop2(); \
  nop2(); \
#elif (instr) == 5 \
  nop(); \
  nop2(); \
  nop2(); \
#else \
#if (instr) % 3 == 1 \
  nop(); \
#elif (instr) % 3 == 2 \
  nop2(); \
#endif /* (instr) % 3 == 1 */ \
#if (instr) / 3 != 0 \
#asm \
  DW  __MOVLW( (instr) / 3 ) \
  DW  __DECFSZ( __WREG, 1 ) \
  DW  __BRA( -2 ) \
#endasm \
#endif /* (instr) / 3 != 0 */ \
#endif \
#endif /* (instr) != 0 */ \

// Must be the 1st defined function in the source code in order to be placed at the correct FLASH location!
//############################################################################################
bit CustomDpaHandler()
//############################################################################################
{
  // Handler presence mark
  clrwdt();

  // Detect DPA event to handle
  switch ( GetDpaEvent() )
  {
    // -------------------------------------------------
    case DpaEvent_Interrupt:
      // Do an extra quick background interrupt work
      // ! The time spent handling this event is critical.If there is no interrupt to handle return immediately otherwise keep the code as fast as possible.
      // ! Make sure the event is the 1st case in the main switch statement at the handler routine.This ensures that the event is handled as the 1st one.
      // ! It is desirable that this event is handled with immediate return even if it is not used by the custom handler because the Interrupt event is raised on every MCU interrupt and the “empty” return handler ensures the shortest possible interrupt routine response time.
      // ! Only global variables or local ones marked by static keyword can be used to allow reentrancy.
      // ! Make sure race condition does not occur when accessing those variables at other places.
      // ! Make sure( inspect.lst file generated by C compiler ) compiler does not create any hidden temporary local variable( occurs when using division, multiplication or bit shifts ) at the event handler code.The name of such variable is usually Cnumbercnt.
      // ! Do not call any OS functions except setINDFx().
      // ! Do not use any OS variables especially for writing access.
      // ! All above rules apply also to any other function being called from the event handler code, although calling any function from Interrupt event is not recommended because of additional MCU stack usage.
      return Carry;

      // -------------------------------------------------
    case DpaEvent_Idle:
      // Do a quick background work when RF packet is not received

      // ####################################
      // Shows free use of normally HW TX pin
      HWTXtris = 0;
      HWTX = !HWTX;
      // ####################################
      break;

      // -------------------------------------------------
    case DpaEvent_Init:
      // Do a one time initialization before main loop starts

      // After UART was opened by DPA, make sure HW TX pin is free to use by other code but not by UART peripheral
      TXEN = 0;
      HWTXtris = 0;

      // Initialize SW TX pin
      SWTXtris = 0;
      SWTX = 1;
      break;

      // -------------------------------------------------
    case DpaEvent_ReceiveDpaRequest:
      // Called after DPA request was received

      if ( _PNUM == PNUM_UART )
        switch ( _PCMD )
        {
          // Not implemented
          case CMD_UART_CLEAR_WRITE_READ:
            DpaApiSetPeripheralError( ERROR_PCMD );
            _PCMD |= RESPONSE_FLAG;
            return TRUE;

            // Handle TX by SW solution, RX by default HW solution
          case CMD_UART_WRITE_READ:
          {
            // Optimization?
#if &_DpaMessage.PerUartSpiWriteRead_Request.WrittenData[-1] == &bufferRF[0]
            setFSR0( _FSR_RF );
#else
            FSR0 = &_DpaMessage.PerUartSpiWriteRead_Request.WrittenData[-1];
#endif
            // Decrease size by ReadTimeout field but 1 byte
            _DpaDataLength -= sizeof( _DpaMessage.PerUartSpiWriteRead_Request.ReadTimeout ) - 1;
            // Send every TX byte by SW
            while ( --_DpaDataLength != 0 )
            {
              // Byte to TX (must be at common RAM to avoid MOVLB)
              userReg0 = *++FSR0;
              // Disable interrupts for precise timing
              GIE = FALSE;
              // Start bit
              SWTX = 0;
              // Bank update can be forced off as we know that only one bank (with SWTX pin) is used in the loop
#pragma updateBank 0 /* OFF */
              SwUartDelayInst( INSTRperBAUD - 6 );
              // Bit loop variable (must be at common RAM to avoid MOVLB)
              uns8 loop @ userReg1;
              // 8 bits
              loop = 8;
              do
              {
                if ( userReg0.0 )
                {
                  userReg0 = rr( userReg0 );
                  SWTX = 1;
                }
                else
                {
                  SWTX = 0;
                  userReg0 = rr( userReg0 );
                  nop();
                }

                SwUartDelayInst( INSTRperBAUD - 9 );
              } while ( --loop != 0 );
              SwUartDelayInst( 9 - 5 );
              // Stop bit
              SWTX = 1;
              // Relax timing
              GIE = TRUE;
              SwUartDelayInst( 3 * INSTRperBAUD );
#pragma updateBank 1 /* ON */
            }

            // Pass the request to the default DPA but without TX data
            _DpaDataLength = sizeof( _DpaMessage.PerUartSpiWriteRead_Request.ReadTimeout );
            break;
          }
        }

      break;

    case DpaEvent_BeforeSendingDpaResponse:
      // Called before sending DPA response back to originator of DPA response

      // After UART was opened by DPA, make sure HW TX pin is free to use by other code but not by UART peripheral
      if ( _PNUM == PNUM_UART && _PCMD == CMD_UART_OPEN )
      {
        TXEN = 0;
        HWTXtris = 0;
      }
      break;
  }

  return FALSE;
}

//############################################################################################
// Default Custom DPA Handler header; 2nd include to implement Code bumper to detect too long code of the Custom DPA Handler (modify the path according to your setup) 
#include "DPAcustomHandler.h"
//############################################################################################
