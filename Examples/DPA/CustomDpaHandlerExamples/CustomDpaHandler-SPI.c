// **************************************************************************
//   Custom DPA Handler code example - Using SPI MCU peripheral by OS calls *
// **************************************************************************
// Copyright (c) IQRF Tech s.r.o.
//
// File:    $RCSfile: CustomDpaHandler-SPI.c,v $
// Version: $Revision: 1.27 $
// Date:    $Date: 2020/02/20 17:18:58 $
//
// Revision history:
//   2017/03/13  Release for DPA 3.00
//   2015/08/05  Release for DPA 2.20
//   2014/10/31  Release for DPA 2.10
//   2014/04/30  Release for DPA 2.00
//
// **************************************************************************

// Online DPA documentation https://doc.iqrf.org/DpaTechGuide/

// Default IQRF include (modify the path according to your setup)
#include "IQRF.h"

// Default DPA header (modify the path according to your setup)
#include "DPA.h"
// Default Custom DPA Handler header (modify the path according to your setup)
#include "DPAcustomHandler.h"

// This example shows how to connect custom peripheral with MCU SPI HW peripheral controlled by IQRF OS

// Must be the 1st defined function in the source code in order to be placed at the correct FLASH location!
//############################################################################################
bit CustomDpaHandler()
//############################################################################################
{
  // Handler presence mark
  clrwdt();

  // Place for local static variables used only within CustomDpaHandler() among more events
  // example: static bit interruptOccured;

  // Detect DPA event to handle (unused event handlers can be commented out or even deleted)
  switch ( GetDpaEvent() )
  {
    // -------------------------------------------------
    case DpaEvent_Interrupt:
      // Do an extra quick background interrupt work
      // ! The time spent handling this event is critical.If there is no interrupt to handle return immediately otherwise keep the code as fast as possible.
      // ! Make sure the event is the 1st case in the main switch statement at the handler routine.This ensures that the event is handled as the 1st one.
      // ! It is desirable that this event is handled with immediate return even if it is not used by the custom handler because the Interrupt event is raised on every MCU interrupt and the “empty” return handler ensures the shortest possible interrupt routine response time.
      // ! Only global variables or local ones marked by static keyword can be used to allow reentrancy.
      // ! Make sure race condition does not occur when accessing those variables at other places.
      // ! Make sure( inspect.lst file generated by C compiler ) compiler does not create any hidden temporary local variable( occurs when using division, multiplication or bit shifts ) at the event handler code.The name of such variable is usually Cnumbercnt.
      // ! Do not call any OS functions except setINDFx().
      // ! Do not use any OS variables especially for writing access.
      // ! All above rules apply also to any other function being called from the event handler code, although calling any function from Interrupt event is not recommended because of additional MCU stack usage.

DpaHandleReturnTRUE:
      return TRUE;

      // -------------------------------------------------
    case DpaEvent_Idle:
      // Do a quick background work when RF packet is not received

      // Is there anything at SPI received?
      if ( !getStatusSPI() && _SPIRX )
      {
        if ( _SPICRCok )
        {
          stopSPI();

          // PeripheralRam[0] stores length of received data
          PeripheralRam[0] = SPIpacketLength;

          // Limit to max. length of Peripheral RAM
          if ( PeripheralRam[0] > sizeof( PeripheralRam ) - 1 )
            PeripheralRam[0] = sizeof( PeripheralRam ) - 1;

          // Store data to PeripheralRam[1...] 
          copyMemoryBlock( bufferCOM, PeripheralRam + 1, PeripheralRam[0] );

          // Now data can be read by
          // 1. reading from Peripheral RAM
          // 2. by user peripheral _Pnum=PNUM_USER and _PCMD=1
        }

        startSPI( 0 );
      }
      break;

      // -------------------------------------------------
    case DpaEvent_Reset:
    {
      // Called after module is reset
      //goto DpaHandleReturnTRUE; // return TRUE only if you handle node bonding/unbonding
      static onlyOnce;

      if ( !onlyOnce )
      {
        onlyOnce = TRUE;

        // Enable SPI after reset
        enableSPI();
        bufferCOM[0] = 'R';
        bufferCOM[1] = 'e';
        bufferCOM[2] = 's';
        bufferCOM[3] = 'e';
        bufferCOM[4] = 't';
        startSPI( 5 );
      }
      break;
    }

    // -------------------------------------------------
    case DpaEvent_Init:
      // Do a one time initialization before main loop starts

      PeripheralRam[0] = 0;
      // SPI stays enabled after reset event
      bufferCOM[0] = 'I';
      bufferCOM[1] = 'n';
      bufferCOM[2] = 'i';
      bufferCOM[3] = 't';
      startSPI( 4 );
      break;

      // -------------------------------------------------
    case DpaEvent_DpaRequest:
      // Called to interpret DPA request for peripherals
      // -------------------------------------------------
      // Peripheral enumeration
      if ( IsDpaEnumPeripheralsRequest() )
      {
        _DpaMessage.EnumPeripheralsAnswer.UserPerNr = 1;
        FlagUserPer( _DpaMessage.EnumPeripheralsAnswer.UserPer, PNUM_USER + 0 );
        _DpaMessage.EnumPeripheralsAnswer.HWPID = 0x000F;
        _DpaMessage.EnumPeripheralsAnswer.HWPIDver = 0;

        goto DpaHandleReturnTRUE;
      }
      // -------------------------------------------------
      // Get information about peripheral
      else if ( IsDpaPeripheralInfoRequest() )
      {
        if ( _PNUM == PNUM_USER + 0 )
        {
          _DpaMessage.PeripheralInfoAnswer.PerT = PERIPHERAL_TYPE_USER_AREA;
          _DpaMessage.PeripheralInfoAnswer.PerTE = PERIPHERAL_TYPE_EXTENDED_READ_WRITE;
          _DpaMessage.PeripheralInfoAnswer.Par1 = 0;
          _DpaMessage.PeripheralInfoAnswer.Par2 = 0;
          goto DpaHandleReturnTRUE;
        }

        break;
      }
      // -------------------------------------------------
      else
      {
        // Handle peripheral command
        if ( _PNUM == PNUM_USER + 0 )
        {
          switch ( _PCMD )
          {
            case 0:
              // Write one byte from PData to SPI
              if ( _DpaDataLength != 1 )
                goto Error_FAIL;

              bufferCOM[0] = 'C';
              bufferCOM[1] = 'm';
              bufferCOM[2] = 'd';
              bufferCOM[3] = '=';
              bufferCOM[4] = _DpaMessage.Request.PData[0];
              // SPI is enabled from reset event
              startSPI( 5 );
              _DpaDataLength = 0;
              goto DpaHandleReturnTRUE;

            case 1:
              if ( _DpaDataLength != 0 )
                goto Error_FAIL;

              // Read data originally read from SPI
              copyMemoryBlock( PeripheralRam + 1, _DpaMessage.Response.PData, _DpaDataLength = PeripheralRam[0] );
              goto DpaHandleReturnTRUE;

            default:;
              // For simplicity reasons we report only one type of error
Error_FAIL:
              DpaApiReturnPeripheralError( ERROR_FAIL );
          }
        }
      }

      break;
  }

DpaHandleReturnFALSE:
  return FALSE;
}
//############################################################################################
// Default Custom DPA Handler header; 2nd include to implement Code bumper to detect too long code of the Custom DPA Handler (modify the path according to your setup) 
#include "DPAcustomHandler.h"
//############################################################################################
