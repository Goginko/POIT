// ***********************************************************************************
//   Custom DPA Handler code example - User peripheral implementation - i2c          *
// ***********************************************************************************
// Copyright (c) IQRF Tech s.r.o.
//
// File:    $RCSfile: CustomDpaHandler-UserPeripheral-i2c.c,v $
// Version: $Revision: 1.19 $
// Date:    $Date: 2020/02/20 17:18:58 $
//
// Revision history:
//   2020/01/02  Release for DPA 4.11
//   2017/03/13  Release for DPA 3.00
//   2015/12/01  Release for DPA 2.24
//   2015/08/05  Release for DPA 2.20
//
// *********************************************************************

// Online DPA documentation https://doc.iqrf.org/DpaTechGuide/

// This example implements the user peripheral reading from MCP9802 at DDC-SE-01
// PNUM = 0x20 and PCMD = 0 returns 2 bytes with result read from MCP9802
// Based on example DDC-SE-01-i2c.c

// Default IQRF include (modify the path according to your setup)
#include "IQRF.h"

// Default DPA header (modify the path according to your setup)
#include "DPA.h"
// Default Custom DPA Handler header (modify the path according to your setup)
#include "DPAcustomHandler.h"
// I2C Master library
#include "lib/I2Cmaster.c"

//############################################################################################

// I2C SCL frequency [Hz]
#define I2Cfrequency        50000

#define I2C_ADR         	0b10010110
#define PWR_SENSOR_TRIS 	TRISC.7
#define PWR_SENSOR_IO   	LATC.7

// Must be the 1st defined function in the source code in order to be placed at the correct FLASH location!
//############################################################################################
bit CustomDpaHandler()
//############################################################################################
{
  // Handler presence mark
  clrwdt();

  // Detect DPA event to handle
  switch ( GetDpaEvent() )
  {
    // -------------------------------------------------
    case DpaEvent_Interrupt:
      // Do an extra quick background interrupt work
      // ! The time spent handling this event is critical.If there is no interrupt to handle return immediately otherwise keep the code as fast as possible.
      // ! Make sure the event is the 1st case in the main switch statement at the handler routine.This ensures that the event is handled as the 1st one.
      // ! It is desirable that this event is handled with immediate return even if it is not used by the custom handler because the Interrupt event is raised on every MCU interrupt and the “empty” return handler ensures the shortest possible interrupt routine response time.
      // ! Only global variables or local ones marked by static keyword can be used to allow reentrancy.
      // ! Make sure race condition does not occur when accessing those variables at other places.
      // ! Make sure( inspect.lst file generated by C compiler ) compiler does not create any hidden temporary local variable( occurs when using division, multiplication or bit shifts ) at the event handler code.The name of such variable is usually Cnumbercnt.
      // ! Do not call any OS functions except setINDFx().
      // ! Do not use any OS variables especially for writing access.
      // ! All above rules apply also to any other function being called from the event handler code, although calling any function from Interrupt event is not recommended because of additional MCU stack usage.

DpaHandleReturnTRUE:
      return TRUE;

      // -------------------------------------------------
    case DpaEvent_Init:
      // Do a one time initialization before main loop starts
    case DpaEvent_AfterSleep:
      // Called after woken up after sleep

      PORTC = 0x80;                       // port

      PWR_SENSOR_TRIS = 0;                // sensor power as output (SIM C8)
      TRISC.5 = 1;                        // shared with SIM C8

      TRISA.5 = 1;                        // sensor ALERT as input (SIM C5)
      TRISB.4 = 1;                        // shared with SIM C5
      TRISC.6 = 1;                        // shared with SIM C5
      i2c_init();

      break;

      // -------------------------------------------------
    case DpaEvent_BeforeSleep:
      // Called before going to sleep

      i2c_shutdown();
      break;

      // -------------------------------------------------
    case DpaEvent_DpaRequest:
      // Called to interpret DPA request for peripherals
      // -------------------------------------------------
      // Peripheral enumeration
      if ( IsDpaEnumPeripheralsRequest() )
      {
        // We implement 1 user peripheral
        _DpaMessage.EnumPeripheralsAnswer.UserPerNr = 1;
        FlagUserPer( _DpaMessage.EnumPeripheralsAnswer.UserPer, PNUM_USER + 0 );
        _DpaMessage.EnumPeripheralsAnswer.HWPID = 0x000F;
        _DpaMessage.EnumPeripheralsAnswer.HWPIDver = 0xAbCd;

        goto DpaHandleReturnTRUE;
      }
      // -------------------------------------------------
      // Get information about peripheral
      else if ( IsDpaPeripheralInfoRequest() )
      {
        if ( _PNUM == PNUM_USER + 0 )
        {
          _DpaMessage.PeripheralInfoAnswer.PerT = PERIPHERAL_TYPE_USER_AREA;
          _DpaMessage.PeripheralInfoAnswer.PerTE = PERIPHERAL_TYPE_EXTENDED_READ;
          goto DpaHandleReturnTRUE;
        }

        break;
      }
      // -------------------------------------------------
      else
      {
        // Handle peripheral command
        if ( _PNUM == PNUM_USER + 0 )
        {
          // Check command
          switch ( _PCMD )
          {
            case 0:
              // -------------------------------------------------
              // Read temperature
              if ( _DpaDataLength != 0 )
                DpaApiReturnPeripheralError( ERROR_DATA_LEN );

              i2c_start( I2C_ADR );                 // MCP9802 address
              i2c_write( 0x01 );                    // pointer: 1 = configuration register
              i2c_write( 0x60 );                    // configuration: 12-bit ADC
              i2c_stop();

              i2c_start( I2C_ADR );                 // MCP9802 address
              i2c_write( 0 );                       // pointer: 0 = temperature
              i2c_stop();

              i2c_start( I2C_ADR | 1 );             // MCP9802 address + read
              uns16 temperature  @ _DpaMessage.Response.PData;
              temperature.high8 = i2c_read( TRUE );  // store the result
              temperature.low8 = i2c_read( FALSE );
              i2c_stop();

              _DpaDataLength = sizeof( temperature );
              goto DpaHandleReturnTRUE;

            default:
              // -------------------------------------------------
              // Invalid command
              DpaApiReturnPeripheralError( ERROR_PCMD );
          }
        }
      }
  }

  return FALSE;
}

//############################################################################################
// I2C Master library
#include "lib/I2Cmaster.c"
// Default Custom DPA Handler header; 2nd include to implement Code bumper to detect too long code of the Custom DPA Handler (modify the path according to your setup) 
#include "DPAcustomHandler.h"
//############################################################################################
