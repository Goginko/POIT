// *********************************************************************
//   Custom DPA Handler code example - Peripheral memory mapping       *
// *********************************************************************
// Copyright (c) IQRF Tech s.r.o.
//
// File:    $RCSfile: CustomDpaHandler-PeripheralMemoryMapping.c,v $
// Version: $Revision: 1.29 $
// Date:    $Date: 2020/01/03 13:56:50 $
//
// Revision history:
//   2018/10/25  Release for DPA 3.03
//   2017/03/13  Release for DPA 3.00
//   2015/08/05  Release for DPA 2.20
//   2014/10/31  Release for DPA 2.10
//   2014/04/30  Release for DPA 2.00
//
// *********************************************************************

// Online DPA documentation https://doc.iqrf.org/DpaTechGuide/

// Default IQRF include (modify the path according to your setup)
#include "IQRF.h"

// Uncomment to implement Custom DPA Handler for Coordinator
//#define COORDINATOR_CUSTOM_HANDLER

// Default DPA header (modify the path according to your setup)
#include "DPA.h"
// Default Custom DPA Handler header (modify the path according to your setup)
#include "DPAcustomHandler.h"

// The application demonstrates mapping of the actual MCU peripherals to the RAM peripheral
// PeripheralRam[0].0 = LEDR status (read/write)
// PeripheralRam[0].1 = LEDG status (read/write)
// PeripheralRam[1].0 = LEDR status invert request (write)
// PeripheralRam[1].1 = LEDG status invert request (write)
// PeripheralRam[2].0 = Button status (read)
// PeripheralRam[3].0 = Temperature (read)

// Must be the 1st defined function in the source code in order to be placed at the correct FLASH location!
//############################################################################################
bit CustomDpaHandler()
//############################################################################################
{
  // Peripheral RAM mapping structure
  struct
  {
    // Actual LED state
    uns8	LEDstate;
    // Request to invert LED state
    uns8	LEDinvert;
    // Button state
    uns8	Button;
    // Measured temperature
    uns8	Temperature;
  } Mapping @ PeripheralRam;

  // Handler presence mark
  clrwdt();

  // Flags that the RAM was written
  static bit ramWritten;

  // Detect DPA event to handle (unused event handlers can be commented out or even deleted)
  switch ( GetDpaEvent() )
  {
#ifdef DpaEvent_Interrupt
    // -------------------------------------------------
    case DpaEvent_Interrupt:
      // Do an extra quick background interrupt work
      // ! The time spent handling this event is critical.If there is no interrupt to handle return immediately otherwise keep the code as fast as possible.
      // ! Make sure the event is the 1st case in the main switch statement at the handler routine.This ensures that the event is handled as the 1st one.
      // ! It is desirable that this event is handled with immediate return even if it is not used by the custom handler because the Interrupt event is raised on every MCU interrupt and the “empty” return handler ensures the shortest possible interrupt routine response time.
      // ! Only global variables or local ones marked by static keyword can be used to allow reentrancy.
      // ! Make sure race condition does not occur when accessing those variables at other places.
      // ! Make sure( inspect.lst file generated by C compiler ) compiler does not create any hidden temporary local variable( occurs when using division, multiplication or bit shifts ) at the event handler code.The name of such variable is usually Cnumbercnt.
      // ! Do not call any OS functions except setINDFx().
      // ! Do not use any OS variables especially for writing access.
      // ! All above rules apply also to any other function being called from the event handler code, although calling any function from Interrupt event is not recommended because of additional MCU stack usage.

      return Carry;
#endif

      // -------------------------------------------------
    case DpaEvent_ReceiveDpaRequest:
      // Called after DPA request was received

      // RAM peripheral read request 
      // (could be optimized by checking the RAM address to read from and based on its value skipping e.g. temperature measurement)
      if ( _PNUM == PNUM_RAM && _PCMD == CMD_RAM_READ )
      {
        // Read button state
        W = 0;
        if ( buttonPressed )
          W = 1;
        Mapping.Button = W;
        // Read temperature
        Mapping.Temperature = getTemperature();
      }

      break;

      // -------------------------------------------------
    case DpaEvent_Notification:
      // Called after DPA request was processed and after DPA response was sent

      // Anything written to the RAM?
      // (could be optimized by checking the RAM address that was written to and based on its value skipping LEDs update)
      if ( _PNUM == PNUM_RAM && _PCMD == CMD_RAM_WRITE )
        ramWritten = TRUE;

      break;

      // -------------------------------------------------
    case DpaEvent_AfterRouting:
      // Called after Notification and after routing of the DPA response was finished

      // Something was written to the RAM? 
      // Update LEDs at the defined after routing time i.e. at the same time at all nodes when addressed by broadcast
      if ( ramWritten )
      {
        ramWritten = FALSE;

        // Update LEDs state
        Mapping.LEDstate ^= Mapping.LEDinvert;
        Mapping.LEDinvert = 0;

        // Update LEDR
        if ( Mapping.LEDstate.0 )
          setLEDR();
        else
          stopLEDR(); // Must be used when pulseLEDR is used

        // Update LEDG
        if ( Mapping.LEDstate.1 )
          setLEDG();
        else
          stopLEDG(); // Must be used when pulseLEDR is used

        // Make sure LED is visible at LP mode
        waitMS( 20 );
      }

      break;

      // -------------------------------------------------
    case DpaEvent_DpaRequest:
      // Called to interpret DPA request for peripherals
      // -------------------------------------------------
      // Peripheral enumeration
      if ( IsDpaEnumPeripheralsRequest() )
      {
        _DpaMessage.EnumPeripheralsAnswer.HWPID = 0x000F;
        _DpaMessage.EnumPeripheralsAnswer.HWPIDver = 0xABCD;

DpaHandleReturnTRUE:
        return TRUE;
      }

      break;
  }

  return FALSE;
}
//############################################################################################
// Default Custom DPA Handler header; 2nd include to implement Code bumper to detect too long code of the Custom DPA Handler (modify the path according to your setup) 
#include "DPAcustomHandler.h"
//############################################################################################
