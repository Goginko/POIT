CC5X Version 3.7D,   File: D:\DP\IQRF_Startup_Package_OS403D_TR-7xD_200302\IQRF_OS403_7xD\Examples\DPA\CustomDpaHandlerExamples\IQRF_Standard\4C02_DDC-SE_LP.c 28. Mar 2020  11:18   Page 1

ADDR CODE  LINE SOURCE

           0001 
           0002 ; CC5X Version 3.7D, Copyright (c) B Knudsen Data
           0003 ; C compiler for the PICmicro family
           0004 ; ************  28. Mar 2020  11:18  *************
           0005 
           0006         processor  16F1938
           0007         radix  DEC
           0008 
     0001  0009 INDF1       EQU   0x01
     0006  0010 FSR1        EQU   0x06
     0006  0011 FSR1L       EQU   0x06
     0009  0012 WREG        EQU   0x09
     0000  0013 Carry       EQU   0
     0002  0014 Zero_       EQU   2
     000E  0015 PORTC       EQU   0x0E
     008C  0016 TRISA       EQU   0x8C
     008D  0017 TRISB       EQU   0x8D
     008E  0018 TRISC       EQU   0x8E
     009C  0019 ADRESH      EQU   0x9C
     009D  0020 ADCON0      EQU   0x9D
     009E  0021 ADCON1      EQU   0x9E
     010E  0022 LATC        EQU   0x10E
     018C  0023 ANSELA      EQU   0x18C
     0007  0024 GIE         EQU   7
     0001  0025 GO          EQU   1
     0320  0026 bufferINFO  EQU   0x320
     0070  0027 userReg0    EQU   0x70
     0074  0028 param3      EQU   0x74
     05BC  0029 responseFRCvalue EQU   0x5BC
     05BC  0030 responseFRCvalue2B EQU   0x5BC
     02A1  0031 DLEN        EQU   0x2A1
     02AE  0032 PNUM        EQU   0x2AE
     02AF  0033 PCMD        EQU   0x2AF
     04C0  0034 DataOutBeforeResponseFRC EQU   0x4C0
     04A0  0035 DpaRfMessage EQU   0x4A0
     0073  0036 par1        EQU   0x73
     04A0  0037 _DpaMessageIqrfStd EQU   0x4A0
     0074  0038 sensorValue EQU   0x74
     05C5  0039 temperature EQU   0x5C5
     05C7  0040 PerOSSleep_Request EQU   0x5C7
     05CA  0041 state       EQU   0x5CA
     05CB  0042 temperatureByteLow EQU   0x5CB
     05CC  0043 timeoutStart EQU   0x5CC
     05C0  0044 sensorsBitmap EQU   0x5C0
     05C0  0045 sensorIndex EQU   0x5C0
     05C1  0046 sensorType  EQU   0x5C1
     0000  0047 sensorError EQU   0
     05C1  0048 _sensorValue EQU   0x5C1
     05C3  0049 C1cnt       EQU   0x5C3
     05C1  0050 bitLoop     EQU   0x5C1
     05C2  0051 byte        EQU   0x5C2
     05C3  0052 bitLoop_2   EQU   0x5C3
     05C0  0053 result      EQU   0x5C0
     05C1  0054 bitLoop_3   EQU   0x5C1
     05C1  0055 cmd         EQU   0x5C1
     05C0  0056 value_4     EQU   0x5C0
           0057 
0000 2900  0058         GOTO main
           0059 
           0060   ; FILE ../../../../Development/include/IQRF_OS/IQRF.h
           0061                         ;// *********************************************************************
           0062                         ;// *                   IQRF OS basic include file                      *
           0063                         ;// *********************************************************************
           0064                         ;//
           0065                         ;// Online IQRF OS Reference Guide: http://www.iqrf.org/IQRF-OS-Reference-guide/
           0066                         ;//
           0067                         ;// Copyright (c) IQRF Tech s.r.o.
           0068                         ;//
           0069                         ;// Intended for:
           0070                         ;//	 HW: TR-72D, TR-76D, TR-77D, TR-78D, TR-75D
           0071                         ;//   OS: v4.03D
           0072                         ;//
           0073                         ;// File:    IQRF.h
           0074                         ;// Version: v1.00                                   Revision: 10/05/2018
           0075                         ;//
           0076                         ;// Revision history:
           0077                         ;//	 v1.00: 10/05/2018 	First release for OS 4.03D.
           0078                         ;//
           0079                         ;// *********************************************************************
           0080                         ;
           0081                         ;#if IQRFOS != 403
           0082                         ;    #error Invalid IQRF OS version, V4.03 is expected. Make sure matching header files and project IQRF OS version setting are used.
           0083                         ;#endif
           0084                         ;
           0085                         ;#if defined TR72D
           0086                         ;    #message Compilation for TR-72D modules (PIC16LF1938) and IQRF OS 4.03D.
           0087                         ;    #define TR7xD
           0088                         ;#elif defined TR76D
           0089                         ;    #message Compilation for TR-76D modules (PIC16LF1938) and IQRF OS 4.03D.
           0090                         ;    #define TR7xD
           0091                         ;#elif defined TR77D
           0092                         ;    #message Compilation for TR-77D modules (PIC16LF1938) and IQRF OS 4.03D.
           0093                         ;    #define TR7xD
           0094                         ;#elif defined TR78D
           0095                         ;    #message Compilation for TR-78D modules (PIC16LF1938) and IQRF OS 4.03D.
           0096                         ;    #define TR7xD
           0097                         ;#elif defined TR75D
           0098                         ;    #message Compilation for TR-75D modules (PIC16LF1938) and IQRF OS 4.03D.
           0099                         ;    #define TR7xD
           0100                         ;#else
           0101                         ;    #error Unsupported TR module type.
           0102                         ;#endif
           0103                         ;
           0104                         ;#pragma chip PIC16F1938
           0105                         ;
           0106                         ;#if __CC5X__ < 3701
           0107                         ;    #warning Insufficient CC5X compiler version, V3.7A is recommended.
           0108                         ;#endif
           0109                         ;
           0110                         ;#pragma origin 0x100
     0000  0111         ORG 0x0100
           0112                         ;#pragma update_RP 0
           0113                         ;
           0114                         ;void APPLICATION();
           0115                         ;
           0116                         ;void main()                                	// Skipped during Upload
           0117                         ;{
           0118 main
           0119                         ;    APPLICATION();
0100 31B8  0120         MOVLP 0x38
0101 2200  0121         CALL  APPLICATION
0102 3180  0122         MOVLP 0x00
           0123                         ;}
0103 0063  0124         SLEEP
0104 2900  0125         GOTO main
           0126 
           0127   ; FILE ../../../../Development/include/IQRF_OS/IQRF-functions.h
           0128                         ;// *********************************************************************
           0129                         ;//      				   IQRF OS functions						   *
           0130                         ;// *********************************************************************
           0131                         ;// Intended for:
           0132                         ;//    OS: v4.03D
           0133                         ;//
           0134                         ;// Online IQRF OS Reference Guide: http://www.iqrf.org/IQRF-OS-Reference-guide/
           0135                         ;//
           0136                         ;// Copyright (c) IQRF Tech s.r.o.
           0137                         ;//
           0138                         ;// File:    IQRF-functions.h
           0139                         ;// Version: v1.00                                   Revision: 27/06/2018
           0140                         ;//
           0141                         ;// Revision history:
           0142                         ;//   v1.00: 27/06/2018  First release for OS 4.03D.
           0143                         ;//
           0144                         ;// *********************************************************************
           0145                         ; 
           0146                         ;#pragma optimize 0
           0147                         ;#pragma update_PAGE 0
           0148                         ;#pragma update_RP 0
           0149                         ;
           0150                         ;#define	dummy_address	0x3810
           0151                         ;#pragma origin dummy_address
     0000  0152         ORG 0x3810
           0153                         ;void dummy()
           0154                         ;{
           0155 dummy
           0156                         ;  #asm
           0157                         ;    DW 0x2000
3810 2000  0158         DW    0x2000
           0159                         ;  #endasm
           0160                         ;  #pragma updateBank exit=UserBank_01
           0161                         ;}
3811 0008  0162         RETURN
           0163                         ;
           0164                         ;#define	iqrfSleep_address	0x3816
           0165                         ;#pragma origin iqrfSleep_address
     0000  0166         ORG 0x3816
           0167                         ;void iqrfSleep()
           0168                         ;{
           0169 iqrfSleep
           0170                         ;  #asm
           0171                         ;    DW 0x2000
3816 2000  0172         DW    0x2000
           0173                         ;  #endasm
           0174                         ;  #pragma updateBank exit=UserBank_01
           0175                         ;}
3817 0008  0176         RETURN
           0177                         ;
           0178                         ;#define	_debug_address	0x3819
           0179                         ;#pragma origin _debug_address
     0000  0180         ORG 0x3819
           0181                         ;void _debug()
           0182                         ;{
           0183 _debug
           0184                         ;  #asm
           0185                         ;    DW 0x2000
3819 2000  0186         DW    0x2000
           0187                         ;  #endasm
           0188                         ;  #pragma updateBank exit=UserBank_01
           0189                         ;}
381A 0008  0190         RETURN
           0191                         ;
           0192                         ;#define debug()	    \
           0193                         ;	do {			\
           0194                         ;		_debug();	\
           0195                         ;        nop();      \
           0196                         ;	} while (0)
           0197                         ;
           0198                         ;#define	moduleInfo_address	0x381c
           0199                         ;#pragma origin moduleInfo_address
     0000  0200         ORG 0x381C
           0201                         ;void moduleInfo()
           0202                         ;{
           0203 moduleInfo
           0204                         ;  #asm
           0205                         ;    DW 0x2000
381C 2000  0206         DW    0x2000
           0207                         ;  #endasm
           0208                         ;  #pragma updateBank exit=UserBank_01
           0209                         ;}
381D 0008  0210         RETURN
           0211                         ;
           0212                         ;#define	pulsingLEDR_address	0x3822
           0213                         ;#pragma origin pulsingLEDR_address
     0000  0214         ORG 0x3822
           0215                         ;void pulsingLEDR()
           0216                         ;{
           0217 pulsingLEDR
           0218                         ;  #asm
           0219                         ;    DW 0x2000
3822 2000  0220         DW    0x2000
           0221                         ;  #endasm
           0222                         ;  #pragma updateBank exit=UserBank_01
           0223                         ;}
3823 0008  0224         RETURN
           0225                         ;
           0226                         ;#define	pulseLEDR_address	0x3825
           0227                         ;#pragma origin pulseLEDR_address
     0000  0228         ORG 0x3825
           0229                         ;void pulseLEDR()
           0230                         ;{
           0231 pulseLEDR
           0232                         ;  #asm
           0233                         ;    DW 0x2000
3825 2000  0234         DW    0x2000
           0235                         ;  #endasm
           0236                         ;  #pragma updateBank exit=UserBank_01
           0237                         ;}
3826 0008  0238         RETURN
           0239                         ;
           0240                         ;#define	stopLEDR_address	0x3828
           0241                         ;#pragma origin stopLEDR_address
     0000  0242         ORG 0x3828
           0243                         ;void stopLEDR()
           0244                         ;{
           0245 stopLEDR
           0246                         ;  #asm
           0247                         ;    DW 0x2000
3828 2000  0248         DW    0x2000
           0249                         ;  #endasm
           0250                         ;  #pragma updateBank exit=UserBank_01
           0251                         ;}
3829 0008  0252         RETURN
           0253                         ;
           0254                         ;#define	pulsingLEDG_address	0x382b
           0255                         ;#pragma origin pulsingLEDG_address
     0000  0256         ORG 0x382B
           0257                         ;void pulsingLEDG()
           0258                         ;{
           0259 pulsingLEDG
           0260                         ;  #asm
           0261                         ;    DW 0x2000
382B 2000  0262         DW    0x2000
           0263                         ;  #endasm
           0264                         ;  #pragma updateBank exit=UserBank_01
           0265                         ;}
382C 0008  0266         RETURN
           0267                         ;
           0268                         ;#define	pulseLEDG_address	0x382e
           0269                         ;#pragma origin pulseLEDG_address
     0000  0270         ORG 0x382E
           0271                         ;void pulseLEDG()
           0272                         ;{
           0273 pulseLEDG
           0274                         ;  #asm
           0275                         ;    DW 0x2000
382E 2000  0276         DW    0x2000
           0277                         ;  #endasm
           0278                         ;  #pragma updateBank exit=UserBank_01
           0279                         ;}
382F 0008  0280         RETURN
           0281                         ;
           0282                         ;#define	stopLEDG_address	0x3831
           0283                         ;#pragma origin stopLEDG_address
     0000  0284         ORG 0x3831
           0285                         ;void stopLEDG()
           0286                         ;{
           0287 stopLEDG
           0288                         ;  #asm
           0289                         ;    DW 0x2000
3831 2000  0290         DW    0x2000
           0291                         ;  #endasm
           0292                         ;  #pragma updateBank exit=UserBank_01
           0293                         ;}
3832 0008  0294         RETURN
           0295                         ;
           0296                         ;#define	setOnPulsingLED_address	0x3834
           0297                         ;#pragma origin setOnPulsingLED_address
     0000  0298         ORG 0x3834
           0299                         ;void setOnPulsingLED(uns8 ticks @ W)
           0300                         ;{
           0301 setOnPulsingLED
           0302                         ;  #asm
           0303                         ;    DW 0x2000
3834 2000  0304         DW    0x2000
           0305                         ;  #endasm
           0306                         ;  #pragma updateBank exit=UserBank_01
           0307                         ;}
3835 0008  0308         RETURN
           0309                         ;
           0310                         ;#define	setOffPulsingLED_address	0x3837
           0311                         ;#pragma origin setOffPulsingLED_address
     0000  0312         ORG 0x3837
           0313                         ;void setOffPulsingLED(uns8 ticks @ W)
           0314                         ;{
           0315 setOffPulsingLED
           0316                         ;  #asm
           0317                         ;    DW 0x2000
3837 2000  0318         DW    0x2000
           0319                         ;  #endasm
           0320                         ;  #pragma updateBank exit=UserBank_01
           0321                         ;}
3838 0008  0322         RETURN
           0323                         ;
           0324                         ;#define	eeReadByte_address	0x383a
           0325                         ;#pragma origin eeReadByte_address
     0000  0326         ORG 0x383A
           0327                         ;uns8 eeReadByte(uns8 address @ W)
           0328                         ;{
           0329 eeReadByte
           0330                         ;  #asm
           0331                         ;    DW 0x2000
383A 2000  0332         DW    0x2000
           0333                         ;  #endasm
           0334                         ;  #pragma updateBank exit=UserBank_01
           0335                         ;  return 1;
383B 3401  0336         RETLW 0x01
           0337                         ;}
           0338                         ;
           0339                         ;#define	eeReadData_address	0x383d
           0340                         ;#pragma origin eeReadData_address
     0000  0341         ORG 0x383D
           0342                         ;bit eeReadData(uns8 address @ param2, uns8 length @ W)
           0343                         ;{
           0344 eeReadData
           0345                         ;  #asm
           0346                         ;    DW 0x2000
383D 2000  0347         DW    0x2000
           0348                         ;  #endasm
           0349                         ;  #pragma updateBank exit=UserBank_01
           0350                         ;  return Carry;
383E 0008  0351         RETURN
           0352                         ;}
           0353                         ;
           0354                         ;#define	eeWriteByte_address	0x3840
           0355                         ;#pragma origin eeWriteByte_address
     0000  0356         ORG 0x3840
           0357                         ;void eeWriteByte(uns8 address @ param2, uns8 data @ W)
           0358                         ;{
           0359 eeWriteByte
           0360                         ;  #asm
           0361                         ;    DW 0x2000
3840 2000  0362         DW    0x2000
           0363                         ;  #endasm
           0364                         ;  #pragma updateBank exit=UserBank_01
           0365                         ;}
3841 0008  0366         RETURN
           0367                         ;
           0368                         ;#define	eeWriteData_address	0x3843
           0369                         ;#pragma origin eeWriteData_address
     0000  0370         ORG 0x3843
           0371                         ;void eeWriteData(uns8 address @ param2, uns8 length @ W)
           0372                         ;{
           0373 eeWriteData
           0374                         ;  #asm
           0375                         ;    DW 0x2000
3843 2000  0376         DW    0x2000
           0377                         ;  #endasm
           0378                         ;  #pragma updateBank exit=UserBank_01
           0379                         ;}
3844 0008  0380         RETURN
           0381                         ;
           0382                         ;#define	readFromRAM_address	0x3846
           0383                         ;#pragma origin readFromRAM_address
     0000  0384         ORG 0x3846
           0385                         ;uns8 readFromRAM(uns16 address @ FSR0)
           0386                         ;{
           0387 readFromRAM
           0388                         ;  #asm
           0389                         ;    DW 0x2000
3846 2000  0390         DW    0x2000
           0391                         ;  #endasm
           0392                         ;  #pragma updateBank exit=UserBank_01
           0393                         ;  return 1;
3847 3401  0394         RETLW 0x01
           0395                         ;}
           0396                         ;
           0397                         ;#define	clearBufferINFO_address	0x384c
           0398                         ;#pragma origin clearBufferINFO_address
     0000  0399         ORG 0x384C
           0400                         ;void clearBufferINFO()
           0401                         ;{
           0402 clearBufferINFO
           0403                         ;  #asm
           0404                         ;    DW 0x2000
384C 2000  0405         DW    0x2000
           0406                         ;  #endasm
           0407                         ;  #pragma updateBank exit=UserBank_01
           0408                         ;}
384D 0008  0409         RETURN
           0410                         ;
           0411                         ;#define	swapBufferINFO_address	0x384f
           0412                         ;#pragma origin swapBufferINFO_address
     0000  0413         ORG 0x384F
           0414                         ;void swapBufferINFO()
           0415                         ;{
           0416 swapBufferINFO
           0417                         ;  #asm
           0418                         ;    DW 0x2000
384F 2000  0419         DW    0x2000
           0420                         ;  #endasm
           0421                         ;  #pragma updateBank exit=UserBank_01
           0422                         ;}
3850 0008  0423         RETURN
           0424                         ;
           0425                         ;#define	compareBufferINFO2RF_address	0x3852
           0426                         ;#pragma origin compareBufferINFO2RF_address
     0000  0427         ORG 0x3852
           0428                         ;bit compareBufferINFO2RF(uns8 length @ W)
           0429                         ;{
           0430 compareBufferINFO2RF
           0431                         ;  #asm
           0432                         ;    DW 0x2000
3852 2000  0433         DW    0x2000
           0434                         ;  #endasm
           0435                         ;  #pragma updateBank exit=UserBank_01
           0436                         ;  return Carry;
3853 0008  0437         RETURN
           0438                         ;}
           0439                         ;
           0440                         ;#define	copyBufferINFO2COM_address	0x3855
           0441                         ;#pragma origin copyBufferINFO2COM_address
     0000  0442         ORG 0x3855
           0443                         ;void copyBufferINFO2COM()
           0444                         ;{
           0445 copyBufferINFO2COM
           0446                         ;  #asm
           0447                         ;    DW 0x2000
3855 2000  0448         DW    0x2000
           0449                         ;  #endasm
           0450                         ;  #pragma updateBank exit=UserBank_01
           0451                         ;}
3856 0008  0452         RETURN
           0453                         ;
           0454                         ;#define	copyBufferINFO2RF_address	0x3858
           0455                         ;#pragma origin copyBufferINFO2RF_address
     0000  0456         ORG 0x3858
           0457                         ;void copyBufferINFO2RF()
           0458                         ;{
           0459 copyBufferINFO2RF
           0460                         ;  #asm
           0461                         ;    DW 0x2000
3858 2000  0462         DW    0x2000
           0463                         ;  #endasm
           0464                         ;  #pragma updateBank exit=UserBank_01
           0465                         ;}
3859 0008  0466         RETURN
           0467                         ;
           0468                         ;#define	copyBufferRF2COM_address	0x385b
           0469                         ;#pragma origin copyBufferRF2COM_address
     0000  0470         ORG 0x385B
           0471                         ;void copyBufferRF2COM()
           0472                         ;{
           0473 copyBufferRF2COM
           0474                         ;  #asm
           0475                         ;    DW 0x2000
385B 2000  0476         DW    0x2000
           0477                         ;  #endasm
           0478                         ;  #pragma updateBank exit=UserBank_01
           0479                         ;}
385C 0008  0480         RETURN
           0481                         ;
           0482                         ;#define	copyBufferRF2INFO_address	0x385e
           0483                         ;#pragma origin copyBufferRF2INFO_address
     0000  0484         ORG 0x385E
           0485                         ;void copyBufferRF2INFO()
           0486                         ;{
           0487 copyBufferRF2INFO
           0488                         ;  #asm
           0489                         ;    DW 0x2000
385E 2000  0490         DW    0x2000
           0491                         ;  #endasm
           0492                         ;  #pragma updateBank exit=UserBank_01
           0493                         ;}
385F 0008  0494         RETURN
           0495                         ;
           0496                         ;#define	copyBufferCOM2RF_address	0x3861
           0497                         ;#pragma origin copyBufferCOM2RF_address
     0000  0498         ORG 0x3861
           0499                         ;void copyBufferCOM2RF()
           0500                         ;{
           0501 copyBufferCOM2RF
           0502                         ;  #asm
           0503                         ;    DW 0x2000
3861 2000  0504         DW    0x2000
           0505                         ;  #endasm
           0506                         ;  #pragma updateBank exit=UserBank_01
           0507                         ;}
3862 0008  0508         RETURN
           0509                         ;
           0510                         ;#define	copyBufferCOM2INFO_address	0x3864
           0511                         ;#pragma origin copyBufferCOM2INFO_address
     0000  0512         ORG 0x3864
           0513                         ;void copyBufferCOM2INFO()
           0514                         ;{
           0515 copyBufferCOM2INFO
           0516                         ;  #asm
           0517                         ;    DW 0x2000
3864 2000  0518         DW    0x2000
           0519                         ;  #endasm
           0520                         ;  #pragma updateBank exit=UserBank_01
           0521                         ;}
3865 0008  0522         RETURN
           0523                         ;
           0524                         ;#define	copyMemoryBlock_address	0x3867
           0525                         ;#pragma origin copyMemoryBlock_address
     0000  0526         ORG 0x3867
           0527                         ;void copyMemoryBlock(uns16 from @ FSR0, uns16 to @ FSR1, uns8 length @ W)
           0528                         ;{
           0529 copyMemoryBlock
           0530                         ;  #asm
           0531                         ;    DW 0x2000
3867 2000  0532         DW    0x2000
           0533                         ;  #endasm
           0534                         ; #pragma updateBank exit=UserBank_01
           0535                         ;}
3868 0008  0536         RETURN
           0537                         ;
           0538                         ;#define	startDelay_address	0x386a
           0539                         ;#pragma origin startDelay_address
     0000  0540         ORG 0x386A
           0541                         ;void startDelay(uns8 ticks @ W)
           0542                         ;{
           0543 startDelay
           0544                         ;  #asm
           0545                         ;    DW 0x2000
386A 2000  0546         DW    0x2000
           0547                         ;  #endasm
           0548                         ;  #pragma updateBank exit=UserBank_01
           0549                         ;}
386B 0008  0550         RETURN
           0551                         ;
           0552                         ;#define	startLongDelay_address	0x386d
           0553                         ;#pragma origin startLongDelay_address
     0000  0554         ORG 0x386D
           0555                         ;void startLongDelay(uns16 ticks @ param3)
           0556                         ;{
           0557 startLongDelay
           0558                         ;  #asm
           0559                         ;    DW 0x2000
386D 2000  0560         DW    0x2000
           0561                         ;  #endasm
           0562                         ;  #pragma updateBank exit=UserBank_01
           0563                         ;}
386E 0008  0564         RETURN
           0565                         ;
           0566                         ;#define	isDelay_address	0x3870
           0567                         ;#pragma origin isDelay_address
     0000  0568         ORG 0x3870
           0569                         ;bit isDelay()
           0570                         ;{
           0571 isDelay
           0572                         ;  #asm
           0573                         ;    DW 0x2000
3870 2000  0574         DW    0x2000
           0575                         ;  #endasm
           0576                         ;  #pragma updateBank exit=UserBank_01
           0577                         ;  return Carry;
3871 0008  0578         RETURN
           0579                         ;}
           0580                         ;
           0581                         ;#define	waitDelay_address	0x3873
           0582                         ;#pragma origin waitDelay_address
     0000  0583         ORG 0x3873
           0584                         ;void waitDelay(uns8 ticks @ W)
           0585                         ;{
           0586 waitDelay
           0587                         ;  #asm
           0588                         ;    DW 0x2000
3873 2000  0589         DW    0x2000
           0590                         ;  #endasm
           0591                         ;  #pragma updateBank exit=UserBank_01
           0592                         ;}
3874 0008  0593         RETURN
           0594                         ;
           0595                         ;#define	waitMS_address	0x3876
           0596                         ;#pragma origin waitMS_address
     0000  0597         ORG 0x3876
           0598                         ;void waitMS(uns8 ms @ W)
           0599                         ;{
           0600 waitMS
           0601                         ;  #asm
           0602                         ;    DW 0x2000
3876 2000  0603         DW    0x2000
           0604                         ;  #endasm
           0605                         ;  #pragma updateBank exit=UserBank_01
           0606                         ;}
3877 0008  0607         RETURN
           0608                         ;
           0609                         ;#define	startCapture_address	0x3879
           0610                         ;#pragma origin startCapture_address
     0000  0611         ORG 0x3879
           0612                         ;void startCapture()
           0613                         ;{
           0614 startCapture
           0615                         ;  #asm
           0616                         ;    DW 0x2000
3879 2000  0617         DW    0x2000
           0618                         ;  #endasm
           0619                         ;  #pragma updateBank exit=UserBank_01
           0620                         ;}
387A 0008  0621         RETURN
           0622                         ;
           0623                         ;#define	captureTicks_address	0x387c
           0624                         ;#pragma origin captureTicks_address
     0000  0625         ORG 0x387C
           0626                         ;void captureTicks()
           0627                         ;{
           0628 captureTicks
           0629                         ;  #asm
           0630                         ;    DW 0x2000
387C 2000  0631         DW    0x2000
           0632                         ;  #endasm
           0633                         ;  #pragma updateBank exit=UserBank_01
           0634                         ;}
387D 0008  0635         RETURN
           0636                         ;
           0637                         ;#define	waitNewTick_address	0x3882
           0638                         ;#pragma origin waitNewTick_address
     0000  0639         ORG 0x3882
           0640                         ;void waitNewTick()
           0641                         ;{
           0642 waitNewTick
           0643                         ;  #asm
           0644                         ;    DW 0x2000
3882 2000  0645         DW    0x2000
           0646                         ;  #endasm
           0647                         ;  #pragma updateBank exit=UserBank_01
           0648                         ;}
3883 0008  0649         RETURN
           0650                         ;
           0651                         ;#define	enableSPI_address	0x3885
           0652                         ;#pragma origin enableSPI_address
     0000  0653         ORG 0x3885
           0654                         ;void enableSPI()
           0655                         ;{
           0656 enableSPI
           0657                         ;  #asm
           0658                         ;    DW 0x2000
3885 2000  0659         DW    0x2000
           0660                         ;  #endasm
           0661                         ;  #pragma updateBank exit=UserBank_01
           0662                         ;}
3886 0008  0663         RETURN
           0664                         ;
           0665                         ;#define	disableSPI_address	0x3888
           0666                         ;#pragma origin disableSPI_address
     0000  0667         ORG 0x3888
           0668                         ;void disableSPI()
           0669                         ;{
           0670 disableSPI
           0671                         ;  #asm
           0672                         ;    DW 0x2000
3888 2000  0673         DW    0x2000
           0674                         ;  #endasm
           0675                         ;  #pragma updateBank exit=UserBank_01
           0676                         ;}
3889 0008  0677         RETURN
           0678                         ;
           0679                         ;#define	startSPI_address	0x388b
           0680                         ;#pragma origin startSPI_address
     0000  0681         ORG 0x388B
           0682                         ;void startSPI(uns8 length @ W)
           0683                         ;{
           0684 startSPI
           0685                         ;  #asm
           0686                         ;    DW 0x2000
388B 2000  0687         DW    0x2000
           0688                         ;  #endasm
           0689                         ;  #pragma updateBank exit=UserBank_01
           0690                         ;}
388C 0008  0691         RETURN
           0692                         ;
           0693                         ;#define	stopSPI_address	0x388e
           0694                         ;#pragma origin stopSPI_address
     0000  0695         ORG 0x388E
           0696                         ;void stopSPI()
           0697                         ;{
           0698 stopSPI
           0699                         ;  #asm
           0700                         ;    DW 0x2000
388E 2000  0701         DW    0x2000
           0702                         ;  #endasm
           0703                         ;  #pragma updateBank exit=UserBank_01
           0704                         ;}
388F 0008  0705         RETURN
           0706                         ;
           0707                         ;#define	restartSPI_address	0x3891
           0708                         ;#pragma origin restartSPI_address
     0000  0709         ORG 0x3891
           0710                         ;void restartSPI()
           0711                         ;{
           0712 restartSPI
           0713                         ;  #asm
           0714                         ;    DW 0x2000
3891 2000  0715         DW    0x2000
           0716                         ;  #endasm
           0717                         ;  #pragma updateBank exit=UserBank_01
           0718                         ;}
3892 0008  0719         RETURN
           0720                         ;
           0721                         ;#define	getStatusSPI_address	0x3894
           0722                         ;#pragma origin getStatusSPI_address
     0000  0723         ORG 0x3894
           0724                         ;bit getStatusSPI()
           0725                         ;{
           0726 getStatusSPI
           0727                         ;  #asm
           0728                         ;    DW 0x2000
3894 2000  0729         DW    0x2000
           0730                         ;  #endasm
           0731                         ;  #pragma updateBank exit=UserBank_01
           0732                         ;  return Carry;
3895 0008  0733         RETURN
           0734                         ;}
           0735                         ;
           0736                         ;#define	setRFpower_address	0x3897
           0737                         ;#pragma origin setRFpower_address
     0000  0738         ORG 0x3897
           0739                         ;void setRFpower(uns8 level @ W)
           0740                         ;{
           0741 setRFpower
           0742                         ;  #asm
           0743                         ;    DW 0x2000
3897 2000  0744         DW    0x2000
           0745                         ;  #endasm
           0746                         ;  #pragma updateBank exit=UserBank_01
           0747                         ;}
3898 0008  0748         RETURN
           0749                         ;
           0750                         ;#define	setLEDG_address	0x389a
           0751                         ;#pragma origin setLEDG_address
     0000  0752         ORG 0x389A
           0753                         ;void setLEDG()
           0754                         ;{
           0755 setLEDG
           0756                         ;  #asm
           0757                         ;    DW 0x2000
389A 2000  0758         DW    0x2000
           0759                         ;  #endasm
           0760                         ;  #pragma updateBank exit=UserBank_01
           0761                         ;}
389B 0008  0762         RETURN
           0763                         ;
           0764                         ;#define	setRFchannel_address	0x389d
           0765                         ;#pragma origin setRFchannel_address
     0000  0766         ORG 0x389D
           0767                         ;void setRFchannel(uns8 channel @ W)
           0768                         ;{
           0769 setRFchannel
           0770                         ;  #asm
           0771                         ;    DW 0x2000
389D 2000  0772         DW    0x2000
           0773                         ;  #endasm
           0774                         ;  #pragma updateBank exit=UserBank_01
           0775                         ;}
389E 0008  0776         RETURN
           0777                         ;
           0778                         ;#define	setRFmode_address	0x38a0
           0779                         ;#pragma origin setRFmode_address
     0000  0780         ORG 0x38A0
           0781                         ;void setRFmode(uns8 mode @ W)
           0782                         ;{
           0783 setRFmode
           0784                         ;  #asm
           0785                         ;    DW 0x2000
38A0 2000  0786         DW    0x2000
           0787                         ;  #endasm
           0788                         ;  #pragma updateBank exit=UserBank_01
           0789                         ;}
38A1 0008  0790         RETURN
           0791                         ;
           0792                         ;#define	setRFspeed_address	0x38a3
           0793                         ;#pragma origin setRFspeed_address
     0000  0794         ORG 0x38A3
           0795                         ;void setRFspeed(uns8 speed @ W)
           0796                         ;{
           0797 setRFspeed
           0798                         ;  #asm
           0799                         ;    DW 0x2000
38A3 2000  0800         DW    0x2000
           0801                         ;  #endasm
           0802                         ;  #pragma updateBank exit=UserBank_01
           0803                         ;}
38A4 0008  0804         RETURN
           0805                         ;
           0806                         ;#define	setRFsleep_address	0x38a6
           0807                         ;#pragma origin setRFsleep_address
     0000  0808         ORG 0x38A6
           0809                         ;void setRFsleep()
           0810                         ;{
           0811 setRFsleep
           0812                         ;  #asm
           0813                         ;    DW 0x2000
38A6 2000  0814         DW    0x2000
           0815                         ;  #endasm
           0816                         ;  #pragma updateBank exit=UserBank_01
           0817                         ;}
38A7 0008  0818         RETURN
           0819                         ;
           0820                         ;#define	setRFready_address	0x38a9
           0821                         ;#pragma origin setRFready_address
     0000  0822         ORG 0x38A9
           0823                         ;void setRFready()
           0824                         ;{
           0825 setRFready
           0826                         ;  #asm
           0827                         ;    DW 0x2000
38A9 2000  0828         DW    0x2000
           0829                         ;  #endasm
           0830                         ;  #pragma updateBank exit=UserBank_01
           0831                         ;}
38AA 0008  0832         RETURN
           0833                         ;
           0834                         ;#define	RFTXpacket_address	0x38ac
           0835                         ;#pragma origin RFTXpacket_address
     0000  0836         ORG 0x38AC
           0837                         ;void RFTXpacket()
           0838                         ;{
           0839 RFTXpacket
           0840                         ;  #asm
           0841                         ;    DW 0x2000
38AC 2000  0842         DW    0x2000
           0843                         ;  #endasm
           0844                         ;  #pragma updateBank exit=UserBank_01
           0845                         ;}
38AD 0008  0846         RETURN
           0847                         ;
           0848                         ;#define	RFRXpacket_address	0x38af
           0849                         ;#pragma origin RFRXpacket_address
     0000  0850         ORG 0x38AF
           0851                         ;bit RFRXpacket()
           0852                         ;{
           0853 RFRXpacket
           0854                         ;  #asm
           0855                         ;    DW 0x2000
38AF 2000  0856         DW    0x2000
           0857                         ;  #endasm
           0858                         ;  #pragma updateBank exit=UserBank_01
           0859                         ;  return Carry;
38B0 0008  0860         RETURN
           0861                         ;}
           0862                         ;
           0863                         ;#define	checkRF_address	0x38b2
           0864                         ;#pragma origin checkRF_address
     0000  0865         ORG 0x38B2
           0866                         ;bit checkRF(uns8 level @ W)
           0867                         ;{
           0868 checkRF
           0869                         ;  #asm
           0870                         ;    DW 0x2000
38B2 2000  0871         DW    0x2000
           0872                         ;  #endasm
           0873                         ;  #pragma updateBank exit=UserBank_01
           0874                         ;  return Carry;
38B3 0008  0875         RETURN
           0876                         ;}
           0877                         ;
           0878                         ;#define	amIBonded_address	0x38b8
           0879                         ;#pragma origin amIBonded_address
     0000  0880         ORG 0x38B8
           0881                         ;bit amIBonded()
           0882                         ;{
           0883 amIBonded
           0884                         ;  #asm
           0885                         ;    DW 0x2000
38B8 2000  0886         DW    0x2000
           0887                         ;  #endasm
           0888                         ;  #pragma updateBank exit=UserBank_01
           0889                         ;  return Carry;
38B9 0008  0890         RETURN
           0891                         ;}
           0892                         ;
           0893                         ;#define	removeBond_address	0x38bb
           0894                         ;#pragma origin removeBond_address
     0000  0895         ORG 0x38BB
           0896                         ;void removeBond()
           0897                         ;{
           0898 removeBond
           0899                         ;  #asm
           0900                         ;    DW 0x2000
38BB 2000  0901         DW    0x2000
           0902                         ;  #endasm
           0903                         ;  #pragma updateBank exit=UserBank_01
           0904                         ;}
38BC 0008  0905         RETURN
           0906                         ;
           0907                         ;#define	bondNewNode_address	0x38be
           0908                         ;#pragma origin bondNewNode_address
     0000  0909         ORG 0x38BE
           0910                         ;bit bondNewNode(uns8 address @ W)
           0911                         ;{
           0912 bondNewNode
           0913                         ;  #asm
           0914                         ;    DW 0x2000
38BE 2000  0915         DW    0x2000
           0916                         ;  #endasm
           0917                         ;  #pragma updateBank exit=UserBank_01
           0918                         ;  return Carry;
38BF 0008  0919         RETURN
           0920                         ;}
           0921                         ;
           0922                         ;#define	isBondedNode_address	0x38c1
           0923                         ;#pragma origin isBondedNode_address
     0000  0924         ORG 0x38C1
           0925                         ;bit isBondedNode(uns8 node @ W)
           0926                         ;{
           0927 isBondedNode
           0928                         ;  #asm
           0929                         ;    DW 0x2000
38C1 2000  0930         DW    0x2000
           0931                         ;  #endasm
           0932                         ;  #pragma updateBank exit=UserBank_01
           0933                         ;  return Carry;
38C2 0008  0934         RETURN
           0935                         ;}
           0936                         ;
           0937                         ;#define	removeBondedNode_address	0x38c4
           0938                         ;#pragma origin removeBondedNode_address
     0000  0939         ORG 0x38C4
           0940                         ;void removeBondedNode(uns8 node @ W)
           0941                         ;{
           0942 removeBondedNode
           0943                         ;  #asm
           0944                         ;    DW 0x2000
38C4 2000  0945         DW    0x2000
           0946                         ;  #endasm
           0947                         ;  #pragma updateBank exit=UserBank_01
           0948                         ;}
38C5 0008  0949         RETURN
           0950                         ;
           0951                         ;#define	rebondNode_address	0x38c7
           0952                         ;#pragma origin rebondNode_address
     0000  0953         ORG 0x38C7
           0954                         ;bit rebondNode(uns8 node @ W)
           0955                         ;{
           0956 rebondNode
           0957                         ;  #asm
           0958                         ;    DW 0x2000
38C7 2000  0959         DW    0x2000
           0960                         ;  #endasm
           0961                         ;  #pragma updateBank exit=UserBank_01
           0962                         ;  return Carry;
38C8 0008  0963         RETURN
           0964                         ;}
           0965                         ;
           0966                         ;#define	clearAllBonds_address	0x38ca
           0967                         ;#pragma origin clearAllBonds_address
     0000  0968         ORG 0x38CA
           0969                         ;void clearAllBonds()
           0970                         ;{
           0971 clearAllBonds
           0972                         ;  #asm
           0973                         ;    DW 0x2000
38CA 2000  0974         DW    0x2000
           0975                         ;  #endasm
           0976                         ;  #pragma updateBank exit=UserBank_01
           0977                         ;}
38CB 0008  0978         RETURN
           0979                         ;
           0980                         ;#define	setNonetMode_address	0x38cd
           0981                         ;#pragma origin setNonetMode_address
     0000  0982         ORG 0x38CD
           0983                         ;void setNonetMode()
           0984                         ;{
           0985 setNonetMode
           0986                         ;  #asm
           0987                         ;    DW 0x2000
38CD 2000  0988         DW    0x2000
           0989                         ;  #endasm
           0990                         ;  #pragma updateBank exit=UserBank_01
           0991                         ;}
38CE 0008  0992         RETURN
           0993                         ;
           0994                         ;#define	setCoordinatorMode_address	0x38d0
           0995                         ;#pragma origin setCoordinatorMode_address
     0000  0996         ORG 0x38D0
           0997                         ;void setCoordinatorMode()
           0998                         ;{
           0999 setCoordinatorMode
           1000                         ;  #asm
           1001                         ;    DW 0x2000
38D0 2000  1002         DW    0x2000
           1003                         ;  #endasm
           1004                         ;  #pragma updateBank exit=UserBank_01
           1005                         ;}
38D1 0008  1006         RETURN
           1007                         ;
           1008                         ;#define	setNodeMode_address	0x38d3
           1009                         ;#pragma origin setNodeMode_address
     0000  1010         ORG 0x38D3
           1011                         ;void setNodeMode()
           1012                         ;{
           1013 setNodeMode
           1014                         ;  #asm
           1015                         ;    DW 0x2000
38D3 2000  1016         DW    0x2000
           1017                         ;  #endasm
           1018                         ;  #pragma updateBank exit=UserBank_01
           1019                         ;}
38D4 0008  1020         RETURN
           1021                         ;
           1022                         ;#define	setNetworkFilteringOn_address	0x38d6
           1023                         ;#pragma origin setNetworkFilteringOn_address
     0000  1024         ORG 0x38D6
           1025                         ;void setNetworkFilteringOn()
           1026                         ;{
           1027 setNetworkFilteringOn
           1028                         ;  #asm
           1029                         ;    DW 0x2000
38D6 2000  1030         DW    0x2000
           1031                         ;  #endasm
           1032                         ;  #pragma updateBank exit=UserBank_01
           1033                         ;}
38D7 0008  1034         RETURN
           1035                         ;
           1036                         ;#define	setNetworkFilteringOff_address	0x38d9
           1037                         ;#pragma origin setNetworkFilteringOff_address
     0000  1038         ORG 0x38D9
           1039                         ;void setNetworkFilteringOff()
           1040                         ;{
           1041 setNetworkFilteringOff
           1042                         ;  #asm
           1043                         ;    DW 0x2000
38D9 2000  1044         DW    0x2000
           1045                         ;  #endasm
           1046                         ;  #pragma updateBank exit=UserBank_01
           1047                         ;}
38DA 0008  1048         RETURN
           1049                         ;
           1050                         ;#define	getNetworkParams_address	0x38dc
           1051                         ;#pragma origin getNetworkParams_address
     0000  1052         ORG 0x38DC
           1053                         ;uns8 getNetworkParams()
           1054                         ;{
           1055 getNetworkParams
           1056                         ;  #asm
           1057                         ;    DW 0x2000
38DC 2000  1058         DW    0x2000
           1059                         ;  #endasm
           1060                         ;  #pragma updateBank exit=UserBank_01
           1061                         ;  return 1;
38DD 3401  1062         RETLW 0x01
           1063                         ;}
           1064                         ;
           1065                         ;#define	setRoutingOn_address	0x38df
           1066                         ;#pragma origin setRoutingOn_address
     0000  1067         ORG 0x38DF
           1068                         ;void setRoutingOn()
           1069                         ;{
           1070 setRoutingOn
           1071                         ;  #asm
           1072                         ;    DW 0x2000
38DF 2000  1073         DW    0x2000
           1074                         ;  #endasm
           1075                         ;  #pragma updateBank exit=UserBank_01
           1076                         ;}
38E0 0008  1077         RETURN
           1078                         ;
           1079                         ;#define	setRoutingOff_address	0x38e2
           1080                         ;#pragma origin setRoutingOff_address
     0000  1081         ORG 0x38E2
           1082                         ;void setRoutingOff()
           1083                         ;{
           1084 setRoutingOff
           1085                         ;  #asm
           1086                         ;    DW 0x2000
38E2 2000  1087         DW    0x2000
           1088                         ;  #endasm
           1089                         ;  #pragma updateBank exit=UserBank_01
           1090                         ;}
38E3 0008  1091         RETURN
           1092                         ;
           1093                         ;#define	answerSystemPacket_address	0x38e8
           1094                         ;#pragma origin answerSystemPacket_address
     0000  1095         ORG 0x38E8
           1096                         ;void answerSystemPacket()
           1097                         ;{
           1098 answerSystemPacket
           1099                         ;  #asm
           1100                         ;    DW 0x2000
38E8 2000  1101         DW    0x2000
           1102                         ;  #endasm
           1103                         ;  #pragma updateBank exit=UserBank_01
           1104                         ;}
38E9 0008  1105         RETURN
           1106                         ;
           1107                         ;#define	discovery_address	0x38eb
           1108                         ;#pragma origin discovery_address
     0000  1109         ORG 0x38EB
           1110                         ;uns8 discovery(uns8 MaxNodeAddress @ W)
           1111                         ;{
           1112 discovery
           1113                         ;  #asm
           1114                         ;    DW 0x2000
38EB 2000  1115         DW    0x2000
           1116                         ;  #endasm
           1117                         ;  #pragma updateBank exit=UserBank_01
           1118                         ;  return 1;
38EC 3401  1119         RETLW 0x01
           1120                         ;}
           1121                         ;
           1122                         ;#define	wasRouted_address	0x38ee
           1123                         ;#pragma origin wasRouted_address
     0000  1124         ORG 0x38EE
           1125                         ;bit wasRouted()
           1126                         ;{
           1127 wasRouted
           1128                         ;  #asm
           1129                         ;    DW 0x2000
38EE 2000  1130         DW    0x2000
           1131                         ;  #endasm
           1132                         ;  #pragma updateBank exit=UserBank_01
           1133                         ;  return Carry;
38EF 0008  1134         RETURN
           1135                         ;}
           1136                         ;
           1137                         ;#define	optimizeHops_address	0x38f1
           1138                         ;#pragma origin optimizeHops_address
     0000  1139         ORG 0x38F1
           1140                         ;bit optimizeHops(uns8 method @ W)
           1141                         ;{
           1142 optimizeHops
           1143                         ;  #asm
           1144                         ;    DW 0x2000
38F1 2000  1145         DW    0x2000
           1146                         ;  #endasm
           1147                         ;  #pragma updateBank exit=UserBank_01
           1148                         ;  return Carry;
38F2 0008  1149         RETURN
           1150                         ;}
           1151                         ;
           1152                         ;#define	getSupplyVoltage_address	0x38f4
           1153                         ;#pragma origin getSupplyVoltage_address
     0000  1154         ORG 0x38F4
           1155                         ;uns8 getSupplyVoltage()
           1156                         ;{
           1157 getSupplyVoltage
           1158                         ;  #asm
           1159                         ;    DW 0x2000
38F4 2000  1160         DW    0x2000
           1161                         ;  #endasm
           1162                         ;  #pragma updateBank exit=UserBank_01
           1163                         ;  return 1;
38F5 3401  1164         RETLW 0x01
           1165                         ;}
           1166                         ;
           1167                         ;#define	getTemperature_address	0x38f7
           1168                         ;#pragma origin getTemperature_address
     0000  1169         ORG 0x38F7
           1170                         ;int8 getTemperature()
           1171                         ;{
           1172 getTemperature
           1173                         ;  #asm
           1174                         ;    DW 0x2000
38F7 2000  1175         DW    0x2000
           1176                         ;  #endasm
           1177                         ;  #pragma updateBank exit=UserBank_01
           1178                         ;  return W;
38F8 0008  1179         RETURN
           1180                         ;}
           1181                         ;
           1182                         ;#define	clearBufferRF_address	0x38fa
           1183                         ;#pragma origin clearBufferRF_address
     0000  1184         ORG 0x38FA
           1185                         ;void clearBufferRF()
           1186                         ;{
           1187 clearBufferRF
           1188                         ;  #asm
           1189                         ;    DW 0x2000
38FA 2000  1190         DW    0x2000
           1191                         ;  #endasm
           1192                         ;  #pragma updateBank exit=UserBank_01
           1193                         ;}
38FB 0008  1194         RETURN
           1195                         ;
           1196                         ;#define	isDiscoveredNode_address	0x3910
           1197                         ;#pragma origin isDiscoveredNode_address
     0000  1198         ORG 0x3910
           1199                         ;bit isDiscoveredNode(uns8 address @ W)
           1200                         ;{
           1201 isDiscoveredNode
           1202                         ;  #asm
           1203                         ;    DW 0x2000
3910 2000  1204         DW    0x2000
           1205                         ;  #endasm
           1206                         ;  #pragma updateBank exit=UserBank_01
           1207                         ;  return Carry;
3911 0008  1208         RETURN
           1209                         ;}
           1210                         ;
           1211                         ;#define	enableRFPGM_address	0x3913
           1212                         ;#pragma origin enableRFPGM_address
     0000  1213         ORG 0x3913
           1214                         ;void enableRFPGM()
           1215                         ;{
           1216 enableRFPGM
           1217                         ;  #asm
           1218                         ;    DW 0x2000
3913 2000  1219         DW    0x2000
           1220                         ;  #endasm
           1221                         ;  #pragma updateBank exit=UserBank_01
           1222                         ;}
3914 0008  1223         RETURN
           1224                         ;
           1225                         ;#define	disableRFPGM_address	0x3916
           1226                         ;#pragma origin disableRFPGM_address
     0000  1227         ORG 0x3916
           1228                         ;void disableRFPGM()
           1229                         ;{
           1230 disableRFPGM
           1231                         ;  #asm
           1232                         ;    DW 0x2000
3916 2000  1233         DW    0x2000
           1234                         ;  #endasm
           1235                         ;  #pragma updateBank exit=UserBank_01
           1236                         ;}
3917 0008  1237         RETURN
           1238                         ;
           1239                         ;#define	setupRFPGM_address	0x3919
           1240                         ;#pragma origin setupRFPGM_address
     0000  1241         ORG 0x3919
           1242                         ;void setupRFPGM(uns8 x @ W)
           1243                         ;{
           1244 setupRFPGM
           1245                         ;  #asm
           1246                         ;    DW 0x2000
3919 2000  1247         DW    0x2000
           1248                         ;  #endasm
           1249                         ;  #pragma updateBank exit=UserBank_01
           1250                         ;}
391A 0008  1251         RETURN
           1252                         ;
           1253                         ;#define	runRFPGM_address	0x391c
           1254                         ;#pragma origin runRFPGM_address
     0000  1255         ORG 0x391C
           1256                         ;void runRFPGM()
           1257                         ;{
           1258 runRFPGM
           1259                         ;  #asm
           1260                         ;    DW 0x2000
391C 2000  1261         DW    0x2000
           1262                         ;  #endasm
           1263                         ;  #pragma updateBank exit=UserBank_01
           1264                         ;}
391D 0008  1265         RETURN
           1266                         ;
           1267                         ;#define	iqrfDeepSleep_address	0x391f
           1268                         ;#pragma origin iqrfDeepSleep_address
     0000  1269         ORG 0x391F
           1270                         ;void iqrfDeepSleep()
           1271                         ;{
           1272 iqrfDeepSleep
           1273                         ;  #asm
           1274                         ;    DW 0x2000
391F 2000  1275         DW    0x2000
           1276                         ;  #endasm
           1277                         ;  #pragma updateBank exit=UserBank_01
           1278                         ;}
3920 0008  1279         RETURN
           1280                         ;
           1281                         ;#define	wasRFICrestarted_address	0x3922
           1282                         ;#pragma origin wasRFICrestarted_address
     0000  1283         ORG 0x3922
           1284                         ;uns8 wasRFICrestarted()
           1285                         ;{
           1286 wasRFICrestarted
           1287                         ;  #asm
           1288                         ;    DW 0x2000
3922 2000  1289         DW    0x2000
           1290                         ;  #endasm
           1291                         ;  #pragma updateBank exit=UserBank_01
           1292                         ;  return 1;
3923 3401  1293         RETLW 0x01
           1294                         ;}
           1295                         ;
           1296                         ;#define	eeeWriteData_address	0x3925
           1297                         ;#pragma origin eeeWriteData_address
     0000  1298         ORG 0x3925
           1299                         ;bit eeeWriteData(uns16 address @ param3)
           1300                         ;{
           1301 eeeWriteData
           1302                         ;  #asm
           1303                         ;    DW 0x2000
3925 2000  1304         DW    0x2000
           1305                         ;  #endasm
           1306                         ;  #pragma updateBank exit=UserBank_01
           1307                         ;  return Carry;
3926 0008  1308         RETURN
           1309                         ;}
           1310                         ;
           1311                         ;#define	eeeReadData_address	0x3928
           1312                         ;#pragma origin eeeReadData_address
     0000  1313         ORG 0x3928
           1314                         ;bit eeeReadData(uns16 address @ param3)
           1315                         ;{
           1316 eeeReadData
           1317                         ;  #asm
           1318                         ;    DW 0x2000
3928 2000  1319         DW    0x2000
           1320                         ;  #endasm
           1321                         ;  #pragma updateBank exit=UserBank_01
           1322                         ;  return Carry;
3929 0008  1323         RETURN
           1324                         ;}
           1325                         ;
           1326                         ;#define	setINDF0_address	0x3931
           1327                         ;#pragma origin setINDF0_address
     0000  1328         ORG 0x3931
           1329                         ;void setINDF0(uns8 value @ W)
           1330                         ;{
           1331 setINDF0
           1332                         ;  #asm
           1333                         ;    DW 0x2000
3931 2000  1334         DW    0x2000
           1335                         ;  #endasm
           1336                         ;  #pragma updateBank exit=UserBank_01
           1337                         ;}
3932 0008  1338         RETURN
           1339                         ;
           1340                         ;#define	setINDF1_address	0x3934
           1341                         ;#pragma origin setINDF1_address
     0000  1342         ORG 0x3934
           1343                         ;void setINDF1(uns8 value @ W)
           1344                         ;{
           1345 setINDF1
           1346                         ;  #asm
           1347                         ;    DW 0x2000
3934 2000  1348         DW    0x2000
           1349                         ;  #endasm
           1350                         ;  #pragma updateBank exit=UserBank_01
           1351                         ;}
3935 0008  1352         RETURN
           1353                         ;
           1354                         ;#define	getRSSI_address	0x3937
           1355                         ;#pragma origin getRSSI_address
     0000  1356         ORG 0x3937
           1357                         ;uns8 getRSSI()
           1358                         ;{
           1359 getRSSI
           1360                         ;  #asm
           1361                         ;    DW 0x2000
3937 2000  1362         DW    0x2000
           1363                         ;  #endasm
           1364                         ;  #pragma updateBank exit=UserBank_01
           1365                         ;  return 1;
3938 3401  1366         RETLW 0x01
           1367                         ;}
           1368                         ;
           1369                         ;#define	removeBondAddress_address	0x393a
           1370                         ;#pragma origin removeBondAddress_address
     0000  1371         ORG 0x393A
           1372                         ;void removeBondAddress()
           1373                         ;{
           1374 removeBondAddress
           1375                         ;  #asm
           1376                         ;    DW 0x2000
393A 2000  1377         DW    0x2000
           1378                         ;  #endasm
           1379                         ;  #pragma updateBank exit=UserBank_01
           1380                         ;}
393B 0008  1381         RETURN
           1382                         ;
           1383                         ;#define	sendFRC_address	0x393d
           1384                         ;#pragma origin sendFRC_address
     0000  1385         ORG 0x393D
           1386                         ;uns8 sendFRC(uns8 command @ W)
           1387                         ;{
           1388 sendFRC
           1389                         ;  #asm
           1390                         ;    DW 0x2000
393D 2000  1391         DW    0x2000
           1392                         ;  #endasm
           1393                         ;  #pragma updateBank exit=UserBank_01
           1394                         ;  return 1;
393E 3401  1395         RETLW 0x01
           1396                         ;}
           1397                         ;
           1398                         ;#define	responseFRC_address	0x3940
           1399                         ;#pragma origin responseFRC_address
     0000  1400         ORG 0x3940
           1401                         ;void responseFRC()
           1402                         ;{
           1403 responseFRC
           1404                         ;  #asm
           1405                         ;    DW 0x2000
3940 2000  1406         DW    0x2000
           1407                         ;  #endasm
           1408                         ;  #pragma updateBank exit=UserBank_01
           1409                         ;}
3941 0008  1410         RETURN
           1411                         ;
           1412                         ;#define	bondRequestAdvanced_address	0x3943
           1413                         ;#pragma origin bondRequestAdvanced_address
     0000  1414         ORG 0x3943
           1415                         ;bit bondRequestAdvanced()
           1416                         ;{
           1417 bondRequestAdvanced
           1418                         ;  #asm
           1419                         ;    DW 0x2000
3943 2000  1420         DW    0x2000
           1421                         ;  #endasm
           1422                         ;  #pragma updateBank exit=UserBank_01
           1423                         ;  return Carry;
3944 0008  1424         RETURN
           1425                         ;}
           1426                         ;
           1427                         ;#define	prebondNodeAtNode_address	0x3946
           1428                         ;#pragma origin prebondNodeAtNode_address
     0000  1429         ORG 0x3946
           1430                         ;bit prebondNodeAtNode()
           1431                         ;{
           1432 prebondNodeAtNode
           1433                         ;  #asm
           1434                         ;    DW 0x2000
3946 2000  1435         DW    0x2000
           1436                         ;  #endasm
           1437                         ;  #pragma updateBank exit=UserBank_01
           1438                         ;  return Carry;
3947 0008  1439         RETURN
           1440                         ;}
           1441                         ;
           1442                         ;#define	nodeAuthorization_address	0x3949
           1443                         ;#pragma origin nodeAuthorization_address
     0000  1444         ORG 0x3949
           1445                         ;bit nodeAuthorization(uns8 address @ W)
           1446                         ;{
           1447 nodeAuthorization
           1448                         ;  #asm
           1449                         ;    DW 0x2000
3949 2000  1450         DW    0x2000
           1451                         ;  #endasm
           1452                         ;  #pragma updateBank exit=UserBank_01
           1453                         ;  return Carry;
394A 0008  1454         RETURN
           1455                         ;}
           1456                         ;
           1457                         ;#define	dummy01_address	0x394c
           1458                         ;#pragma origin dummy01_address
     0000  1459         ORG 0x394C
           1460                         ;void dummy01()
           1461                         ;{
           1462 dummy01
           1463                         ;  #asm
           1464                         ;  DW 0x2000
394C 2000  1465         DW    0x2000
           1466                         ;  #endasm
           1467                         ;  #pragma updateBank exit=UserBank_01
           1468                         ;}
394D 0008  1469         RETURN
           1470                         ;
           1471                         ;#define	setAccessPassword_address	0x3958
           1472                         ;#pragma origin setAccessPassword_address
     0000  1473         ORG 0x3958
           1474                         ;void setAccessPassword()
           1475                         ;{
           1476 setAccessPassword
           1477                         ;  #asm
           1478                         ;    DW 0x2000
3958 2000  1479         DW    0x2000
           1480                         ;  #endasm
           1481                         ;  #pragma updateBank exit=UserBank_01
           1482                         ;}
3959 0008  1483         RETURN
           1484                         ;
           1485                         ;#define	setUserKey_address	0x395b
           1486                         ;#pragma origin setUserKey_address
     0000  1487         ORG 0x395B
           1488                         ;void setUserKey()
           1489                         ;{
           1490 setUserKey
           1491                         ;  #asm
           1492                         ;    DW 0x2000
395B 2000  1493         DW    0x2000
           1494                         ;  #endasm
           1495                         ;  #pragma updateBank exit=UserBank_01
           1496                         ;}
395C 0008  1497         RETURN
           1498                         ;
           1499                         ;#define	amIRecipientOfFRC_address	0x3961
           1500                         ;#pragma origin amIRecipientOfFRC_address
     0000  1501         ORG 0x3961
           1502                         ;bit amIRecipientOfFRC()
           1503                         ;{
           1504 amIRecipientOfFRC
           1505                         ;  #asm
           1506                         ;    DW 0x2000
3961 2000  1507         DW    0x2000
           1508                         ;  #endasm
           1509                         ;  #pragma updateBank exit=UserBank_01
           1510                         ;  return Carry;
3962 0008  1511         RETURN
           1512                         ;}
           1513                         ;
           1514                         ;#define	setLEDR_address	0x3964
           1515                         ;#pragma origin setLEDR_address
     0000  1516         ORG 0x3964
           1517                         ;void setLEDR()
           1518                         ;{
           1519 setLEDR
           1520                         ;  #asm
           1521                         ;    DW 0x2000
3964 2000  1522         DW    0x2000
           1523                         ;  #endasm
           1524                         ;  #pragma updateBank exit=UserBank_01
           1525                         ;}
3965 0008  1526         RETURN
           1527                         ;
           1528                         ;#define	encryptBufferRF_address	0x3967
           1529                         ;#pragma origin encryptBufferRF_address
     0000  1530         ORG 0x3967
           1531                         ;void encryptBufferRF(uns8 blocks @ W)
           1532                         ;{
           1533 encryptBufferRF
           1534                         ;  #asm
           1535                         ;    DW 0x2000
3967 2000  1536         DW    0x2000
           1537                         ;  #endasm
           1538                         ;  #pragma updateBank exit=UserBank_01
           1539                         ;}
3968 0008  1540         RETURN
           1541                         ;
           1542                         ;#define	decryptBufferRF_address	0x396a
           1543                         ;#pragma origin decryptBufferRF_address
     0000  1544         ORG 0x396A
           1545                         ;void decryptBufferRF(uns8 blocks @ W)
           1546                         ;{
           1547 decryptBufferRF
           1548                         ;  #asm
           1549                         ;    DW 0x2000
396A 2000  1550         DW    0x2000
           1551                         ;  #endasm
           1552                         ;  #pragma updateBank exit=UserBank_01
           1553                         ;}
396B 0008  1554         RETURN
           1555                         ;
           1556                         ;#define	prebondNodeAtCoordinator_address	0x396d
           1557                         ;#pragma origin prebondNodeAtCoordinator_address
     0000  1558         ORG 0x396D
           1559                         ;bit prebondNodeAtCoordinator(uns8 address @ W)
           1560                         ;{
           1561 prebondNodeAtCoordinator
           1562                         ;  #asm
           1563                         ;    DW 0x2000
396D 2000  1564         DW    0x2000
           1565                         ;  #endasm
           1566                         ;  #pragma updateBank exit=UserBank_01
           1567                         ;  return Carry;
396E 0008  1568         RETURN
           1569                         ;}
           1570                         ;
           1571                         ;#define	setFSRs_address	0x3970
           1572                         ;#pragma origin setFSRs_address
     0000  1573         ORG 0x3970
           1574                         ;uns8 setFSRs(uns8 fsrs @ W)
           1575                         ;{
           1576 setFSRs
           1577                         ;  #asm
           1578                         ;    DW 0x2000
3970 2000  1579         DW    0x2000
           1580                         ;  #endasm
           1581                         ;  #pragma updateBank exit=UserBank_01
           1582                         ;  return 1;
3971 3401  1583         RETLW 0x01
           1584                         ;}
           1585                         ;
           1586                         ;// For internal usage only
           1587                         ;#define	updateCRC16_address	0x3973
           1588                         ;#pragma origin updateCRC16_address
     0000  1589         ORG 0x3973
           1590                         ;void updateCRC16(uns8 value @ W)
           1591                         ;{
           1592 updateCRC16
           1593                         ;  #asm
           1594                         ;    DW 0x2000
3973 2000  1595         DW    0x2000
           1596                         ;  #endasm
           1597                         ;  #pragma updateBank exit=UserBank_01
           1598                         ;}
3974 0008  1599         RETURN
           1600                         ;
           1601                         ;#define	smartConnect_address	0x3976
           1602                         ;#pragma origin smartConnect_address
     0000  1603         ORG 0x3976
           1604                         ;bit smartConnect(uns8 address @ W)
           1605                         ;{
           1606 smartConnect
           1607                         ;  #asm
           1608                         ;    DW 0x2000
3976 2000  1609         DW    0x2000
           1610                         ;  #endasm
           1611                         ;  #pragma updateBank exit=UserBank_01
           1612                         ;  return Carry;
3977 0008  1613         RETURN
           1614                         ;}
           1615                         ;
           1616                         ;#define	addressBitmap_address	0x3979
           1617                         ;#pragma origin addressBitmap_address
     0000  1618         ORG 0x3979
           1619                         ;uns8 addressBitmap(uns8 bitIndex @ W)
           1620                         ;{
           1621 addressBitmap
           1622                         ;  #asm
           1623                         ;    DW 0x2000
3979 2000  1624         DW    0x2000
           1625                         ;  #endasm
           1626                         ;  #pragma updateBank exit=UserBank_01
           1627                         ;  return 1;
397A 3401  1628         RETLW 0x01
           1629                         ;}
           1630                         ;
           1631                         ;#define	setServiceChannel_address	0x397c
           1632                         ;#pragma origin setServiceChannel_address
     0000  1633         ORG 0x397C
           1634                         ;bit setServiceChannel(uns8 channelNumber @ W)
           1635                         ;{
           1636 setServiceChannel
           1637                         ;  #asm
           1638                         ;    DW 0x2000
397C 2000  1639         DW    0x2000
           1640                         ;  #endasm
           1641                         ;  #pragma updateBank exit=UserBank_01
           1642                         ;  return 1;
397D 1403  1643         BSF   0x03,Carry
397E 0008  1644         RETURN
           1645                         ;}
           1646                         ;
           1647                         ;#pragma optimize 1
           1648                         ;#pragma update_RP 1
           1649                         ;#pragma update_PAGE 1
           1650                         ;#pragma origin __APPLICATION_ADDRESS
     0000  1651         ORG 0x3A00
           1652 
           1653   ; FILE ../../../../Development/include/DPA/DPA.h
           1654                         ;// *********************************************************************
           1655                         ;//   General public DPA header file                                    *
           1656                         ;// *********************************************************************
           1657                         ;// Copyright (c) IQRF Tech s.r.o.
           1658                         ;//
           1659                         ;// File:    $RCSfile: DPA.h,v $
           1660                         ;// Version: $Revision: 1.275 $
           1661                         ;// Date:    $Date: 2020/02/27 13:17:17 $
           1662                         ;//
           1663                         ;// Revision history:
           1664                         ;//   2020/02/27  Release for DPA 4.13
           1665                         ;//   2020/01/09  Release for DPA 4.12
           1666                         ;//   2019/12/11  Release for DPA 4.11
           1667                         ;//   2019/10/09  Release for DPA 4.10
           1668                         ;//   2019/06/12  Release for DPA 4.03
           1669                         ;//   2019/06/03  Release for DPA 4.02
           1670                         ;//   2019/03/07  Release for DPA 4.01
           1671                         ;//   2019/01/10  Release for DPA 4.00
           1672                         ;//   2018/10/25  Release for DPA 3.03
           1673                         ;//   2017/11/16  Release for DPA 3.02
           1674                         ;//   2017/08/14  Release for DPA 3.01
           1675                         ;//   2017/03/13  Release for DPA 3.00
           1676                         ;//   2016/09/12  Release for DPA 2.28
           1677                         ;//   2016/04/14  Release for DPA 2.27
           1678                         ;//   2016/03/03  Release for DPA 2.26
           1679                         ;//   2016/01/21  Release for DPA 2.25
           1680                         ;//   2015/12/01  Release for DPA 2.24
           1681                         ;//   2015/10/23  Release for DPA 2.23
           1682                         ;//   2015/09/25  Release for DPA 2.22
           1683                         ;//   2015/09/03  Release for DPA 2.21
           1684                         ;//   2015/08/05  Release for DPA 2.20
           1685                         ;//   2014/10/31  Release for DPA 2.10
           1686                         ;//   2014/04/30  Release for DPA 2.00
           1687                         ;//   2013/10/03  Release for DPA 1.00
           1688                         ;//
           1689                         ;// *********************************************************************
           1690                         ;
           1691                         ;// Online DPA documentation https://doc.iqrf.org/DpaTechGuide/
           1692                         ;// IQRF Standards documentation https://www.iqrfalliance.org/iqrf-interoperability/
           1693                         ;
           1694                         ;#ifndef _DPA_HEADER_
           1695                         ;#define _DPA_HEADER_
           1696                         ;
           1697                         ;//############################################################################################
           1698                         ;
           1699                         ;// DPA version
           1700                         ;#define	DPA_VERSION_MASTER			0x0413
           1701                         ;
           1702                         ;#ifdef __CC5X__
           1703                         ;// Compiled only at CC5X
           1704                         ;#if __CC5X__ < 3703
           1705                         ;#error Insufficient CC5X compiler version, V3.7C is minimum
           1706                         ;#endif
           1707                         ;
           1708                         ;#if IQRFOS < 403
           1709                         ;#error IQRF OS 4.03+ is required
           1710                         ;#endif
           1711                         ;
           1712                         ;// Bank for custom variables
           1713                         ;#pragma rambank = UserBank_01
           1714                         ;
           1715                         ;// Main DPA API entry address (also start of the licensed FLASH) 
           1716                         ;#define	DPA_API_ADDRESS				__LICENSED_FLASH
           1717                         ;
           1718                         ;// Main DPA entry address
           1719                         ;#define	MAIN_DPA_ADDRESS			( DPA_API_ADDRESS + 4 )
           1720                         ;
           1721                         ;// Main DPA API entry address stub
           1722                         ;#define	DPA_API_ADDRESS_ENTRY		0x3A08
           1723                         ;
           1724                         ;// Address of the DPA Custom Handler
           1725                         ;#define	CUSTOM_HANDLER_ADDRESS		0x3A20
           1726                         ;
           1727                         ;// Address of the DPA Custom Handler end + 1
           1728                         ;#define	CUSTOM_HANDLER_ADDRESS_END	0x3D80
           1729                         ;
           1730                         ;// DPA API entry function
           1731                         ;uns8  DpaApiEntry( uns8 par1, uns8 par2, uns8 apiIndex );
           1732                         ;
           1733                         ;// DPA API codes
           1734                         ;#define	DPA_API_RFTX_DPAPACKET				0
           1735                         ;#define	DPA_API_READ_CONFIG_BYTE			1
           1736                         ;#define	DPA_API_SEND_TO_IFACEMASTER			2
           1737                         ;#define	DPA_API_COORDINATOR_RFTX_DPAPACKET	3
           1738                         ;#define	DPA_API_LOCAL_REQUEST				4
           1739                         ;#define	DPA_API_SET_PERIPHERAL_ERROR		5
           1740                         ;#define	DPA_API_SET_RF_DEFAULTS				6
           1741                         ;
           1742                         ;// Used buffer size symbols
           1743                         ;#define	sizeofBufferRF						sizeof( bufferRF )
           1744                         ;#define	sizeofBufferAUX						sizeof( bufferAUX )
           1745                         ;#define	sizeofBufferCOM						sizeof( bufferCOM )
           1746                         ;
           1747                         ;#define	STRUCTATTR
           1748                         ;
           1749                         ;#else //__CC5X__
           1750                         ;// Not compiled at CC5X
           1751                         ;
           1752                         ;// Define CC5X types
           1753                         ;typedef uint8_t	  uns8;
           1754                         ;typedef uint16_t  uns16;
           1755                         ;
           1756                         ;// Define some types missing at Arduino
           1757                         ;#ifdef Arduino_h
           1758                         ;typedef int8_t  int8;
           1759                         ;typedef int16_t int16;
           1760                         ;#endif
           1761                         ;
           1762                         ;// Fake buffer sizes
           1763                         ;#define	sizeofBufferRF  64
           1764                         ;#define	sizeofBufferAUX 64
           1765                         ;#define	sizeofBufferCOM 64
           1766                         ;
           1767                         ;// Disables alignment of members of structures
           1768                         ;#define	STRUCTATTR	__attribute__((packed))
           1769                         ;
           1770                         ;#endif	// __CC5X__
           1771                         ;
           1772                         ;// Indexes of configuration bytes used by DpaApiReadConfigByte( index )
           1773                         ;// Checksum
           1774                         ;#define	CFGIND_CHECKSUM			0x00
           1775                         ;// Embedded peripherals
           1776                         ;#define	CFGIND_DPA_PERIPHERALS	0x01
           1777                         ;// DPA configuration flags #0
           1778                         ;#define	CFGIND_DPA_FLAGS		0x05
           1779                         ;// Main RF channel, used by the subordinate network
           1780                         ;#define	CFGIND_CHANNEL_2ND_A	0x06
           1781                         ;// Second RF channel, used by the subordinate network
           1782                         ;#define	CFGIND_CHANNEL_2ND_B	0x07
           1783                         ;// TX power
           1784                         ;#define	CFGIND_TXPOWER 			0x08
           1785                         ;// RX filter used by checkRF()
           1786                         ;#define	CFGIND_RXFILTER			0x09
           1787                         ;// toutRF for LP mode
           1788                         ;#define	CFGIND_DPA_LP_TOUTRF	0x0A
           1789                         ;// UART interface baud rate
           1790                         ;#define	CFGIND_DPA_UART_IFACE_SPEED 0x0B
           1791                         ;// Alternate DSM channel
           1792                         ;#define	CFGIND_ALTERNATE_DSM_CHANNEL 0x0C
           1793                         ;// Main RF channel
           1794                         ;#define	CFGIND_CHANNEL_A		0x11
           1795                         ;// Second RF channel
           1796                         ;#define	CFGIND_CHANNEL_B		0x12
           1797                         ;
           1798                         ;// 0: checks only mandatory precondition in order to prevent critical side-effects
           1799                         ;// 1: as above plus checks meaningful parameter conditions
           1800                         ;// 2: full implemented parameter checking (default)
           1801                         ;#ifndef PARAM_CHECK_LEVEL
           1802                         ;#define	PARAM_CHECK_LEVEL 2
           1803                         ;#endif
           1804                         ;
           1805                         ;// "foursome" at IFace structure
           1806                         ;typedef struct
           1807                         ;{
           1808                         ;  // Node address low byte
           1809                         ;  uns8	NADRlow;
           1810                         ;  // Node address high byte
           1811                         ;  uns8	NADRhigh;
           1812                         ;  // Peripheral number
           1813                         ;  uns8	PNUM;
           1814                         ;  // Peripheral command
           1815                         ;  uns8	PCMD;
           1816                         ;  // HWPID
           1817                         ;  uns16	HWPID;
           1818                         ;} STRUCTATTR TDpaIFaceHeader;
           1819                         ;
           1820                         ;// Maximum command PCMD value (except reserved 0x3F = CMD_GET_PER_INFO)
           1821                         ;#define	PCMD_MAX					0x7f
           1822                         ;// Bit mask at PCMD that indicates DPA Response message
           1823                         ;#define	RESPONSE_FLAG				0x80
           1824                         ;
           1825                         ;// IQMESH coordinator address
           1826                         ;#define COORDINATOR_ADDRESS			0x00
           1827                         ;// IQMESH broadcast address
           1828                         ;#define BROADCAST_ADDRESS			0xff
           1829                         ;// IQMESH temporary address, assigned by pre-bonding before authorization is done
           1830                         ;#define TEMPORARY_ADDRESS			0xfe
           1831                         ;// Address of the local device addressed by IFace
           1832                         ;#define LOCAL_ADDRESS				0xfc
           1833                         ;// Maximum IQMESH network device address
           1834                         ;#define MAX_ADDRESS					( 240 - 1 )
           1835                         ;
           1836                         ;// Time slots lengths in 10 ms
           1837                         ;#define	MIN_STD_TIMESLOT	4
           1838                         ;#define	MAX_STD_TIMESLOT	6
           1839                         ;
           1840                         ;#define	MIN_LP_TIMESLOT		8
           1841                         ;#define	MAX_LP_TIMESLOT		10
           1842                         ;
           1843                         ;// Maximum number of DPA PData bytes ( minus 8 = 6B foursome + 8b error code + 8b DpaValue )
           1844                         ;#define DPA_MAX_DATA_LENGTH			( sizeofBufferCOM - sizeof( TDpaIFaceHeader ) - 2 * sizeof( uns8 ) )
           1845                         ;
           1846                         ;// Maximum number of peripherals info that can fit in the message
           1847                         ;#define	MAX_PERIPHERALS_PER_BLOCK_INFO	( DPA_MAX_DATA_LENGTH / sizeof( TPeripheralInfoAnswer ) )
           1848                         ;
           1849                         ;// Embedded peripheral numbers
           1850                         ;#define	PNUM_COORDINATOR	0x00
           1851                         ;#define	PNUM_NODE			0x01
           1852                         ;#define	PNUM_OS				0x02
           1853                         ;#define	PNUM_EEPROM			0x03
           1854                         ;#define	PNUM_EEEPROM		0x04
           1855                         ;#define	PNUM_RAM			0x05
           1856                         ;#define	PNUM_LEDR			0x06
           1857                         ;#define	PNUM_LEDG			0x07
           1858                         ;#define	PNUM_SPI			0x08
           1859                         ;#define	PNUM_IO				0x09
           1860                         ;#define	PNUM_THERMOMETER	0x0A
           1861                         ;#define	PNUM_UART			0x0C
           1862                         ;#define	PNUM_FRC			0x0D
           1863                         ;
           1864                         ;// Number of the 1st user peripheral
           1865                         ;#define	PNUM_USER			0x20
           1866                         ;// Number of the last user peripheral
           1867                         ;#define	PNUM_USER_MAX		0x3E
           1868                         ;// Maximum peripheral number
           1869                         ;#define	PNUM_MAX			0x7F
           1870                         ;
           1871                         ;// Fake peripheral number used to flag DPA response with error sent by RF
           1872                         ;#define	PNUM_ERROR_FLAG		0xFE
           1873                         ;// Special peripheral used for enumeration
           1874                         ;#define	PNUM_ENUMERATION	0xFF
           1875                         ;
           1876                         ;// DPA Commands for embedded peripherals
           1877                         ;#define	CMD_COORDINATOR_ADDR_INFO  0
           1878                         ;#define	CMD_COORDINATOR_DISCOVERED_DEVICES 1
           1879                         ;#define	CMD_COORDINATOR_BONDED_DEVICES 2
           1880                         ;#define	CMD_COORDINATOR_CLEAR_ALL_BONDS 3
           1881                         ;#define	CMD_COORDINATOR_BOND_NODE 4
           1882                         ;#define	CMD_COORDINATOR_REMOVE_BOND 5
           1883                         ;#define	CMD_COORDINATOR_DISCOVERY 7
           1884                         ;#define	CMD_COORDINATOR_SET_DPAPARAMS 8
           1885                         ;#define	CMD_COORDINATOR_SET_HOPS 9
           1886                         ;#define	CMD_COORDINATOR_BACKUP 11
           1887                         ;#define	CMD_COORDINATOR_RESTORE 12
           1888                         ;#define	CMD_COORDINATOR_AUTHORIZE_BOND 13
           1889                         ;#define	CMD_COORDINATOR_BRIDGE 14
           1890                         ;#define	CMD_COORDINATOR_SMART_CONNECT 18
           1891                         ;#define	CMD_COORDINATOR_SET_MID 19
           1892                         ;
           1893                         ;#define	CMD_NODE_READ 0
           1894                         ;#define	CMD_NODE_REMOVE_BOND 1
           1895                         ;#define	CMD_NODE_BACKUP 6
           1896                         ;#define	CMD_NODE_RESTORE 7
           1897                         ;#define	CMD_NODE_VALIDATE_BONDS 8
           1898                         ;
           1899                         ;#define	CMD_OS_READ 0
           1900                         ;#define	CMD_OS_RESET 1
           1901                         ;#define	CMD_OS_READ_CFG 2
           1902                         ;#define	CMD_OS_RFPGM 3
           1903                         ;#define	CMD_OS_SLEEP 4
           1904                         ;#define	CMD_OS_BATCH 5
           1905                         ;#define	CMD_OS_SET_SECURITY 6
           1906                         ;#define	CMD_OS_INDICATE 7
           1907                         ;#define	CMD_OS_RESTART 8
           1908                         ;#define	CMD_OS_WRITE_CFG_BYTE 9
           1909                         ;#define	CMD_OS_LOAD_CODE 10
           1910                         ;#define	CMD_OS_SELECTIVE_BATCH 11
           1911                         ;#define	CMD_OS_TEST_RF_SIGNAL 12
           1912                         ;#define	CMD_OS_FACTORY_SETTINGS 13
           1913                         ;#define	CMD_OS_WRITE_CFG 15
           1914                         ;
           1915                         ;#define	CMD_RAM_READ 0
           1916                         ;#define	CMD_RAM_WRITE 1
           1917                         ;#define	CMD_RAM_READ_ANY    15
           1918                         ;
           1919                         ;#define	CMD_EEPROM_READ CMD_RAM_READ
           1920                         ;#define	CMD_EEPROM_WRITE CMD_RAM_WRITE
           1921                         ;
           1922                         ;#define	CMD_EEEPROM_XREAD ( CMD_RAM_READ + 2 )
           1923                         ;#define	CMD_EEEPROM_XWRITE ( CMD_RAM_WRITE + 2 )
           1924                         ;
           1925                         ;#define	CMD_LED_SET_OFF 0
           1926                         ;#define	CMD_LED_SET_ON 1
           1927                         ;#define	CMD_LED_PULSE 3
           1928                         ;#define	CMD_LED_FLASHING 4
           1929                         ;
           1930                         ;#define	CMD_SPI_WRITE_READ 0
           1931                         ;
           1932                         ;#define	CMD_IO_DIRECTION  0
           1933                         ;#define	CMD_IO_SET	1
           1934                         ;#define	CMD_IO_GET	2
           1935                         ;
           1936                         ;#define	CMD_THERMOMETER_READ 0
           1937                         ;
           1938                         ;#define	CMD_UART_OPEN 0
           1939                         ;#define	CMD_UART_CLOSE 1
           1940                         ;#define	CMD_UART_WRITE_READ 2
           1941                         ;#define	CMD_UART_CLEAR_WRITE_READ 3
           1942                         ;
           1943                         ;#define	CMD_FRC_SEND 0
           1944                         ;#define	CMD_FRC_EXTRARESULT 1
           1945                         ;#define	CMD_FRC_SEND_SELECTIVE 2
           1946                         ;#define	CMD_FRC_SET_PARAMS 3
           1947                         ;
           1948                         ;#define	CMD_GET_PER_INFO  0x3f
           1949                         ;
           1950                         ;// DPA peripheral type
           1951                         ;typedef enum
           1952                         ;{
           1953                         ;  PERIPHERAL_TYPE_DUMMY = 0x00,
           1954                         ;  PERIPHERAL_TYPE_COORDINATOR = 0x01,
           1955                         ;  PERIPHERAL_TYPE_NODE = 0x02,
           1956                         ;  PERIPHERAL_TYPE_OS = 0x03,
           1957                         ;  PERIPHERAL_TYPE_EEPROM = 0x04,
           1958                         ;  PERIPHERAL_TYPE_BLOCK_EEPROM = 0x05,
           1959                         ;  PERIPHERAL_TYPE_RAM = 0x06,
           1960                         ;  PERIPHERAL_TYPE_LED = 0x07,
           1961                         ;  PERIPHERAL_TYPE_SPI = 0x08,
           1962                         ;  PERIPHERAL_TYPE_IO = 0x09,
           1963                         ;  PERIPHERAL_TYPE_UART = 0x0a,
           1964                         ;  PERIPHERAL_TYPE_THERMOMETER = 0x0b,
           1965                         ;  PERIPHERAL_TYPE_ADC = 0x0c,
           1966                         ;  PERIPHERAL_TYPE_PWM = 0x0d,
           1967                         ;  PERIPHERAL_TYPE_FRC = 0x0e,
           1968                         ;  // Starts peripheral type number interval for user peripherals
           1969                         ;  PERIPHERAL_TYPE_USER_AREA = 0x80
           1970                         ;} TDpaPeripheralType;
           1971                         ;
           1972                         ;// Peripheral extended information
           1973                         ;typedef enum
           1974                         ;{
           1975                         ;  PERIPHERAL_TYPE_EXTENDED_DEFAULT = 0x00,
           1976                         ;  PERIPHERAL_TYPE_EXTENDED_READ = 0x01,
           1977                         ;  PERIPHERAL_TYPE_EXTENDED_WRITE = 0x02,
           1978                         ;  PERIPHERAL_TYPE_EXTENDED_READ_WRITE = PERIPHERAL_TYPE_EXTENDED_READ | PERIPHERAL_TYPE_EXTENDED_WRITE
           1979                         ;} TDpaPeripheralTypeExtended;
           1980                         ;
           1981                         ;// Response packet error codes
           1982                         ;typedef enum
           1983                         ;{
           1984                         ;  // No error
           1985                         ;  STATUS_NO_ERROR = 0,
           1986                         ;
           1987                         ;  // General fail
           1988                         ;  ERROR_FAIL = 1,
           1989                         ;  // Incorrect PCMD
           1990                         ;  ERROR_PCMD = 2,
           1991                         ;  // Incorrect PNUM or PCMD
           1992                         ;  ERROR_PNUM = 3,
           1993                         ;  // Incorrect Address value when addressing memory type peripherals
           1994                         ;  ERROR_ADDR = 4,
           1995                         ;  // Incorrect Data length
           1996                         ;  ERROR_DATA_LEN = 5,
           1997                         ;  // Incorrect Data
           1998                         ;  ERROR_DATA = 6,
           1999                         ;  // Incorrect HWPID used
           2000                         ;  ERROR_HWPID = 7,
           2001                         ;  // Incorrect NADR
           2002                         ;  ERROR_NADR = 8,
           2003                         ;  // IFACE data consumed by Custom DPA Handler
           2004                         ;  ERROR_IFACE_CUSTOM_HANDLER = 9,
           2005                         ;  // Custom DPA Handler is missing
           2006                         ;  ERROR_MISSING_CUSTOM_DPA_HANDLER = 10,
           2007                         ;
           2008                         ;  // Beginning of the user code error interval
           2009                         ;  ERROR_USER_FROM = 0x20,
           2010                         ;  // End of the user code error interval
           2011                         ;  ERROR_USER_TO = 0x3f,
           2012                         ;
           2013                         ;  // Bit/flag reserved for a future use
           2014                         ;  STATUS_RESERVED_FLAG = 0x40,
           2015                         ;  // Bit to flag asynchronous DPA Response from [N]
           2016                         ;  STATUS_ASYNC_RESPONSE = 0x80,
           2017                         ;  // Error code used to mark DPA Confirmation
           2018                         ;  STATUS_CONFIRMATION = 0xff
           2019                         ;} TErrorCodes;
           2020                         ;
           2021                         ;// Embedded FRC commands
           2022                         ;typedef enum
           2023                         ;{
           2024                         ;  // 2 bits
           2025                         ;  FRC_Ping = 0x00,
           2026                         ;  FRC_AcknowledgedBroadcastBits = 0x02,
           2027                         ;  FRC_PrebondedAlive = 0x03,
           2028                         ;  FRC_SupplyVoltage = 0x04,
           2029                         ;  // 1 byte
           2030                         ;  FRC_Temperature = 0x80,
           2031                         ;  FRC_AcknowledgedBroadcastBytes = 0x81,
           2032                         ;  FRC_MemoryRead = 0x82,
           2033                         ;  FRC_MemoryReadPlus1 = 0x83,
           2034                         ;  FRC_FrcResponseTime = 0x84,
           2035                         ;  FRC_TestRFsignal = 0x85,
           2036                         ;  // 4 bytes
           2037                         ;  FRC_PrebondedMemoryReadPlus1 = 0xF8,
           2038                         ;  FRC_MemoryRead4B = 0xFA
           2039                         ;} TFRCommands;
           2040                         ;
           2041                         ;// Intervals of user FRC codes
           2042                         ;#define	FRC_USER_BIT_FROM	  0x40
           2043                         ;#define	FRC_USER_BIT_TO		  0x7F
           2044                         ;#define	FRC_USER_BYTE_FROM	  0xC0
           2045                         ;#define	FRC_USER_BYTE_TO	  0xDF
           2046                         ;#define	FRC_USER_2BYTE_FROM	  0xF0
           2047                         ;#define	FRC_USER_2BYTE_TO	  0xF7
           2048                         ;#define	FRC_USER_4BYTE_FROM	  0xFC
           2049                         ;#define	FRC_USER_4BYTE_TO	  0xFF
           2050                         ;
           2051                         ;// No HWPID specified
           2052                         ;#define HWPID_Default         0x0000
           2053                         ;// Use this type to override HWPID check
           2054                         ;#define HWPID_DoNotCheck      0xFfFf
           2055                         ;
           2056                         ;// RAM peripheral block definitions
           2057                         ;#define	PERIPHERAL_RAM_LENGTH		48
           2058                         ;
           2059                         ;// Start address of EEPROM peripheral in the real EEPROM
           2060                         ;#ifndef COORDINATOR_CUSTOM_HANDLER // Node
           2061                         ;#define	PERIPHERAL_EEPROM_START		( (uns8)0x00 )
           2062                         ;#else // Coordinator
           2063                         ;#define	PERIPHERAL_EEPROM_START		( (uns8)0x80 )
           2064                         ;#endif
           2065                         ;
           2066                         ;// Length of the readable area of serial EEEPROM from the EEEPROM DPA peripheral write point of view. 
           2067                         ;#define	EEEPROM_READ_LENGTH					0x8000
           2068                         ;// Length of the writable area of serial EEEPROM from the EEEPROM DPA peripheral write point of view. 
           2069                         ;#define	EEEPROM_WRITE_LENGTH				0x4000
           2070                         ;
           2071                         ;// Starting address of the Autoexec DPA storage at external EEPROM
           2072                         ;#define	AUTOEXEC_EEEPROM_ADDR				0x0000
           2073                         ;// Length of the autoexec memory block
           2074                         ;#define	AUTOEXEC_LENGTH						sizeofBufferAUX
           2075                         ;
           2076                         ;// Starting address of the IO Setup DPA storage at external EEPROM
           2077                         ;#define	IOSETUP_EEEPROM_ADDR				( AUTOEXEC_EEEPROM_ADDR + AUTOEXEC_LENGTH )
           2078                         ;// Length of the IO setup memory block
           2079                         ;#define	IOSETUP_LENGTH						sizeofBufferAUX
           2080                         ;
           2081                         ;// ---------------------------------------------------------
           2082                         ;
           2083                         ;// Enumerate peripherals structure
           2084                         ;typedef struct
           2085                         ;{
           2086                         ;  uns16	DpaVersion;
           2087                         ;  uns8	UserPerNr;
           2088                         ;  uns8	EmbeddedPers[PNUM_USER / 8];
           2089                         ;  uns16	HWPID;
           2090                         ;  uns16	HWPIDver;
           2091                         ;  uns8	Flags;
           2092                         ;  uns8	UserPer[( PNUM_MAX - PNUM_USER + 1 + 7 ) / 8];
           2093                         ;} STRUCTATTR TEnumPeripheralsAnswer;
           2094                         ;
           2095                         ;#define	FlagUserPer(UserPersArray,UserPerNumber)	UserPersArray[((UserPerNumber)-PNUM_USER) / 8] |= (uns8)0x01 << (((UserPerNumber)-PNUM_USER) % 8);
           2096                         ;
           2097                         ;// Get peripheral info structure (CMD_GET_PER_INFO)
           2098                         ;typedef struct
           2099                         ;{
           2100                         ;  uns8	PerTE;
           2101                         ;  uns8	PerT;
           2102                         ;  uns8	Par1;
           2103                         ;  uns8	Par2;
           2104                         ;} STRUCTATTR TPeripheralInfoAnswer;
           2105                         ;
           2106                         ;// Error DPA response (PNUM_ERROR_FLAG)
           2107                         ;typedef struct
           2108                         ;{
           2109                         ;  uns8	ErrN;
           2110                         ;  uns8	PNUMoriginal;
           2111                         ;} STRUCTATTR TErrorAnswer;
           2112                         ;
           2113                         ;// Structure returned by CMD_COORDINATOR_ADDR_INFO
           2114                         ;typedef struct
           2115                         ;{
           2116                         ;  uns8	DevNr;
           2117                         ;  uns8	DID;
           2118                         ;} STRUCTATTR TPerCoordinatorAddrInfo_Response;
           2119                         ;
           2120                         ;// Structure for CMD_COORDINATOR_BOND_NODE
           2121                         ;typedef struct
           2122                         ;{
           2123                         ;  uns8	ReqAddr;
           2124                         ;  uns8	BondingTestRetries;
           2125                         ;} STRUCTATTR TPerCoordinatorBondNode_Request;
           2126                         ;
           2127                         ;// Structure returned by CMD_COORDINATOR_BOND_NODE or CMD_COORDINATOR_SMART_CONNECT
           2128                         ;typedef struct
           2129                         ;{
           2130                         ;  uns8	BondAddr;
           2131                         ;  uns8	DevNr;
           2132                         ;} STRUCTATTR TPerCoordinatorBondNodeSmartConnect_Response;
           2133                         ;
           2134                         ;// Structure for CMD_COORDINATOR_REMOVE_BOND
           2135                         ;typedef struct
           2136                         ;{
           2137                         ;  uns8	BondAddr;
           2138                         ;} STRUCTATTR TPerCoordinatorRemoveBond_Request;
           2139                         ;
           2140                         ;// Structure returned by CMD_COORDINATOR_REMOVE_BOND
           2141                         ;typedef struct
           2142                         ;{
           2143                         ;  uns8	DevNr;
           2144                         ;} STRUCTATTR TPerCoordinatorRemoveBond_Response;
           2145                         ;
           2146                         ;// Structure for CMD_COORDINATOR_DISCOVERY
           2147                         ;typedef struct
           2148                         ;{
           2149                         ;  uns8	TxPower;
           2150                         ;  uns8	MaxAddr;
           2151                         ;} STRUCTATTR TPerCoordinatorDiscovery_Request;
           2152                         ;
           2153                         ;// Structure returned by CMD_COORDINATOR_DISCOVERY
           2154                         ;typedef struct
           2155                         ;{
           2156                         ;  uns8	DiscNr;
           2157                         ;} STRUCTATTR TPerCoordinatorDiscovery_Response;
           2158                         ;
           2159                         ;// Structure for and also returned by CMD_COORDINATOR_SET_DPAPARAMS
           2160                         ;typedef struct
           2161                         ;{
           2162                         ;  uns8	DpaParam;
           2163                         ;} STRUCTATTR TPerCoordinatorSetDpaParams_Request_Response;
           2164                         ;
           2165                         ;// Structure for and also returned by CMD_COORDINATOR_SET_HOPS
           2166                         ;typedef struct
           2167                         ;{
           2168                         ;  uns8	RequestHops;
           2169                         ;  uns8	ResponseHops;
           2170                         ;} STRUCTATTR TPerCoordinatorSetHops_Request_Response;
           2171                         ;
           2172                         ;// Structure for CMD_COORDINATOR_BACKUP and CMD_NODE_BACKUP
           2173                         ;typedef struct
           2174                         ;{
           2175                         ;  uns8	Index;
           2176                         ;} STRUCTATTR TPerCoordinatorNodeBackup_Request;
           2177                         ;
           2178                         ;// Structure returned by CMD_COORDINATOR_BACKUP and CMD_NODE_BACKUP
           2179                         ;typedef struct
           2180                         ;{
           2181                         ;  uns8	NetworkData[49];
           2182                         ;} STRUCTATTR TPerCoordinatorNodeBackup_Response;
           2183                         ;
           2184                         ;// Structure for CMD_COORDINATOR_RESTORE and CMD_NODE_RESTORE
           2185                         ;typedef struct
           2186                         ;{
           2187                         ;  uns8	NetworkData[49];
           2188                         ;} STRUCTATTR TPerCoordinatorNodeRestore_Request;
           2189                         ;
           2190                         ;// Structure for CMD_COORDINATOR_AUTHORIZE_BOND
           2191                         ;typedef struct
           2192                         ;{
           2193                         ;  uns8	ReqAddr;
           2194                         ;  uns8	MID[4];
           2195                         ;} STRUCTATTR TPerCoordinatorAuthorizeBond_Request;
           2196                         ;
           2197                         ;// Structure returned by CMD_COORDINATOR_AUTHORIZE_BOND
           2198                         ;typedef struct
           2199                         ;{
           2200                         ;  uns8	BondAddr;
           2201                         ;  uns8	DevNr;
           2202                         ;} STRUCTATTR TPerCoordinatorAuthorizeBond_Response;
           2203                         ;
           2204                         ;// Structure for CMD_COORDINATOR_BRIDGE
           2205                         ;typedef struct
           2206                         ;{
           2207                         ;  TDpaIFaceHeader subHeader;
           2208                         ;  uns8	subPData[DPA_MAX_DATA_LENGTH - sizeof( TDpaIFaceHeader )];
           2209                         ;} STRUCTATTR TPerCoordinatorBridge_Request;
           2210                         ;
           2211                         ;// Structure returned by CMD_COORDINATOR_BRIDGE
           2212                         ;typedef struct
           2213                         ;{
           2214                         ;  TDpaIFaceHeader subHeader;
           2215                         ;  uns8	subRespCode;
           2216                         ;  uns8	subDpaValue;
           2217                         ;  uns8	subPData[DPA_MAX_DATA_LENGTH - sizeof( TDpaIFaceHeader ) - 2 * sizeof( uns8 )];
           2218                         ;} STRUCTATTR TPerCoordinatorBridge_Response;
           2219                         ;
           2220                         ;// Structure for CMD_COORDINATOR_SMART_CONNECT
           2221                         ;typedef struct
           2222                         ;{
           2223                         ;  uns8  ReqAddr;
           2224                         ;  uns8  BondingTestRetries;
           2225                         ;  uns8  IBK[16];
           2226                         ;  uns8  MID[4];
           2227                         ;  uns8  reserved0[2];
           2228                         ;  uns8  VirtualDeviceAddress;
           2229                         ;  uns8  reserved1[9];
           2230                         ;  uns8	UserData[4];
           2231                         ;} STRUCTATTR TPerCoordinatorSmartConnect_Request;
           2232                         ;
           2233                         ;// Structure for CMD_COORDINATOR_SET_MID
           2234                         ;typedef struct
           2235                         ;{
           2236                         ;  uns8  MID[4];
           2237                         ;  uns8	BondAddr;
           2238                         ;} STRUCTATTR TPerCoordinatorSetMID_Request;
           2239                         ;
           2240                         ;// Structure returned by CMD_NODE_READ
           2241                         ;typedef struct
           2242                         ;{
           2243                         ;  uns8  ntwADDR;
           2244                         ;  uns8  ntwVRN;
           2245                         ;  uns8  ntwZIN;
           2246                         ;  uns8  ntwDID;
           2247                         ;  uns8  ntwPVRN;
           2248                         ;  uns16 ntwUSERADDRESS;
           2249                         ;  uns16 ntwID;
           2250                         ;  uns8  ntwVRNFNZ;
           2251                         ;  uns8  ntwCFG;
           2252                         ;  uns8  Flags;
           2253                         ;} STRUCTATTR TPerNodeRead_Response;
           2254                         ;
           2255                         ;// Structures for CMD_NODE_VALIDATE_BONDS
           2256                         ;typedef struct
           2257                         ;{
           2258                         ;  uns8	Address;
           2259                         ;  uns8  MID[4];
           2260                         ;} STRUCTATTR TPerNodeValidateBondsItem;
           2261                         ;
           2262                         ;// Structure for CMD_NODE_VALIDATE_BONDS
           2263                         ;typedef struct
           2264                         ;{
           2265                         ;  TPerNodeValidateBondsItem Bonds[DPA_MAX_DATA_LENGTH / sizeof( TPerNodeValidateBondsItem )];
           2266                         ;} STRUCTATTR TPerNodeValidateBonds_Request;
           2267                         ;
           2268                         ;// Structure returned by CMD_OS_READ
           2269                         ;typedef struct
           2270                         ;{
           2271                         ;  uns8	MID[4];
           2272                         ;  uns8	OsVersion;
           2273                         ;  uns8	McuType;
           2274                         ;  uns16	OsBuild;
           2275                         ;  uns8	Rssi;
           2276                         ;  uns8	SupplyVoltage;
           2277                         ;  uns8	Flags;
           2278                         ;  uns8	SlotLimits;
           2279                         ;  uns8  IBK[16];
           2280                         ;  // Enumerate peripherals part, variable length because of UserPer field
           2281                         ;  uns16	DpaVersion;
           2282                         ;  uns8	UserPerNr;
           2283                         ;  uns8	EmbeddedPers[PNUM_USER / 8];
           2284                         ;  uns16	HWPID;
           2285                         ;  uns16	HWPIDver;
           2286                         ;  uns8	FlagsEnum;
           2287                         ;  uns8	UserPer[( PNUM_MAX - PNUM_USER + 1 + 7 ) / 8];
           2288                         ;} STRUCTATTR TPerOSRead_Response;
           2289                         ;
           2290                         ;// Structure returned by CMD_OS_READ_CFG
           2291                         ;typedef struct
           2292                         ;{
           2293                         ;  uns8	Checksum;
           2294                         ;  uns8	Configuration[31];
           2295                         ;  uns8	RFPGM;
           2296                         ;  uns8	Undocumented[1];
           2297                         ;} STRUCTATTR TPerOSReadCfg_Response;
           2298                         ;
           2299                         ;// Structure for CMD_OS_WRITE_CFG
           2300                         ;typedef struct
           2301                         ;{
           2302                         ;  uns8	Undefined;
           2303                         ;  uns8	Configuration[31];
           2304                         ;  uns8	RFPGM;
           2305                         ;} STRUCTATTR TPerOSWriteCfg_Request;
           2306                         ;
           2307                         ;// Structures for CMD_OS_WRITE_CFG_BYTE
           2308                         ;typedef struct
           2309                         ;{
           2310                         ;  uns8	Address;
           2311                         ;  uns8	Value;
           2312                         ;  uns8	Mask;
           2313                         ;} STRUCTATTR TPerOSWriteCfgByteTriplet;
           2314                         ;
           2315                         ;// Structure for CMD_OS_WRITE_CFG_BYTE
           2316                         ;typedef struct
           2317                         ;{
           2318                         ;  TPerOSWriteCfgByteTriplet Triplets[DPA_MAX_DATA_LENGTH / sizeof( TPerOSWriteCfgByteTriplet )];
           2319                         ;} STRUCTATTR TPerOSWriteCfgByte_Request;
           2320                         ;
           2321                         ;// Structure for CMD_OS_SET_SECURITY
           2322                         ;typedef struct
           2323                         ;{
           2324                         ;  uns8	Type;
           2325                         ;  uns8	Data[16];
           2326                         ;} STRUCTATTR TPerOSSetSecurity_Request;
           2327                         ;
           2328                         ;// Structure for CMD_OS_LOAD_CODE
           2329                         ;typedef struct
           2330                         ;{
           2331                         ;  uns8	Flags;
           2332                         ;  uns16	Address;
           2333                         ;  uns16	Length;
           2334                         ;  uns16	CheckSum;
           2335                         ;} STRUCTATTR TPerOSLoadCode_Request;
           2336                         ;
           2337                         ;// Structure for CMD_OS_SLEEP
           2338                         ;typedef struct
           2339                         ;{
           2340                         ;  uns16	Time;
           2341                         ;  uns8	Control;
           2342                         ;} STRUCTATTR TPerOSSleep_Request;
           2343                         ;
           2344                         ;// Structure for CMD_OS_SELECTIVE_BATCH
           2345                         ;typedef struct
           2346                         ;{
           2347                         ;  uns8	SelectedNodes[30];
           2348                         ;  uns8	Requests[DPA_MAX_DATA_LENGTH - 30];
           2349                         ;} STRUCTATTR TPerOSSelectiveBatch_Request;
           2350                         ;
           2351                         ;// Structure for CMD_OS_TEST_RF_SIGNAL request
           2352                         ;typedef struct
           2353                         ;{
           2354                         ;  uns8  Channel;
           2355                         ;  uns8  RXfilter;
           2356                         ;  uns16 Time;
           2357                         ;} STRUCTATTR TPerOSTestRfSignal_Request;
           2358                         ;
           2359                         ;// Structure for CMD_OS_TEST_RF_SIGNAL response
           2360                         ;typedef struct
           2361                         ;{
           2362                         ;  uns8  Counter;
           2363                         ;} STRUCTATTR TPerOSTestRfSignal_Response;
           2364                         ;
           2365                         ;// Structure for CMD_OS_INDICATE request
           2366                         ;typedef struct
           2367                         ;{
           2368                         ;  uns8  Control;
           2369                         ;} STRUCTATTR TPerOSIndicate_Request;
           2370                         ;
           2371                         ;// Structure for general memory request
           2372                         ;typedef struct
           2373                         ;{
           2374                         ;  // Address of data to write or read
           2375                         ;  uns8	Address;
           2376                         ;
           2377                         ;  union
           2378                         ;  {
           2379                         ;    // Memory read request
           2380                         ;    struct
           2381                         ;    {
           2382                         ;      // Length of data to read
           2383                         ;      uns8	Length;
           2384                         ;    } Read;
           2385                         ;
           2386                         ;    // Size of Address field
           2387                         ;#define	MEMORY_WRITE_REQUEST_OVERHEAD	( sizeof( uns8 ) )
           2388                         ;
           2389                         ;    // Memory write request
           2390                         ;    struct
           2391                         ;    {
           2392                         ;      uns8	PData[DPA_MAX_DATA_LENGTH - MEMORY_WRITE_REQUEST_OVERHEAD];
           2393                         ;    } Write;
           2394                         ;
           2395                         ;  } ReadWrite;
           2396                         ;} STRUCTATTR TPerMemoryRequest;
           2397                         ;
           2398                         ;// Structure for general extended memory request
           2399                         ;typedef struct
           2400                         ;{
           2401                         ;  // Address of data to write or read
           2402                         ;  uns16	Address;
           2403                         ;
           2404                         ;  union
           2405                         ;  {
           2406                         ;    // Memory read request
           2407                         ;    struct
           2408                         ;    {
           2409                         ;      // Length of data to read
           2410                         ;      uns8	Length;
           2411                         ;    } Read;
           2412                         ;
           2413                         ;    // Size of Address field
           2414                         ;#define	XMEMORY_WRITE_REQUEST_OVERHEAD	( sizeof( uns16 ) )
           2415                         ;
           2416                         ;    // Memory write request
           2417                         ;    struct
           2418                         ;    {
           2419                         ;      uns8	PData[DPA_MAX_DATA_LENGTH - XMEMORY_WRITE_REQUEST_OVERHEAD];
           2420                         ;    } Write;
           2421                         ;
           2422                         ;  } ReadWrite;
           2423                         ;} STRUCTATTR TPerXMemoryRequest;
           2424                         ;
           2425                         ;// Structure for CMD_IO requests
           2426                         ;typedef struct
           2427                         ;{
           2428                         ;  uns8  Port;
           2429                         ;  uns8  Mask;
           2430                         ;  uns8  Value;
           2431                         ;} STRUCTATTR TPerIOTriplet;
           2432                         ;
           2433                         ;typedef struct
           2434                         ;{
           2435                         ;  uns8  Header;	// == PNUM_IO_DELAY
           2436                         ;  uns16 Delay;
           2437                         ;} STRUCTATTR TPerIODelay;
           2438                         ;
           2439                         ;// Union for CMD_IO_SET and CMD_IO_DIRECTION requests
           2440                         ;typedef union
           2441                         ;{
           2442                         ;  TPerIOTriplet Triplets[DPA_MAX_DATA_LENGTH / sizeof( TPerIOTriplet )];
           2443                         ;  TPerIODelay   Delays[DPA_MAX_DATA_LENGTH / sizeof( TPerIODelay )];
           2444                         ;} STRUCTATTR TPerIoDirectionAndSet_Request;
           2445                         ;
           2446                         ;// Structure returned by CMD_THERMOMETER_READ
           2447                         ;typedef struct
           2448                         ;{
           2449                         ;  int8  IntegerValue;
           2450                         ;  int16 SixteenthValue;
           2451                         ;} STRUCTATTR TPerThermometerRead_Response;
           2452                         ;
           2453                         ;// Structure for CMD_UART_OPEN
           2454                         ;typedef struct
           2455                         ;{
           2456                         ;  uns8  BaudRate;
           2457                         ;} STRUCTATTR TPerUartOpen_Request;
           2458                         ;
           2459                         ;// Structure for CMD_UART_[CLEAR_]WRITE_READ and CMD_SPI_WRITE_READ
           2460                         ;typedef struct
           2461                         ;{
           2462                         ;  uns8  ReadTimeout;
           2463                         ;  uns8	WrittenData[DPA_MAX_DATA_LENGTH - sizeof( uns8 )];
           2464                         ;} STRUCTATTR TPerUartSpiWriteRead_Request;
           2465                         ;
           2466                         ;// Structure for CMD_FRC_SEND
           2467                         ;typedef struct
           2468                         ;{
           2469                         ;  uns8  FrcCommand;
           2470                         ;  uns8	UserData[30];
           2471                         ;} STRUCTATTR TPerFrcSend_Request;
           2472                         ;
           2473                         ;// Structure for CMD_FRC_SEND_SELECTIVE
           2474                         ;typedef struct
           2475                         ;{
           2476                         ;  uns8  FrcCommand;
           2477                         ;  uns8	SelectedNodes[30];
           2478                         ;  uns8	UserData[25];
           2479                         ;} STRUCTATTR TPerFrcSendSelective_Request;
           2480                         ;
           2481                         ;// Structure returned by CMD_FRC_SEND and CMD_FRC_SEND_SELECTIVE
           2482                         ;typedef struct
           2483                         ;{
           2484                         ;  uns8  Status;
           2485                         ;  uns8	FrcData[DPA_MAX_DATA_LENGTH - sizeof( uns8 )];
           2486                         ;} STRUCTATTR TPerFrcSend_Response;
           2487                         ;
           2488                         ;// Structure for request and response of CMD_FRC_SET_PARAMS
           2489                         ;typedef struct
           2490                         ;{
           2491                         ;  uns8	FRCresponseTime;
           2492                         ;} STRUCTATTR TPerFrcSetParams_RequestResponse;
           2493                         ;
           2494                         ;// Interface and CMD_COORDINATOR_BRIDGE confirmation structure
           2495                         ;typedef struct
           2496                         ;{
           2497                         ;  // Number of hops
           2498                         ;  uns8  Hops;
           2499                         ;  // Time slot length in 10ms
           2500                         ;  uns8  TimeSlotLength;
           2501                         ;  // Number of hops for response
           2502                         ;  uns8  HopsResponse;
           2503                         ;} STRUCTATTR TIFaceConfirmation;
           2504                         ;
           2505                         ;// ---------------------------------------------------------
           2506                         ;
           2507                         ;// DPA Message data structure (packet w/o NADR, PNUM, PCMD, HWPID)
           2508                         ;typedef union
           2509                         ;{
           2510                         ;  // General DPA request
           2511                         ;  struct
           2512                         ;  {
           2513                         ;    uns8	PData[DPA_MAX_DATA_LENGTH];
           2514                         ;  } Request;
           2515                         ;
           2516                         ;  // General DPA response
           2517                         ;  struct
           2518                         ;  {
           2519                         ;    uns8	PData[DPA_MAX_DATA_LENGTH];
           2520                         ;  } Response;
           2521                         ;
           2522                         ;  // Enumerate peripherals structure
           2523                         ;  TEnumPeripheralsAnswer EnumPeripheralsAnswer;
           2524                         ;
           2525                         ;  // Get peripheral info structure (CMD_GET_PER_INFO)
           2526                         ;  TPeripheralInfoAnswer PeripheralInfoAnswer;
           2527                         ;
           2528                         ;  // Get peripheral info structure (CMD_GET_PER_INFO) for more peripherals
           2529                         ;  TPeripheralInfoAnswer PeripheralInfoAnswers[MAX_PERIPHERALS_PER_BLOCK_INFO];
           2530                         ;
           2531                         ;  // Error DPA response (PNUM_ERROR_FLAG)
           2532                         ;  TErrorAnswer ErrorAnswer;
           2533                         ;
           2534                         ;  // Structure returned by CMD_COORDINATOR_ADDR_INFO
           2535                         ;  TPerCoordinatorAddrInfo_Response PerCoordinatorAddrInfo_Response;
           2536                         ;
           2537                         ;  // Structure for CMD_COORDINATOR_BOND_NODE
           2538                         ;  TPerCoordinatorBondNode_Request PerCoordinatorBondNode_Request;
           2539                         ;
           2540                         ;  // Structure returned by CMD_COORDINATOR_BOND_NODE or CMD_COORDINATOR_SMART_CONNECT
           2541                         ;  TPerCoordinatorBondNodeSmartConnect_Response PerCoordinatorBondNodeSmartConnect_Response;
           2542                         ;
           2543                         ;  // Structure for CMD_COORDINATOR_REMOVE_BOND
           2544                         ;  TPerCoordinatorRemoveBond_Request PerCoordinatorRemoveBond_Request;
           2545                         ;
           2546                         ;  // Structure returned by CMD_COORDINATOR_REMOVE_BOND 
           2547                         ;  TPerCoordinatorRemoveBond_Response PerCoordinatorRemoveBond_Response;
           2548                         ;
           2549                         ;  // Structure for CMD_COORDINATOR_DISCOVERY
           2550                         ;  TPerCoordinatorDiscovery_Request PerCoordinatorDiscovery_Request;
           2551                         ;
           2552                         ;  // Structure returned by CMD_COORDINATOR_DISCOVERY
           2553                         ;  TPerCoordinatorDiscovery_Response PerCoordinatorDiscovery_Response;
           2554                         ;
           2555                         ;  // Structure for and also returned by CMD_COORDINATOR_SET_DPAPARAMS
           2556                         ;  TPerCoordinatorSetDpaParams_Request_Response PerCoordinatorSetDpaParams_Request_Response;
           2557                         ;
           2558                         ;  // Structure for and also returned by CMD_COORDINATOR_SET_HOPS
           2559                         ;  TPerCoordinatorSetHops_Request_Response PerCoordinatorSetHops_Request_Response;
           2560                         ;
           2561                         ;  // Structure for CMD_COORDINATOR_BACKUP and CMD_NODE_BACKUP
           2562                         ;  TPerCoordinatorNodeBackup_Request PerCoordinatorNodeBackup_Request;
           2563                         ;
           2564                         ;  // Structure returned by CMD_COORDINATOR_BACKUP and CMD_NODE_BACKUP
           2565                         ;  TPerCoordinatorNodeBackup_Response PerCoordinatorNodeBackup_Response;
           2566                         ;
           2567                         ;  // Structure for CMD_COORDINATOR_RESTORE and CMD_NODE_RESTORE
           2568                         ;  TPerCoordinatorNodeRestore_Request PerCoordinatorNodeRestore_Request;
           2569                         ;
           2570                         ;  // Structure for CMD_COORDINATOR_AUTHORIZE_BOND
           2571                         ;  TPerCoordinatorAuthorizeBond_Request PerCoordinatorAuthorizeBond_Request;
           2572                         ;
           2573                         ;  // Structure returned by CMD_COORDINATOR_AUTHORIZE_BOND
           2574                         ;  TPerCoordinatorAuthorizeBond_Response PerCoordinatorAuthorizeBond_Response;
           2575                         ;
           2576                         ;  // Structure for CMD_COORDINATOR_BRIDGE
           2577                         ;  TPerCoordinatorBridge_Request PerCoordinatorBridge_Request;
           2578                         ;
           2579                         ;  // Structure returned by CMD_COORDINATOR_BRIDGE
           2580                         ;  TPerCoordinatorBridge_Response PerCoordinatorBridge_Response;
           2581                         ;
           2582                         ;  // Structure for CMD_COORDINATOR_SMART_CONNECT
           2583                         ;  TPerCoordinatorSmartConnect_Request PerCoordinatorSmartConnect_Request;
           2584                         ;
           2585                         ;  // Structure for CMD_COORDINATOR_SET_MID
           2586                         ;  TPerCoordinatorSetMID_Request PerCoordinatorSetMID_Request;
           2587                         ;
           2588                         ;  // Structure returned by CMD_NODE_READ
           2589                         ;  TPerNodeRead_Response PerNodeRead_Response;
           2590                         ;
           2591                         ;  // Structure for CMD_NODE_VALIDATE_BONDS
           2592                         ;  TPerNodeValidateBonds_Request PerNodeValidateBonds_Request;
           2593                         ;
           2594                         ;  // Structure returned by CMD_OS_READ
           2595                         ;  TPerOSRead_Response PerOSRead_Response;
           2596                         ;
           2597                         ;  // Structure returned by CMD_OS_READ_CFG
           2598                         ;  TPerOSReadCfg_Response PerOSReadCfg_Response;
           2599                         ;
           2600                         ;  // Structure for CMD_OS_WRITE_CFG
           2601                         ;  TPerOSWriteCfg_Request PerOSWriteCfg_Request;
           2602                         ;
           2603                         ;  // Structure for CMD_OS_WRITE_CFG_BYTE
           2604                         ;  TPerOSWriteCfgByte_Request PerOSWriteCfgByte_Request;
           2605                         ;
           2606                         ;  // Structure for CMD_OS_SET_SECURITY
           2607                         ;  TPerOSSetSecurity_Request PerOSSetSecurity_Request;
           2608                         ;
           2609                         ;  // Structure for CMD_OS_LOAD_CODE
           2610                         ;  TPerOSLoadCode_Request PerOSLoadCode_Request;
           2611                         ;
           2612                         ;  // Structure for CMD_OS_SLEEP
           2613                         ;  TPerOSSleep_Request PerOSSleep_Request;
           2614                         ;
           2615                         ;  // Structure for CMD_OS_SELECTIVE_BATCH
           2616                         ;  TPerOSSelectiveBatch_Request PerOSSelectiveBatch_Request;
           2617                         ;
           2618                         ;  // Structure for CMD_OS_TEST_RF_SIGNAL request
           2619                         ;  TPerOSTestRfSignal_Request PerOSTestRfSignal_Request;
           2620                         ;
           2621                         ;  // Structure for CMD_OS_INDICATE request
           2622                         ;  TPerOSIndicate_Request PerOSIndicate_Request;
           2623                         ;
           2624                         ;  // Structure for CMD_OS_TEST_RF_SIGNAL response
           2625                         ;  TPerOSTestRfSignal_Response PerOSTestRfSignal_Response;
           2626                         ;
           2627                         ;  // Structure for general memory request
           2628                         ;  TPerMemoryRequest MemoryRequest;
           2629                         ;
           2630                         ;  // Structure for general extended memory request
           2631                         ;  TPerXMemoryRequest XMemoryRequest;
           2632                         ;
           2633                         ;  // Structure for CMD_IO requests
           2634                         ;  TPerIoDirectionAndSet_Request PerIoDirectionAndSet_Request;
           2635                         ;
           2636                         ;  // Structure returned by CMD_THERMOMETER_READ
           2637                         ;  TPerThermometerRead_Response PerThermometerRead_Response;
           2638                         ;
           2639                         ;  // Structure for CMD_UART_OPEN
           2640                         ;  TPerUartOpen_Request PerUartOpen_Request;
           2641                         ;
           2642                         ;  // Structure for CMD_UART_[CLEAR_]WRITE_READ and CMD_SPI_WRITE_READ
           2643                         ;  TPerUartSpiWriteRead_Request PerUartSpiWriteRead_Request;
           2644                         ;
           2645                         ;  // Structure for CMD_FRC_SEND
           2646                         ;  TPerFrcSend_Request PerFrcSend_Request;
           2647                         ;
           2648                         ;  // Structure returned by CMD_FRC_SEND and CMD_FRC_SEND_SELECTIVE
           2649                         ;  TPerFrcSend_Response PerFrcSend_Response;
           2650                         ;
           2651                         ;  // Structure for CMD_FRC_SEND_SELECTIVE
           2652                         ;  TPerFrcSendSelective_Request PerFrcSendSelective_Request;
           2653                         ;
           2654                         ;  // Structure for request and response of CMD_FRC_SET_PARAMS
           2655                         ;  TPerFrcSetParams_RequestResponse PerFrcSetParams_RequestResponse;
           2656                         ;
           2657                         ;  // Interface and CMD_COORDINATOR_BRIDGE confirmation structure
           2658                         ;  TIFaceConfirmation IFaceConfirmation;
           2659                         ;} TDpaMessage;
           2660                         ;
           2661                         ;// Custom DPA Handler events
           2662                         ;#define	DpaEvent_DpaRequest				  0
           2663                         ;#define	DpaEvent_Interrupt				  1
           2664                         ;#define	DpaEvent_Idle					  2
           2665                         ;#define	DpaEvent_Init					  3
           2666                         ;#define	DpaEvent_Notification			  4
           2667                         ;#define	DpaEvent_AfterRouting			  5
           2668                         ;#define	DpaEvent_BeforeSleep			  6
           2669                         ;#define	DpaEvent_AfterSleep				  7
           2670                         ;#define	DpaEvent_Reset					  8
           2671                         ;#define	DpaEvent_DisableInterrupts		  9
           2672                         ;#define	DpaEvent_FrcValue				  10
           2673                         ;#define	DpaEvent_ReceiveDpaResponse		  11
           2674                         ;#define	DpaEvent_IFaceReceive			  12
           2675                         ;#define	DpaEvent_ReceiveDpaRequest		  13
           2676                         ;#define	DpaEvent_BeforeSendingDpaResponse 14
           2677                         ;#define	DpaEvent_PeerToPeer				  15
           2678                         ;#define	DpaEvent_UserDpaValue			  17
           2679                         ;#define	DpaEvent_FrcResponseTime		  18
           2680                         ;#define	DpaEvent_BondingButton			  19
           2681                         ;#define	DpaEvent_Indicate    			  20
           2682                         ;
           2683                         ;#define	DpaEvent_LAST					  DpaEvent_Indicate
           2684                         ;
           2685                         ;// Types of the diagnostic DPA Value that is returned inside DPA response 
           2686                         ;typedef enum
           2687                         ;{
           2688                         ;  DpaValueType_RSSI = 0,
           2689                         ;  DpaValueType_SupplyVoltage = 1,
           2690                         ;  DpaValueType_System = 2,
           2691                         ;  DpaValueType_User = 3
           2692                         ;} TDpaValueType;
           2693                         ;
           2694                         ;// Type (color) of LED peripheral
           2695                         ;typedef enum
           2696                         ;{
           2697                         ;  LED_COLOR_RED = 0,
           2698                         ;  LED_COLOR_GREEN = 1,
           2699                         ;  LED_COLOR_BLUE = 2,
           2700                         ;  LED_COLOR_YELLOW = 3,
           2701                         ;  LED_COLOR_WHITE = 4,
           2702                         ;  LED_COLOR_UNKNOWN = 0xff
           2703                         ;} TLedColor;
           2704                         ;
           2705                         ;// Baud rates
           2706                         ;typedef enum
           2707                         ;{
           2708                         ;  DpaBaud_1200 = 0x00,
           2709                         ;  DpaBaud_2400 = 0x01,
           2710                         ;  DpaBaud_4800 = 0x02,
           2711                         ;  DpaBaud_9600 = 0x03,
           2712                         ;  DpaBaud_19200 = 0x04,
           2713                         ;  DpaBaud_38400 = 0x05,
           2714                         ;  DpaBaud_57600 = 0x06,
           2715                         ;  DpaBaud_115200 = 0x07,
           2716                         ;  DpaBaud_230400 = 0x08
           2717                         ;} TBaudRates;
           2718                         ;
           2719                         ;// Useful PNUM_IO definitions
           2720                         ;typedef enum
           2721                         ;{
           2722                         ;  PNUM_IO_PORTA = 0x00,
           2723                         ;  PNUM_IO_TRISA = 0x00,
           2724                         ;  PNUM_IO_PORTB = 0x01,
           2725                         ;  PNUM_IO_TRISB = 0x01,
           2726                         ;  PNUM_IO_PORTC = 0x02,
           2727                         ;  PNUM_IO_TRISC = 0x02,
           2728                         ;  PNUM_IO_PORTE = 0x04,
           2729                         ;  PNUM_IO_TRISE = 0x04,
           2730                         ;  PNUM_IO_WPUB = 0x11,
           2731                         ;  PNUM_IO_DELAY = 0xff
           2732                         ;} PNUM_IO_Definitions;
           2733                         ;
           2734                         ;// To test for enumeration peripherals request
           2735                         ;#define IsDpaEnumPeripheralsRequestNoSize() ( _PNUM == PNUM_ENUMERATION && _PCMD == CMD_GET_PER_INFO )
           2736                         ;
           2737                         ;#if PARAM_CHECK_LEVEL >= 2
           2738                         ;#define IsDpaEnumPeripheralsRequest() ( IsDpaEnumPeripheralsRequestNoSize() && _DpaDataLength == 0 )
           2739                         ;#else
           2740                         ;#define IsDpaEnumPeripheralsRequest() IsDpaEnumPeripheralsRequestNoSize()
           2741                         ;#endif
           2742                         ;
           2743                         ;// To test for peripherals information request
           2744                         ;#define IsDpaPeripheralInfoRequestNoSize()  ( _PNUM != PNUM_ENUMERATION && _PCMD == CMD_GET_PER_INFO )
           2745                         ;
           2746                         ;#if PARAM_CHECK_LEVEL >= 2
           2747                         ;#define IsDpaPeripheralInfoRequest()  ( IsDpaPeripheralInfoRequestNoSize() && _DpaDataLength == 0 )
           2748                         ;#else
           2749                         ;#define IsDpaPeripheralInfoRequest()  IsDpaPeripheralInfoRequestNoSize()
           2750                         ;#endif
           2751                         ;
           2752                         ;// Optimized macro for both testing enumeration peripherals ELSE peripherals information. See examples
           2753                         ;#define	IfDpaEnumPeripherals_Else_PeripheralInfo_Else_PeripheralRequestNoSize() if ( _PCMD == CMD_GET_PER_INFO ) if ( _PNUM == PNUM_ENUMERATION )
           2754                         ;
           2755                         ;#if PARAM_CHECK_LEVEL >= 2
           2756                         ;#define IfDpaEnumPeripherals_Else_PeripheralInfo_Else_PeripheralRequest() if ( _DpaDataLength == 0 && _PCMD == CMD_GET_PER_INFO ) if ( _PNUM == PNUM_ENUMERATION )
           2757                         ;#else
           2758                         ;#define	IfDpaEnumPeripherals_Else_PeripheralInfo_Else_PeripheralRequest() IfDpaEnumPeripherals_Else_PeripheralInfo_Else_PeripheralRequestNoSize()
           2759                         ;#endif
           2760                         ;
           2761                         ;#ifdef __CC5X__
           2762                         ;
           2763                         ;// DPA message at bufferRF
           2764                         ;TDpaMessage DpaRfMessage @bufferRF;
           2765                         ;
           2766                         ;// Actual allocation of the RAM Peripheral memory block @ UserBank_02
           2767                         ;bank12 uns8  PeripheralRam[PERIPHERAL_RAM_LENGTH] @ 0x620;
           2768                         ;
           2769                         ;// Actual DPA message parameters at memory
           2770                         ;#define	_NADR			RX
           2771                         ;#define _NADRhigh		RTAUX
           2772                         ;#define _PNUM			PNUM
           2773                         ;#define _PCMD			PCMD
           2774                         ;#define _DpaDataLength	DLEN
           2775                         ;#define _DpaMessage		DpaRfMessage
           2776                         ;
           2777                         ;// Return actual DPA user routine event
           2778                         ;#define	GetDpaEvent()	userReg0
           2779                         ;
           2780                         ;// Stores DPA Params inside DPA request/response
           2781                         ;#define	_DpaParams		PPAR
           2782                         ;// Get DPA Value type out of the DPA Params
           2783                         ;#define	DpaValueType()	( _DpaParams & 0b11 )
           2784                         ;
           2785                         ;// When TRUE then encryptBufferRF/decryptBufferRF is done by AccessPassord
           2786                         ;bit encryptByAccessPassword @ usedBank0[0x23].7;
           2787                         ;
           2788                         ;// DP2P response time-slot time in 10 ms
           2789                         ;#define DP2P_TIMESLOT   11
           2790                         ;
           2791                         ;// DP2P request packet. Fills out the whole bufferRF.
           2792                         ;typedef struct
           2793                         ;{
           2794                         ;  uns8  Header[3];  // 0x000000
           2795                         ;  uns8  SelectedNodes[30];
           2796                         ;  uns8  SlotLength;
           2797                         ;  uns8  ResponseTxPower;
           2798                         ;  uns8  Reserved;
           2799                         ;  uns16	HWPID;
           2800                         ;  uns8  PDATA[sizeofBufferRF - ( 3 + 30 + 1 + 1 + 1 ) * sizeof( uns8 ) - ( 1 ) * sizeof( uns16 )]; // size is 26 bytes
           2801                         ;} STRUCTATTR TDP2Prequest;
           2802                         ;
           2803                         ;// DP2P invite packet.
           2804                         ;typedef struct
           2805                         ;{
           2806                         ;  uns8  Header[3];  // 0x000001
           2807                         ;  uns8  NADR;
           2808                         ;  uns8  Rand[12];
           2809                         ;} STRUCTATTR TDP2Invite;
           2810                         ;
           2811                         ;// DP2P confirm packet.
           2812                         ;typedef struct
           2813                         ;{
           2814                         ;  uns8  Header[3];  // 0x000003
           2815                         ;  uns8  NADR;
           2816                         ;  uns8  Rand[12];
           2817                         ;} STRUCTATTR TDP2Confirm;
           2818                         ;
           2819                         ;// DP2P response packet.
           2820                         ;typedef struct
           2821                         ;{
           2822                         ;  uns8  Header[3];  // 0xFfFfFf
           2823                         ;  uns8  NADR;
           2824                         ;  uns8  PDATA[DPA_MAX_DATA_LENGTH];
           2825                         ;} STRUCTATTR TDP2Presponse;
           2826                         ;
           2827                         ;// Include assembler definitions
           2828                         ;#include "HexCodes.h"
           2829                         ;
           2830                         ;// Next code must start at the IQRF APPLICATION routine entry point
           2831                         ;#pragma origin __APPLICATION_ADDRESS
     0000  2832         ORG 0x3A00
           2833 
           2834   ; FILE ../../../../Development/include/DPA/DPAcustomHandler.h
           2835                         ;// *********************************************************************
           2836                         ;//   Main Custom DPA Handler header                                    *
           2837                         ;// *********************************************************************
           2838                         ;// Copyright (c) IQRF Tech s.r.o.
           2839                         ;//
           2840                         ;// File:    $RCSfile: DPAcustomHandler.h,v $
           2841                         ;// Version: $Revision: 1.113 $
           2842                         ;// Date:    $Date: 2020/02/27 13:17:18 $
           2843                         ;//
           2844                         ;// Revision history:
           2845                         ;//   2020/02/27  Release for DPA 4.13
           2846                         ;//   2020/01/09  Release for DPA 4.12
           2847                         ;//   2019/12/11  Release for DPA 4.11
           2848                         ;//   2019/10/09  Release for DPA 4.10
           2849                         ;//   2019/06/12  Release for DPA 4.03
           2850                         ;//   2019/06/03  Release for DPA 4.02
           2851                         ;//   2019/03/07  Release for DPA 4.01
           2852                         ;//   2019/01/10  Release for DPA 4.00
           2853                         ;//   2018/10/25  Release for DPA 3.03
           2854                         ;//   2017/11/16  Release for DPA 3.02
           2855                         ;//   2017/08/14  Release for DPA 3.01
           2856                         ;//   2017/03/13  Release for DPA 3.00
           2857                         ;//   2016/09/12  Release for DPA 2.28
           2858                         ;//   2016/04/14  Release for DPA 2.27
           2859                         ;//   2016/03/03  Release for DPA 2.26
           2860                         ;//   2016/01/21  Release for DPA 2.25
           2861                         ;//   2015/12/01  Release for DPA 2.24
           2862                         ;//   2015/10/23  Release for DPA 2.23
           2863                         ;//   2015/09/25  Release for DPA 2.22
           2864                         ;//   2015/09/03  Release for DPA 2.21
           2865                         ;//   2015/08/05  Release for DPA 2.20
           2866                         ;//   2014/10/31  Release for DPA 2.10
           2867                         ;//   2014/04/30  Release for DPA 2.00
           2868                         ;//   2013/10/03  Release for DPA 1.00
           2869                         ;//
           2870                         ;// *********************************************************************
           2871                         ;
           2872                         ;// Online DPA documentation https://doc.iqrf.org/DpaTechGuide/
           2873                         ;// IQRF Standards documentation https://www.iqrfalliance.org/iqrf-interoperability/
           2874                         ;
           2875                         ;#ifndef _CUSTOM_DPA_HANDLER_
           2876                         ;#define _CUSTOM_DPA_HANDLER_
           2877                         ;
           2878                         ;//############################################################################################
           2879                         ;// 1st include 
           2880                         ;
           2881                         ;// Custom DPA Handler routine declaration
           2882                         ;bit CustomDpaHandler();
           2883                         ;
           2884                         ;// Various DPA flags shared between DPA and Custom DPA Handler
           2885                         ;uns8 DpaFlags @ usedBank4[0];
           2886                         ;#ifdef COORDINATOR_CUSTOM_HANDLER
           2887                         ;// [C] TRUE if interface master is not connected (detected)
           2888                         ;bit IFaceMasterNotConnected @ DpaFlags.2;
           2889                         ;#endif
           2890                         ;// [N] [CN] DPA by interface notification is sent also when there was a "reading" like DPA request
           2891                         ;bit EnableIFaceNotificationOnRead @ DpaFlags.3;
           2892                         ;// [N] [NC] TRUE when node was just bonded using default bonding procedure
           2893                         ;bit NodeWasBonded @ DpaFlags.4;
           2894                         ;
           2895                         ;// [C] Ticks (decrementing) counter usable for timing in the coordinator's Customer DPA Handler
           2896                         ;uns16 DpaTicks @ usedBank4[1];
           2897                         ;// [N] [NC] toutRF for LP mode, read from configuration memory after reset
           2898                         ;uns8 LPtoutRF @ usedBank4[3];
           2899                         ;// DPA Request/Response HWPID
           2900                         ;uns16 _HWPID @ usedBank4[4];
           2901                         ;// Identifies type of reset (stored at UserReg0 upon module reset). See Reset chapter at IQRF User's Guide for more information
           2902                         ;uns8 ResetType @ usedBank4[6];
           2903                         ;// User DPA Values to return
           2904                         ;uns8 UserDpaValue @ usedBank4[7];
           2905                         ;// Network depth of the DPA request/response, increases on bridging, decreases on back-bridging
           2906                         ;uns8 NetDepth @ usedBank4[8];
           2907                         ;// TRUE when node was at DPA Service Mode after last boot
           2908                         ;bit DSMactivated @ usedBank4[9].0;
           2909                         ;// If set to TRUE, then LP RX mode in the main loop can be terminated by pin, see _RLPMAT
           2910                         ;bit LpRxPinTerminate @ usedBank4[9].1;
           2911                         ;// If set to TRUE, then [C] executes asynchronous DPA requests received from [N]
           2912                         ;bit AsyncReqAtCoordinator @ usedBank4[9].2;
           2913                         ;// RX filter used at the DPA main loop checkRF call
           2914                         ;uns8 RxFilter @ usedBank4[11];
           2915                         ;// Countdown variable for button bonding before going to deep sleep 
           2916                         ;uns16 BondingSleepCountdown @ usedBank4[12];
           2917                         ;#define BONDING_SLEEP_COUNTDOWN_UNIT  290
           2918                         ;// Non-zero pseudo-random value, read-only, updated on every Reset and Idle event, at [N] only.
           2919                         ;uns16 Random @ usedBank4[14];
           2920                         ;
           2921                         ;// Macro to return an error from the peripheral handler. If the code size is not an issue this macro is the right choice.
           2922                         ;#define DpaApiReturnPeripheralError(error) do { \
           2923                         ;	DpaApiSetPeripheralError( error ); \
           2924                         ;	return Carry; \
           2925                         ;  } while( 0 )
           2926                         ;
           2927                         ;// DPA API functions, see documentation for details
           2928                         ;#define	DpaApiRfTxDpaPacket( dpaValue, netDepthAndFlags ) DpaApiEntry( dpaValue, netDepthAndFlags, DPA_API_RFTX_DPAPACKET )
           2929                         ;#define	DpaApiReadConfigByte( index )					  DpaApiEntry( index, param3.low8, DPA_API_READ_CONFIG_BYTE )
           2930                         ;#define	DpaApiLocalRequest()							  DpaApiEntry( param2, param3.low8, DPA_API_LOCAL_REQUEST )
           2931                         ;#define	DpaApiSetPeripheralError( error )				  DpaApiEntry( error, param3.low8, DPA_API_SET_PERIPHERAL_ERROR )
           2932                         ;#define	DpaApiSendToIFaceMaster( dpaValue, flags )		  DpaApiEntry( dpaValue, flags, DPA_API_SEND_TO_IFACEMASTER )
           2933                         ;#define	DpaApiSetRfDefaults()							  DpaApiEntry( param2, param3.low8, DPA_API_SET_RF_DEFAULTS )
           2934                         ;
           2935                         ;#ifdef COORDINATOR_CUSTOM_HANDLER
           2936                         ;#define	DpaApiRfTxDpaPacketCoordinator()				  DpaApiEntry( param2, param3.low8, DPA_API_COORDINATOR_RFTX_DPAPACKET )
           2937                         ;#endif
           2938                         ;
           2939                         ;#ifdef COORDINATOR_CUSTOM_HANDLER
           2940                         ;#undef	DpaEvent_Interrupt
           2941                         ;#undef	DpaEvent_BeforeSleep
           2942                         ;#undef	DpaEvent_AfterSleep
           2943                         ;#undef	DpaEvent_FrcValue
           2944                         ;#undef	DpaEvent_FrcResponseTime
           2945                         ;#else
           2946                         ;#undef  DpaEvent_ReceiveDpaResponse
           2947                         ;#undef  DpaEvent_IFaceReceive
           2948                         ;#endif
           2949                         ;
           2950                         ;// To detect overlapping code in case someone would put some code before this header by mistake
           2951                         ;#pragma origin __APPLICATION_ADDRESS
     0000  2952         ORG 0x3A00
           2953                         ;#pragma updateBank 0
           2954                         ;
           2955                         ;//############################################################################################
           2956                         ;// Main IQRF entry point jumps to the main DPA entry point
           2957                         ;void APPLICATION()
           2958                         ;//############################################################################################
           2959                         ;{
           2960 APPLICATION
           2961                         ;  #asm
           2962                         ;    DW  __MOVLP( MAIN_DPA_ADDRESS >> 8 );
3A00 31AC  2963         DW    0x31AC
           2964                         ;  DW  __GOTO( MAIN_DPA_ADDRESS );
3A01 2C04  2965         DW    0x2C04
           2966                         ;  #endasm
           2967                         ;
           2968                         ;#ifndef NO_CUSTOM_DPA_HANDLER
           2969                         ;    // Fake call to force CustomDpaHandler() compilation
           2970                         ;    CustomDpaHandler();
3A02 2220  2971         CALL  CustomDpaHandler
           2972                         ;#endif
           2973                         ;
           2974                         ;  // Fake call to force DpaApiEntry() compilation
           2975                         ;  DpaApiEntry( param2, param3.low8, W );
3A03 3204  2976         BRA   DpaApiEntry
           2977                         ;}
           2978                         ;
           2979                         ;//############################################################################################
           2980                         ;// Entry stub to the real DPA API entry
           2981                         ;#pragma origin DPA_API_ADDRESS_ENTRY
     0000  2982         ORG 0x3A08
           2983                         ;uns8  DpaApiEntry( uns8 par1 @ param2, uns8 par2 @ param3.low8, uns8 apiIndex @ W )
           2984                         ;//############################################################################################
           2985                         ;{
           2986 DpaApiEntry
           2987                         ;  #asm
           2988                         ;    DW  __MOVLP( DPA_API_ADDRESS >> 8 );
3A08 31AC  2989         DW    0x31AC
           2990                         ;  DW  __CALL( DPA_API_ADDRESS );
3A09 2400  2991         DW    0x2400
           2992                         ;  DW  __MOVLP( DPA_API_ADDRESS_ENTRY >> 8 );
3A0A 31BA  2993         DW    0x31BA
           2994                         ;  #endasm
           2995                         ;
           2996                         ;    return W;
3A0B 0008  2997         RETURN
           2998                         ;}
           2999                         ;
           3000                         ;//############################################################################################
           3001                         ;#pragma origin DPA_API_ADDRESS_ENTRY + 0x08
     0000  3002         ORG 0x3A10
           3003                         ;
           3004                         ;//############################################################################################
           3005                         ;
           3006                         ;#ifndef NO_CUSTOM_DPA_HANDLER
           3007                         ;// Next comes Custom DPA handler routine
           3008                         ;#pragma origin CUSTOM_HANDLER_ADDRESS
     0000  3009         ORG 0x3A20
           3010                         ;#endif
           3011                         ;
           3012                         ;#pragma updateBank 1
           3013 
           3014   ; FILE D:\DP\IQRF_Startup_Package_OS403D_TR-7xD_200302\IQRF_OS403_7xD\Examples\DPA\CustomDpaHandlerExamples\IQRF_Standard\4C02_DDC-SE_LP.c
           3015                         ;// ***********************************************************************************************************
           3016                         ;//   Custom DPA Handler code example - Standard Sensors - DDC-SE-01 - LP version *
           3017                         ;// ***********************************************************************************************************
           3018                         ;// Copyright (c) IQRF Tech s.r.o.
           3019                         ;//
           3020                         ;// File:    $RCSfile: 4C02_DDC-SE_LP.c,v $
           3021                         ;// Version: $Revision: 1.9 $
           3022                         ;// Date:    $Date: 2020/02/20 17:18:59 $
           3023                         ;//
           3024                         ;// Revision history:
           3025                         ;//   2020/01/02  Release for DPA 4.11
           3026                         ;//   2019/03/07  Release for DPA 4.01
           3027                         ;//
           3028                         ;// *********************************************************************
           3029                         ;
           3030                         ;// Online DPA documentation https://doc.iqrf.org/DpaTechGuide/
           3031                         ;// IQRF Standards documentation https://www.iqrfalliance.org/iqrf-interoperability/
           3032                         ;
           3033                         ;// This example implements 3 sensors according to the IQRF Sensors standard
           3034                         ;// Index 0 i.e. 1st sensor is either Dallas 18B20 or MCP9802 temperature sensor at DDC-SE-01 board according to the HW jumper position and symbol DALLASnotMCP.
           3035                         ;// Index 1 i.e. 2nd sensor is light intensity indicator at DDC-SE-01 board (value range is 0[max light]-127[max dark]).
           3036                         ;// Index 2 i.e. 3rd sensor is potentiometer value at DDC-SE-01 board (value range is 0[left stop]-127[right stop]).
           3037                         ;
           3038                         ;// This example must be compiled without a "-bu" compiler switch in order to fit into available Flash memory
           3039                         ;
           3040                         ;// Default IQRF include (modify the path according to your setup)
           3041                         ;#include "IQRF.h"
           3042                         ;
           3043                         ;// We can save more instructions if needed by the symbol below
           3044                         ;// #define	PARAM_CHECK_LEVEL 1
           3045                         ;
           3046                         ;// Default DPA header (modify the path according to your setup)
           3047                         ;#include "DPA.h"
           3048                         ;// Default Custom DPA Handler header (modify the path according to your setup)
           3049                         ;#include "DPAcustomHandler.h"
           3050                         ;// IQRF standards header (modify the path according to your setup)
           3051                         ;#include "IQRFstandard.h"
           3052                         ;#include "IQRF_HWPID.h"
           3053                         ;// I2C Master library
           3054                         ;#include "lib/I2Cmaster.c"
           3055                         ;
           3056                         ;// If defined then the handler is compiled for Dallas otherwise for MCP9802
           3057                         ;#define	DALLASnotMCP
           3058                         ;
           3059                         ;//############################################################################################
           3060                         ;
           3061                         ;// Define useful macro that saves some code but not preset at DPA < 3.01
           3062                         ;#if DPA_VERSION_MASTER	< 0x0301
           3063                         ;// Optimized macro for both testing enumeration peripherals ELSE peripherals information. See examples
           3064                         ;#define	IfDpaEnumPeripherals_Else_PeripheralInfo_Else_PeripheralRequestNoSize() if ( _PCMD == CMD_GET_PER_INFO ) if ( _PNUM == PNUM_ENUMERATION )
           3065                         ;
           3066                         ;#if PARAM_CHECK_LEVEL >= 2
           3067                         ;#define IfDpaEnumPeripherals_Else_PeripheralInfo_Else_PeripheralRequest() if ( _DpaDataLength == 0 && _PCMD == CMD_GET_PER_INFO ) if ( _PNUM == PNUM_ENUMERATION )
           3068                         ;#else
           3069                         ;#define	IfDpaEnumPeripherals_Else_PeripheralInfo_Else_PeripheralRequest() IfDpaEnumPeripherals_Else_PeripheralInfo_Else_PeripheralRequestNoSize()
           3070                         ;#endif
           3071                         ;#endif
           3072                         ;
           3073                         ;//############################################################################################
           3074                         ;
           3075                         ;// Number of implemented sensors
           3076                         ;#define	SENSORS_COUNT 3
           3077                         ;
           3078                         ;// Variable to store sensor value at Get?_????() methods. This example implements sensors returning maximum 2 bytes of data.
           3079                         ;uns16 sensorValue @ param3;
           3080                         ;
           3081                         ;// Reads sensor value to the sensorValue variable and to responseFRCvalue(2B) variable
           3082                         ;bit Get0_Temperature();
           3083                         ;bit Get1_BinaryData_Light();
           3084                         ;bit Get2_BinaryData_Potentiometer();
           3085                         ;
           3086                         ;// Stores sensor value byte(s) to the FSR1[+1...], in case of PCMD_STD_SENSORS_READ_TYPES_AND_VALUES sensor type is stored before value byte(s)
           3087                         ;void StoreValue( uns8 sensorType );
           3088                         ;
           3089                         ;#ifdef DALLASnotMCP
           3090                         ;// Sensor connected to PORT C.3 (compatible with DDC-SE-01)
           3091                         ;#define OneWire_TRIS         TRISC.3
           3092                         ;#define OneWire_IO_IN        PORTC.3
           3093                         ;#define OneWire_IO_OUT       LATC.3
           3094                         ;
           3095                         ;// ms per ticks
           3096                         ;#define	TICKS_LEN  10
           3097                         ;
           3098                         ;// Writes sensor configuration (resolution)
           3099                         ;bit Ds18B20WriteConfig( uns8 value );
           3100                         ;
           3101                         ;// Resets OneWire
           3102                         ;bit OneWireReset();
           3103                         ;// Reads OneWire byte
           3104                         ;uns8 OneWireReadByte();
           3105                         ;// Writes OneWire byte
           3106                         ;void OneWireWriteByte( uns8 byte );
           3107                         ;
           3108                         ;// DS18B20 commands
           3109                         ;#define CMD_READROM		  0x33
           3110                         ;#define CMD_CONVERTTEMP	  0x44
           3111                         ;#define CMD_CPYSCRATCHPAD 0x48
           3112                         ;#define CMD_WSCRATCHPAD	  0x4e
           3113                         ;#define CMD_MATCHROM	  0x55
           3114                         ;#define CMD_RPWRSUPPLY	  0xb4
           3115                         ;#define CMD_RECEEPROM	  0xb8
           3116                         ;#define CMD_RSCRATCHPAD	  0xbe
           3117                         ;#define CMD_SKIPROM		  0xcc
           3118                         ;#define CMD_ALARMSEARCH	  0xec
           3119                         ;#define CMD_SEARCHROM	  0xf0
           3120                         ;
           3121                         ;// Final DS18B20 temperature value read by state machine
           3122                         ;uns16 temperature;
           3123                         ;
           3124                         ;#else // DALLASnotMCP
           3125                         ;
           3126                         ;// I2C SCL frequency [Hz]
           3127                         ;#define I2Cfrequency      50000
           3128                         ;
           3129                         ;// Own implementation with timeout
           3130                         ;#define i2c_waitForIdle_REDEFINE
           3131                         ;
           3132                         ;// TRUE if I2C timeout occurred
           3133                         ;bit i2cTimeout;
           3134                         ;
           3135                         ;// MCP9802 address
           3136                         ;#define I2C_ADR         	0b10010110
           3137                         ;// Power pin
           3138                         ;#define PWR_SENSOR_TRIS 	TRISC.7
           3139                         ;#define PWR_SENSOR_IO   	LATC.7
           3140                         ;
           3141                         ;#endif
           3142                         ;
           3143                         ;// Must be the 1st defined function in the source code in order to be placed at the correct FLASH location!
           3144                         ;//############################################################################################
           3145                         ;bit CustomDpaHandler()
           3146                         ;//############################################################################################
           3147                         ;{
           3148 CustomDpaHandler
           3149                         ;  // This forces CC5X to wisely use MOVLB instructions (doc says:  The 'default' bank is used by the compiler for loops and labels when the algorithm gives up finding the optimal choice)
           3150                         ;#pragma updateBank default = UserBank_01
           3151                         ;
           3152                         ;#ifdef DALLASnotMCP
           3153                         ;  // Finite machine states
           3154                         ;  typedef enum
           3155                         ;  {
           3156                         ;    S_ResetConvertT = 0,
           3157                         ;    S_SkipRomConvertT,
           3158                         ;    S_CmdConvertT,
           3159                         ;
           3160                         ;    S_WaitConvertT,
           3161                         ;
           3162                         ;    S_ResetReadTemp,
           3163                         ;    S_SkipRomReadTemp,
           3164                         ;    S_CmdReadTemp,
           3165                         ;    S_Byte1ReadTemp,
           3166                         ;    S_Byte2ReadTemp
           3167                         ;  } TState;
           3168                         ;#endif
           3169                         ;
           3170                         ;  // Handler presence mark
           3171                         ;  clrwdt();
3A20 0064  3172         CLRWDT
           3173                         ;
           3174                         ;  // Sleeping parameters, valid when Time != 0
           3175                         ;  static TPerOSSleep_Request PerOSSleep_Request;
           3176                         ;
           3177                         ;#ifdef DALLASnotMCP
           3178                         ;  // Finite machine state
           3179                         ;  static uns8 state; // = S_ResetConvertT = 0
           3180                         ;  // Pre-read lower temperature byte
           3181                         ;  static uns8 temperatureByteLow;
           3182                         ;  // Conversion timeout counter
           3183                         ;  static uns16 timeoutStart;
           3184                         ;#endif
           3185                         ;
           3186                         ;  // Detect DPA event to handle
           3187                         ;  switch ( GetDpaEvent() )
3A21 0870  3188         MOVF  userReg0,W
3A22 3A01  3189         XORLW 0x01
3A23 1903  3190         BTFSC 0x03,Zero_
3A24 3216  3191         BRA   m001
3A25 3A03  3192         XORLW 0x03
3A26 1903  3193         BTFSC 0x03,Zero_
3A27 3214  3194         BRA   m002
3A28 3A01  3195         XORLW 0x01
3A29 1903  3196         BTFSC 0x03,Zero_
3A2A 3271  3197         BRA   m014
3A2B 3A04  3198         XORLW 0x04
3A2C 1903  3199         BTFSC 0x03,Zero_
3A2D 2B73  3200         GOTO  m043
3A2E 3A01  3201         XORLW 0x01
3A2F 1903  3202         BTFSC 0x03,Zero_
3A30 2B73  3203         GOTO  m043
3A31 3A06  3204         XORLW 0x06
3A32 1903  3205         BTFSC 0x03,Zero_
3A33 3276  3206         BRA   m016
3A34 3A0A  3207         XORLW 0x0A
3A35 1903  3208         BTFSC 0x03,Zero_
3A36 32E1  3209         BRA   m031
3A37 3A18  3210         XORLW 0x18
3A38 1903  3211         BTFSC 0x03,Zero_
3A39 2B66  3212         GOTO  m041
3A3A 2B73  3213         GOTO  m043
           3214                         ;  {
           3215                         ;    // -------------------------------------------------
           3216                         ;    case DpaEvent_Interrupt:
           3217                         ;      // Do an extra quick background interrupt work
           3218                         ;
           3219                         ;      return Carry;
3A3B 0008  3220 m001    RETURN
           3221                         ;
           3222                         ;      // -------------------------------------------------
           3223                         ;    case DpaEvent_Idle:
           3224                         ;      // Do a quick background work when RF packet is not received
           3225                         ;
           3226                         ;      // Should go to sleep?
           3227                         ;      if ( PerOSSleep_Request.Time != 0 )
3A3C 002B  3228 m002    MOVLB 0x0B
3A3D 0847  3229         MOVF  PerOSSleep_Request,W
3A3E 0448  3230         IORWF PerOSSleep_Request+1,W
3A3F 1903  3231         BTFSC 0x03,Zero_
3A40 3217  3232         BRA   m003
           3233                         ;      {
           3234                         ;        // Copy sleep parameters to the DPA request
           3235                         ;        _DpaMessage.PerOSSleep_Request.Time = PerOSSleep_Request.Time;
3A41 0847  3236         MOVF  PerOSSleep_Request,W
3A42 0029  3237         MOVLB 0x09
3A43 00A0  3238         MOVWF DpaRfMessage
3A44 002B  3239         MOVLB 0x0B
3A45 0848  3240         MOVF  PerOSSleep_Request+1,W
3A46 0029  3241         MOVLB 0x09
3A47 00A1  3242         MOVWF DpaRfMessage+1
           3243                         ;        _DpaMessage.PerOSSleep_Request.Control = PerOSSleep_Request.Control;
3A48 002B  3244         MOVLB 0x0B
3A49 0849  3245         MOVF  PerOSSleep_Request+2,W
3A4A 0029  3246         MOVLB 0x09
3A4B 00A2  3247         MOVWF DpaRfMessage+2
           3248                         ;        // Finalize OS Sleep DPA Request
           3249                         ;        _DpaDataLength = sizeof( _DpaMessage.PerOSSleep_Request );
3A4C 3003  3250         MOVLW 0x03
3A4D 0025  3251         MOVLB 0x05
3A4E 00A1  3252         MOVWF DLEN
           3253                         ;        _PNUM = PNUM_OS;
3A4F 3002  3254         MOVLW 0x02
3A50 00AE  3255         MOVWF PNUM
           3256                         ;        _PCMD = CMD_OS_SLEEP;
3A51 3004  3257         MOVLW 0x04
3A52 00AF  3258         MOVWF PCMD
           3259                         ;        // Perform local DPA Request to go to sleep
           3260                         ;        DpaApiLocalRequest();
3A53 3004  3261         MOVLW 0x04
3A54 2208  3262         CALL  DpaApiEntry
           3263                         ;        // Switch off sleeping time=flag
           3264                         ;        PerOSSleep_Request.Time = 0;
3A55 002B  3265         MOVLB 0x0B
3A56 01C7  3266         CLRF  PerOSSleep_Request
3A57 01C8  3267         CLRF  PerOSSleep_Request+1
           3268                         ;      }
           3269                         ;
           3270                         ;#ifdef DALLASnotMCP
           3271                         ;      // Run finite state machine to read temperature from DS18B20 at background so the temperature value is immediately ready for FRC 
           3272                         ;
           3273                         ;      // Make sure 1Wire data pin at LATX.y is low as it might be set by another PORTX.? pin manipulation
           3274                         ;      OneWire_IO_OUT = 0;
3A58 0022  3275 m003    MOVLB 0x02
3A59 118E  3276         BCF   LATC,3
           3277                         ;
           3278                         ;      skip( state );
3A5A 002B  3279         MOVLB 0x0B
3A5B 084A  3280         MOVF  state,W
3A5C 000B  3281         BRW  
           3282                         ;#pragma computedGoto 1
           3283                         ;      goto _S_ResetConvertT;
3A5D 320F  3284         BRA   m006
           3285                         ;      goto _S_SkipRomConvertT;
3A5E 3216  3286         BRA   m008
           3287                         ;      goto _S_CmdConvertT;
3A5F 3218  3288         BRA   m009
           3289                         ;      goto _S_WaitConvertT;
3A60 321F  3290         BRA   m010
           3291                         ;      goto _S_ResetReadTemp;
3A61 320B  3292         BRA   m006
           3293                         ;      goto _S_SkipRomReadTemp;
3A62 3212  3294         BRA   m008
           3295                         ;      goto _S_CmdReadTemp;
3A63 322F  3296         BRA   m011
           3297                         ;      goto _S_Byte1ReadTemp;
3A64 3231  3298         BRA   m012
           3299                         ;      goto _S_Byte2ReadTemp;
           3300                         ;#pragma computedGoto 0
           3301                         ;      ;
           3302                         ;      // --------------
           3303                         ;_S_Byte2ReadTemp:
           3304                         ;      temperature.high8 = OneWireReadByte();
3A65 2438  3305 m004    CALL  OneWireReadByte
3A66 002B  3306         MOVLB 0x0B
3A67 00C6  3307         MOVWF temperature+1
           3308                         ;      temperature.low8 = temperatureByteLow;
3A68 084B  3309         MOVF  temperatureByteLow,W
3A69 00C5  3310         MOVWF temperature
           3311                         ;
           3312                         ;ResetMachine:
           3313                         ;      state = S_ResetConvertT;
3A6A 002B  3314 m005    MOVLB 0x0B
3A6B 01CA  3315         CLRF  state
           3316                         ;      goto ExitMachine;
3A6C 2B73  3317         GOTO  m043
           3318                         ;
           3319                         ;      // --------------
           3320                         ;_S_ResetConvertT:
           3321                         ;_S_ResetReadTemp:
           3322                         ;      if ( !OneWireReset() )
3A6D 2451  3323 m006    CALL  OneWireReset
3A6E 1803  3324         BTFSC 0x03,Carry
3A6F 3229  3325         BRA   m013
           3326                         ;      {
           3327                         ;_S_Error_Reset:
           3328                         ;        STD_SENSOR_TYPE_TEMPERATURE_SET_ERROR( temperature );
3A70 002B  3329 m007    MOVLB 0x0B
3A71 01C5  3330         CLRF  temperature
3A72 3080  3331         MOVLW 0x80
3A73 00C6  3332         MOVWF temperature+1
           3333                         ;        goto ResetMachine;
3A74 33F5  3334         BRA   m005
           3335                         ;      }
           3336                         ;      goto NextState;
           3337                         ;
           3338                         ;      // --------------
           3339                         ;_S_SkipRomConvertT:
           3340                         ;_S_SkipRomReadTemp:
           3341                         ;      // OneWire: Skip ROM
           3342                         ;      OneWireWriteByte( CMD_SKIPROM );
3A75 30CC  3343 m008    MOVLW 0xCC
3A76 241F  3344         CALL  OneWireWriteByte
           3345                         ;      goto NextState;
3A77 3221  3346         BRA   m013
           3347                         ;
           3348                         ;      // --------------
           3349                         ;_S_CmdConvertT:
           3350                         ;      // OneWire: Convert temperature
           3351                         ;      OneWireWriteByte( CMD_CONVERTTEMP );
3A78 3044  3352 m009    MOVLW 0x44
3A79 241F  3353         CALL  OneWireWriteByte
           3354                         ;      // Start timeout for approx 750 ms (the longest conversion time)
           3355                         ;      captureTicks();
3A7A 207C  3356         CALL  captureTicks
           3357                         ;      // Remember start time
           3358                         ;      timeoutStart = param3;
3A7B 0874  3359         MOVF  param3,W
3A7C 00CC  3360         MOVWF timeoutStart
3A7D 0875  3361         MOVF  param3+1,W
3A7E 00CD  3362         MOVWF timeoutStart+1
           3363                         ;      goto NextState;
3A7F 3219  3364         BRA   m013
           3365                         ;
           3366                         ;      // --------------
           3367                         ;_S_WaitConvertT:
           3368                         ;      // Measured?
           3369                         ;      if ( OneWireReadByte() == 0xff )
3A80 2438  3370 m010    CALL  OneWireReadByte
3A81 3AFF  3371         XORLW 0xFF
3A82 1903  3372         BTFSC 0x03,Zero_
           3373                         ;        goto NextState;
3A83 3215  3374         BRA   m013
           3375                         ;
           3376                         ;      // Timeout?
           3377                         ;      captureTicks();
3A84 207C  3378         CALL  captureTicks
           3379                         ;      param3 -= timeoutStart;
3A85 084D  3380         MOVF  timeoutStart+1,W
3A86 02F5  3381         SUBWF param3+1,1
3A87 084C  3382         MOVF  timeoutStart,W
3A88 02F4  3383         SUBWF param3,1
3A89 1C03  3384         BTFSS 0x03,Carry
3A8A 03F5  3385         DECF  param3+1,1
           3386                         ;      // Yes!
           3387                         ;      if ( param3 > ( 2 + 750 / TICKS_LEN ) )
3A8B 0875  3388         MOVF  param3+1,W
3A8C 1D03  3389         BTFSS 0x03,Zero_
3A8D 33E2  3390         BRA   m007
3A8E 304E  3391         MOVLW 0x4E
3A8F 0274  3392         SUBWF param3,W
3A90 1C03  3393         BTFSS 0x03,Carry
3A91 32E1  3394         BRA   m043
           3395                         ;        goto _S_Error_Reset;
3A92 33DD  3396         BRA   m007
           3397                         ;
           3398                         ;      goto ExitMachine;
           3399                         ;
           3400                         ;      // --------------
           3401                         ;_S_CmdReadTemp:
           3402                         ;      // OneWire: Read scratchpad
           3403                         ;      OneWireWriteByte( CMD_RSCRATCHPAD );
3A93 30BE  3404 m011    MOVLW 0xBE
3A94 241F  3405         CALL  OneWireWriteByte
           3406                         ;      goto NextState;
3A95 3203  3407         BRA   m013
           3408                         ;
           3409                         ;      // --------------
           3410                         ;_S_Byte1ReadTemp:
           3411                         ;      temperatureByteLow = OneWireReadByte();
3A96 2438  3412 m012    CALL  OneWireReadByte
3A97 002B  3413         MOVLB 0x0B
3A98 00CB  3414         MOVWF temperatureByteLow
           3415                         ;      goto NextState;
           3416                         ;
           3417                         ;      // --------------
           3418                         ;NextState:
           3419                         ;      ++state;
3A99 002B  3420 m013    MOVLB 0x0B
3A9A 0ACA  3421         INCF  state,1
           3422                         ;
           3423                         ;ExitMachine:
           3424                         ;#endif
           3425                         ;      break;
3A9B 32D7  3426         BRA   m043
           3427                         ;
           3428                         ;      // -------------------------------------------------
           3429                         ;    case DpaEvent_Init:
           3430                         ;      // Do a one time initialization before main loop starts
           3431                         ;
           3432                         ;      // Initialize ticks
           3433                         ;      startCapture();
3A9C 2079  3434 m014    CALL  startCapture
           3435                         ;
           3436                         ;      // Initialize sensors
           3437                         ;      // C5 (AN4) as input 
           3438                         ;      moduleInfo();
3A9D 201C  3439         CALL  moduleInfo
           3440                         ;      // Connected TR pins?
           3441                         ;      if ( !bufferINFO[5].7 )
3A9E 0026  3442         MOVLB 0x06
3A9F 1BA5  3443         BTFSC bufferINFO+5,7
3AA0 3203  3444         BRA   m015
           3445                         ;      {
           3446                         ;        TRISC.6 = 1;
3AA1 0021  3447         MOVLB 0x01
3AA2 170E  3448         BSF   TRISC,6
           3449                         ;        TRISB.4 = 1;
3AA3 160D  3450         BSF   TRISB,4
           3451                         ;      }
           3452                         ;      TRISA.5 = 1;
3AA4 0021  3453 m015    MOVLB 0x01
3AA5 168C  3454         BSF   TRISA,5
           3455                         ;
           3456                         ;      // C1 (AN0) as input 
           3457                         ;      TRISA.0 = 1;
3AA6 140C  3458         BSF   TRISA,0
           3459                         ;
           3460                         ;#ifdef DALLASnotMCP
           3461                         ;      // Setup DS18B20 for 9bit precision, conversion takes 94ms (see datasheet)
           3462                         ;      Ds18B20WriteConfig( 0b0.00.00000 );
3AA7 3000  3463         MOVLW 0x00
3AA8 246C  3464         CALL  Ds18B20WriteConfig
           3465                         ;#else
           3466                         ;      // Expect MCP9802 is enabled
           3467                         ;      i2c_init();
           3468                         ;#endif
           3469                         ;      break;
3AA9 32C9  3470         BRA   m043
           3471                         ;
           3472                         ;      // -------------------------------------------------
           3473                         ;    case DpaEvent_AfterSleep:
           3474                         ;      // Called after woken up after sleep
           3475                         ;#ifndef DALLASnotMCP
           3476                         ;      i2c_init();
           3477                         ;#endif
           3478                         ;
           3479                         ;      break;
           3480                         ;
           3481                         ;      // -------------------------------------------------
           3482                         ;    case DpaEvent_BeforeSleep:
           3483                         ;      // Called before going to sleep
           3484                         ;#ifndef DALLASnotMCP
           3485                         ;      i2c_shutdown();
           3486                         ;#endif
           3487                         ;      break;
           3488                         ;
           3489                         ;      // -------------------------------------------------
           3490                         ;    case DpaEvent_DpaRequest:
           3491                         ;      // Called to interpret DPA request for peripherals
           3492                         ;      // -------------------------------------------------
           3493                         ;      // Peripheral enumeration
           3494                         ;      IfDpaEnumPeripherals_Else_PeripheralInfo_Else_PeripheralRequest()
3AAA 0025  3495 m016    MOVLB 0x05
3AAB 08A1  3496         MOVF  DLEN,1
3AAC 1D03  3497         BTFSS 0x03,Zero_
3AAD 321D  3498         BRA   m019
3AAE 082F  3499         MOVF  PCMD,W
3AAF 3A3F  3500         XORLW 0x3F
3AB0 1D03  3501         BTFSS 0x03,Zero_
3AB1 3219  3502         BRA   m019
3AB2 0F2E  3503         INCFSZ PNUM,W
3AB3 320A  3504         BRA   m018
           3505                         ;      {
           3506                         ;        // We implement 2 standard peripherals
           3507                         ;        _DpaMessage.EnumPeripheralsAnswer.UserPerNr = 1;
3AB4 3001  3508         MOVLW 0x01
3AB5 0029  3509         MOVLB 0x09
3AB6 00A2  3510         MOVWF DpaRfMessage+2
           3511                         ;        FlagUserPer( _DpaMessage.EnumPeripheralsAnswer.UserPer, PNUM_STD_SENSORS );
3AB7 1733  3512         BSF   DpaRfMessage+19,6
           3513                         ;        _DpaMessage.EnumPeripheralsAnswer.HWPID = HWPID_IQRF_TECH__DEMO_DDC_SE01_LP;
3AB8 3002  3514         MOVLW 0x02
3AB9 00A7  3515         MOVWF DpaRfMessage+7
3ABA 304C  3516         MOVLW 0x4C
3ABB 00A8  3517         MOVWF DpaRfMessage+8
           3518                         ;        _DpaMessage.EnumPeripheralsAnswer.HWPIDver |= 0x0000;
           3519                         ;
           3520                         ;DpaHandleReturnTRUE:
           3521                         ;        return TRUE;
3ABC 1403  3522 m017    BSF   0x03,Carry
3ABD 0008  3523         RETURN
           3524                         ;      }
           3525                         ;      // -------------------------------------------------
           3526                         ;      // Get information about peripherals
           3527                         ;      else
           3528                         ;      {
           3529                         ;        switch ( _DpaMessage.PeripheralInfoAnswer.PerT = _PNUM )
3ABE 0025  3530 m018    MOVLB 0x05
3ABF 082E  3531         MOVF  PNUM,W
3AC0 0029  3532         MOVLB 0x09
3AC1 00A1  3533         MOVWF DpaRfMessage+1
3AC2 3A5E  3534         XORLW 0x5E
3AC3 1D03  3535         BTFSS 0x03,Zero_
3AC4 32AE  3536         BRA   m043
           3537                         ;        {
           3538                         ;          case PNUM_STD_SENSORS:
           3539                         ;            // Set standard version
           3540                         ;            _DpaMessage.PeripheralInfoAnswer.Par1 = 15;
3AC5 300F  3541         MOVLW 0x0F
3AC6 0029  3542         MOVLB 0x09
3AC7 00A2  3543         MOVWF DpaRfMessage+2
           3544                         ;            _DpaMessage.PeripheralInfoAnswer.PerTE = PERIPHERAL_TYPE_EXTENDED_READ_WRITE;
3AC8 3003  3545         MOVLW 0x03
3AC9 00A0  3546         MOVWF DpaRfMessage
           3547                         ;            goto DpaHandleReturnTRUE;
3ACA 33F1  3548         BRA   m017
           3549                         ;        }
           3550                         ;
           3551                         ;        break;
           3552                         ;      }
           3553                         ;
           3554                         ;      {
           3555                         ;        // -------------------------------------------------
           3556                         ;        // Handle peripheral command
           3557                         ;
           3558                         ;        // Supported peripheral number?
           3559                         ;        switch ( _PNUM )
3ACB 0025  3560 m019    MOVLB 0x05
3ACC 082E  3561         MOVF  PNUM,W
3ACD 3A5E  3562         XORLW 0x5E
3ACE 1D03  3563         BTFSS 0x03,Zero_
3ACF 32A3  3564         BRA   m043
           3565                         ;        {
           3566                         ;          case PNUM_STD_SENSORS:
           3567                         ;          {
           3568                         ;            // Supported commands?
           3569                         ;            switch ( _PCMD )
3AD0 0025  3570         MOVLB 0x05
3AD1 082F  3571         MOVF  PCMD,W
3AD2 3A3E  3572         XORLW 0x3E
3AD3 1903  3573         BTFSC 0x03,Zero_
3AD4 320A  3574         BRA   m022
3AD5 3A3E  3575         XORLW 0x3E
3AD6 1903  3576         BTFSC 0x03,Zero_
3AD7 3216  3577         BRA   m025
3AD8 3A01  3578         XORLW 0x01
3AD9 1903  3579         BTFSC 0x03,Zero_
3ADA 3213  3580         BRA   m025
           3581                         ;            {
           3582                         ;              // Invalid command
           3583                         ;              default:
           3584                         ;              {
           3585                         ;                // Return error
           3586                         ;_ERROR_PCMD:
           3587                         ;                W = ERROR_PCMD;
3ADB 3002  3588 m020    MOVLW 0x02
           3589                         ;_ERROR_W:
           3590                         ;                DpaApiReturnPeripheralError( W );
3ADC 00F3  3591 m021    MOVWF par1
3ADD 3005  3592         MOVLW 0x05
3ADE 3329  3593         BRA   DpaApiEntry
           3594                         ;              }
           3595                         ;
           3596                         ;              // Sensor enumeration
           3597                         ;              case PCMD_STD_ENUMERATE:
           3598                         ;                if ( _DpaDataLength != 0 )
3ADF 0025  3599 m022    MOVLB 0x05
3AE0 08A1  3600         MOVF  DLEN,1
3AE1 1903  3601         BTFSC 0x03,Zero_
3AE2 3202  3602         BRA   m024
           3603                         ;                {
           3604                         ;_ERROR_DATA_LEN:
           3605                         ;                  W = ERROR_DATA_LEN;
3AE3 3005  3606 m023    MOVLW 0x05
           3607                         ;                  goto _ERROR_W;
3AE4 33F7  3608         BRA   m021
           3609                         ;                }
           3610                         ;
           3611                         ;                _DpaMessage.Response.PData[0] = STD_SENSOR_TYPE_TEMPERATURE;
3AE5 3001  3612 m024    MOVLW 0x01
3AE6 0029  3613         MOVLB 0x09
3AE7 00A0  3614         MOVWF DpaRfMessage
           3615                         ;                _DpaMessage.Response.PData[1] = STD_SENSOR_TYPE_BINARYDATA7;
3AE8 3081  3616         MOVLW 0x81
3AE9 00A1  3617         MOVWF DpaRfMessage+1
           3618                         ;                _DpaMessage.Response.PData[2] = STD_SENSOR_TYPE_BINARYDATA7;
3AEA 3081  3619         MOVLW 0x81
3AEB 00A2  3620         MOVWF DpaRfMessage+2
           3621                         ;                W = SENSORS_COUNT;
3AEC 3003  3622         MOVLW 0x03
           3623                         ;                goto _W2_DpaDataLength;
3AED 3227  3624         BRA   m030
           3625                         ;
           3626                         ;                // Supported commands. They are handled the same way except one "if" at StoreValue() method
           3627                         ;              case PCMD_STD_SENSORS_READ_VALUES:
           3628                         ;              case PCMD_STD_SENSORS_READ_TYPES_AND_VALUES:
           3629                         ;              {
           3630                         ;                // No sensor bitmap specified? W = _DpaDataLength. Note: W is used to avoid MOVLB at next if
           3631                         ;                W = _DpaDataLength;
3AEE 0025  3632 m025    MOVLB 0x05
3AEF 0821  3633         MOVF  DLEN,W
           3634                         ;                if ( W == 0 )	// Note: must not modify W
3AF0 1D03  3635         BTFSS 0x03,Zero_
3AF1 3206  3636         BRA   m026
           3637                         ;                {
           3638                         ;                  // Actually clears the bitmap
           3639                         ;#if &_DpaMessageIqrfStd.PerStdSensorRead_Request.Bitmap[0] != &bufferRF[0]
           3640                         ;#error Cannot use clearBufferRF for clearing bitmap
           3641                         ;#endif
           3642                         ;                  clearBufferRF();
3AF2 20FA  3643         CALL  clearBufferRF
           3644                         ;                  // Simulate 1st only sensor in the bitmap (states of the other unimplemented sensors do not care)
           3645                         ;                  _DpaMessageIqrfStd.PerStdSensorRead_Request.Bitmap[0].0 = 1;
3AF3 0029  3646         MOVLB 0x09
3AF4 1420  3647         BSF   _DpaMessageIqrfStd,0
           3648                         ;                  // Bitmap is 32 bits long
           3649                         ;                  _DpaDataLength = W = sizeof( _DpaMessageIqrfStd.PerStdSensorRead_Request.Bitmap );
3AF5 3004  3650         MOVLW 0x04
3AF6 0025  3651         MOVLB 0x05
3AF7 00A1  3652         MOVWF DLEN
           3653                         ;                }
           3654                         ;
           3655                         ;                // Invalid bitmap (data) length (W = _DpaDataLength)?
           3656                         ;                if ( W != sizeof( _DpaMessageIqrfStd.PerStdSensorRead_Request.Bitmap ) )
3AF8 3A04  3657 m026    XORLW 0x04
3AF9 1D03  3658         BTFSS 0x03,Zero_
           3659                         ;                  goto _ERROR_DATA_LEN;
3AFA 33E8  3660         BRA   m023
           3661                         ;
           3662                         ;                // Now read the sensors
           3663                         ;
           3664                         ;                // Prepare pointer (minus 1, see below) to store sensor (types and) values to
           3665                         ;                // Note: 3 sensors at this example cannot return more than DPA_MAX_DATA_LENGTH bytes of data, so it does not have to be checked...
           3666                         ;                // ... If it would be the case, then ERROR_FAIL must be returned
           3667                         ;                FSR1 = &_DpaMessage.Response.PData[-1];
3AFB 309F  3668         MOVLW 0x9F
3AFC 0086  3669         MOVWF FSR1
3AFD 3004  3670         MOVLW 0x04
3AFE 0087  3671         MOVWF FSR1+1
           3672                         ;
           3673                         ;                // Store bitmap of sensors to get values from
           3674                         ;                uns8 sensorsBitmap = FSR1[1 + offsetof( TPerStdSensorRead_Request, Bitmap )];
3AFF 3F41  3675         MOVIW 1[INDF1]
3B00 002B  3676         MOVLB 0x0B
3B01 00C0  3677         MOVWF sensorsBitmap
           3678                         ;
           3679                         ;                // 1st sensor (index 0) selected?
           3680                         ;                if ( sensorsBitmap.0 )
3B02 1C40  3681         BTFSS sensorsBitmap,0
3B03 3203  3682         BRA   m027
           3683                         ;                {
           3684                         ;                  Get0_Temperature();
3B04 23CF  3685         CALL  Get0_Temperature
           3686                         ;                  StoreValue( STD_SENSOR_TYPE_TEMPERATURE );
3B05 3001  3687         MOVLW 0x01
3B06 237B  3688         CALL  StoreValue
           3689                         ;                }
           3690                         ;
           3691                         ;                // 2nd sensor (index 1) selected?
           3692                         ;                if ( sensorsBitmap.1 )
3B07 002B  3693 m027    MOVLB 0x0B
3B08 1CC0  3694         BTFSS sensorsBitmap,1
3B09 3203  3695         BRA   m028
           3696                         ;                {
           3697                         ;                  Get1_BinaryData_Light();
3B0A 240B  3698         CALL  Get1_BinaryData_Light
           3699                         ;                  StoreValue( STD_SENSOR_TYPE_BINARYDATA7 );
3B0B 3081  3700         MOVLW 0x81
3B0C 237B  3701         CALL  StoreValue
           3702                         ;                }
           3703                         ;
           3704                         ;                // 3rd sensor (index 2) selected?
           3705                         ;                if ( sensorsBitmap.2 )
3B0D 002B  3706 m028    MOVLB 0x0B
3B0E 1D40  3707         BTFSS sensorsBitmap,2
3B0F 3203  3708         BRA   m029
           3709                         ;                {
           3710                         ;                  Get2_BinaryData_Potentiometer();
3B10 240F  3711         CALL  Get2_BinaryData_Potentiometer
           3712                         ;                  StoreValue( STD_SENSOR_TYPE_BINARYDATA7 );
3B11 3081  3713         MOVLW 0x81
3B12 237B  3714         CALL  StoreValue
           3715                         ;                }
           3716                         ;
           3717                         ;                // Compute returned data bytes count
           3718                         ;                W = FSR1L - ( (uns16)&_DpaMessageIqrfStd & 0xFF ) + 1;
3B13 309F  3719 m029    MOVLW 0x9F
3B14 0206  3720         SUBWF FSR1L,W
           3721                         ;                // Optimization: return W long block of bytes at response
           3722                         ;_W2_DpaDataLength:
           3723                         ;                _DpaDataLength = W;
3B15 0025  3724 m030    MOVLB 0x05
3B16 00A1  3725         MOVWF DLEN
           3726                         ;                goto DpaHandleReturnTRUE;
3B17 33A4  3727         BRA   m017
           3728                         ;              }
           3729                         ;            }
           3730                         ;          }
           3731                         ;        }
           3732                         ;
           3733                         ;        break;
           3734                         ;      }
           3735                         ;
           3736                         ;      // -------------------------------------------------
           3737                         ;    case DpaEvent_FrcValue:
           3738                         ;      // Called to get FRC value
           3739                         ;
           3740                         ;      // FSR1 for optimization purposes (avoid MOVLB) will be used to point to DataOutBeforeResponseFRC[0...]
           3741                         ;      FSR1 = (uns16)&PerStdSensorFrc;
3B18 30C0  3742 m031    MOVLW 0xC0
3B19 0086  3743         MOVWF FSR1
3B1A 3004  3744         MOVLW 0x04
3B1B 0087  3745         MOVWF FSR1+1
           3746                         ;#if offsetof( TPerStdSensorFrc, Header ) != 0 || offsetof( TPerStdSensorFrc, SensorType ) != 1 || offsetof( TPerStdSensorFrc, Options ) != 3
           3747                         ;#error Cannot optimize
           3748                         ;#endif
           3749                         ;      // Check for correct FRC user data
           3750                         ;      if ( *FSR1++ /* PerStdSensorFrc.Header */ == PNUM_STD_SENSORS )
3B1C 0016  3751         MOVIW INDF1++
3B1D 3A5E  3752         XORLW 0x5E
3B1E 1D03  3753         BTFSS 0x03,Zero_
3B1F 3253  3754         BRA   m043
           3755                         ;      {
           3756                         ;        // Actually used sensor index
           3757                         ;        uns8 sensorIndex = FSR1[offsetof( TPerStdSensorFrc, SensorIndex ) - 1] & 0x1f;
3B20 3F41  3758         MOVIW 1[INDF1]
3B21 391F  3759         ANDLW 0x1F
3B22 002B  3760         MOVLB 0x0B
3B23 00C0  3761         MOVWF sensorIndex
           3762                         ;        // Test sensor type
           3763                         ;        switch ( *FSR1++ /* PerStdSensorFrc.SensorType */ )
3B24 0016  3764         MOVIW INDF1++
3B25 1903  3765         BTFSC 0x03,Zero_
3B26 3217  3766         BRA   m035
3B27 3A01  3767         XORLW 0x01
3B28 1903  3768         BTFSC 0x03,Zero_
3B29 3204  3769         BRA   m032
3B2A 3A80  3770         XORLW 0x80
3B2B 1903  3771         BTFSC 0x03,Zero_
3B2C 3208  3772         BRA   m033
3B2D 3245  3773         BRA   m043
           3774                         ;        {
           3775                         ;          default:
           3776                         ;            goto DpaHandleReturnFALSE;
           3777                         ;
           3778                         ;            // No type specified, use specified index value
           3779                         ;          case 0x00:
           3780                         ;            goto _KeepSensorIndex;
           3781                         ;
           3782                         ;            // For other types make the index value based on the requested index value and sensor type
           3783                         ;          case STD_SENSOR_TYPE_TEMPERATURE:
           3784                         ;            if ( sensorIndex > 0 )
3B2E 002B  3785 m032    MOVLB 0x0B
3B2F 08C0  3786         MOVF  sensorIndex,1
3B30 1D03  3787         BTFSS 0x03,Zero_
           3788                         ;              goto DpaHandleReturnFALSE;
3B31 3241  3789         BRA   m043
           3790                         ;            W = 0 + sensorIndex;
3B32 002B  3791         MOVLB 0x0B
3B33 0840  3792         MOVF  sensorIndex,W
           3793                         ;            break;
3B34 3207  3794         BRA   m034
           3795                         ;
           3796                         ;          case STD_SENSOR_TYPE_BINARYDATA7:
           3797                         ;            if ( sensorIndex > 1 )
3B35 3002  3798 m033    MOVLW 0x02
3B36 002B  3799         MOVLB 0x0B
3B37 0240  3800         SUBWF sensorIndex,W
3B38 1803  3801         BTFSC 0x03,Carry
           3802                         ;              goto DpaHandleReturnFALSE;
3B39 3239  3803         BRA   m043
           3804                         ;            W = 1 + sensorIndex;
3B3A 002B  3805         MOVLB 0x0B
3B3B 0A40  3806         INCF  sensorIndex,W
           3807                         ;            break;
           3808                         ;        }
           3809                         ;
           3810                         ;        // New sensor index based on type and requested index
           3811                         ;        sensorIndex = W;
3B3C 002B  3812 m034    MOVLB 0x0B
3B3D 00C0  3813         MOVWF sensorIndex
           3814                         ;_KeepSensorIndex:
           3815                         ;
           3816                         ;        // Test for supported FRC commands
           3817                         ;        switch ( _PCMD )
3B3E 0025  3818 m035    MOVLB 0x05
3B3F 082F  3819         MOVF  PCMD,W
3B40 3A10  3820         XORLW 0x10
3B41 1903  3821         BTFSC 0x03,Zero_
3B42 3206  3822         BRA   m036
3B43 3A80  3823         XORLW 0x80
3B44 1903  3824         BTFSC 0x03,Zero_
3B45 3203  3825         BRA   m036
3B46 3A70  3826         XORLW 0x70
3B47 1D03  3827         BTFSS 0x03,Zero_
3B48 322A  3828         BRA   m043
           3829                         ;        {
           3830                         ;          default:
           3831                         ;            goto DpaHandleReturnFALSE;
           3832                         ;
           3833                         ;          case FRC_STD_SENSORS_BIT:
           3834                         ;          case FRC_STD_SENSORS_1B:
           3835                         ;          case FRC_STD_SENSORS_2B:
           3836                         ;            switch ( sensorIndex )
3B49 002B  3837 m036    MOVLB 0x0B
3B4A 0840  3838         MOVF  sensorIndex,W
3B4B 1903  3839         BTFSC 0x03,Zero_
3B4C 3207  3840         BRA   m037
3B4D 3A01  3841         XORLW 0x01
3B4E 1903  3842         BTFSC 0x03,Zero_
3B4F 3206  3843         BRA   m038
3B50 3A03  3844         XORLW 0x03
3B51 1903  3845         BTFSC 0x03,Zero_
3B52 3205  3846         BRA   m039
3B53 321F  3847         BRA   m043
           3848                         ;            {
           3849                         ;              default:
           3850                         ;                goto DpaHandleReturnFALSE;
           3851                         ;
           3852                         ;              case 0:
           3853                         ;                Carry = Get0_Temperature();
3B54 23CF  3854 m037    CALL  Get0_Temperature
           3855                         ;                break;
3B55 3203  3856         BRA   m040
           3857                         ;
           3858                         ;              case 1:
           3859                         ;                Carry = Get1_BinaryData_Light();
3B56 240B  3860 m038    CALL  Get1_BinaryData_Light
           3861                         ;                break;
3B57 3201  3862         BRA   m040
           3863                         ;
           3864                         ;              case 2:
           3865                         ;                Carry = Get2_BinaryData_Potentiometer();
3B58 240F  3866 m039    CALL  Get2_BinaryData_Potentiometer
           3867                         ;                break;
           3868                         ;            }
           3869                         ;
           3870                         ;            // This type of FRC is not valid for the specified sensor
           3871                         ;            if ( !Carry )
3B59 1C03  3872 m040    BTFSS 0x03,Carry
           3873                         ;              goto DpaHandleReturnFALSE;
3B5A 3218  3874         BRA   m043
           3875                         ;
           3876                         ;            break;
           3877                         ;        }
           3878                         ;
           3879                         ;        // Some sensor was measured by FRC, check if there is a sleep request
           3880                         ;        FSR1++;
3B5B 3141  3881         ADDFSR INDF1,1
           3882                         ;        if ( INDF1.0 ) // Note: same as PerStdSensorFrc.Options.0
3B5C 1C01  3883         BTFSS INDF1,0
3B5D 3215  3884         BRA   m043
           3885                         ;        {
           3886                         ;          // Remember sleep parameters to go to sleep at the Idle event later
           3887                         ;          PerOSSleep_Request.Time.low8 = FSR1[offsetof( TPerOSSleep_Request, Time ) + 0 + offsetof( TPerStdSensorFrc, SleepParameters ) - 3];
3B5E 3F41  3888         MOVIW 1[INDF1]
3B5F 002B  3889         MOVLB 0x0B
3B60 00C7  3890         MOVWF PerOSSleep_Request
           3891                         ;          PerOSSleep_Request.Time.high8 = FSR1[offsetof( TPerOSSleep_Request, Time ) + 1 + offsetof( TPerStdSensorFrc, SleepParameters ) - 3];
3B61 3F42  3892         MOVIW 2[INDF1]
3B62 00C8  3893         MOVWF PerOSSleep_Request+1
           3894                         ;          PerOSSleep_Request.Control = FSR1[offsetof( TPerOSSleep_Request, Control ) + offsetof( TPerStdSensorFrc, SleepParameters ) - 3];
3B63 3F43  3895         MOVIW 3[INDF1]
3B64 00C9  3896         MOVWF PerOSSleep_Request+2
           3897                         ;        }
           3898                         ;      }
           3899                         ;
           3900                         ;      break;
3B65 320D  3901         BRA   m043
           3902                         ;
           3903                         ;      // -------------------------------------------------
           3904                         ;    case DpaEvent_FrcResponseTime:
           3905                         ;      // Called to get FRC response time
           3906                         ;
           3907                         ;      // In this example the FRC commands are fast 
           3908                         ;      switch ( DataOutBeforeResponseFRC[0] )
3B66 0029  3909 m041    MOVLB 0x09
3B67 0840  3910         MOVF  DataOutBeforeResponseFRC,W
3B68 3A10  3911         XORLW 0x10
3B69 1903  3912         BTFSC 0x03,Zero_
3B6A 3206  3913         BRA   m042
3B6B 3A80  3914         XORLW 0x80
3B6C 1903  3915         BTFSC 0x03,Zero_
3B6D 3203  3916         BRA   m042
3B6E 3A70  3917         XORLW 0x70
3B6F 1D03  3918         BTFSS 0x03,Zero_
3B70 3202  3919         BRA   m043
           3920                         ;      {
           3921                         ;        case FRC_STD_SENSORS_BIT:
           3922                         ;        case FRC_STD_SENSORS_1B:
           3923                         ;        case FRC_STD_SENSORS_2B:
           3924                         ;          responseFRCvalue = _FRC_RESPONSE_TIME_40_MS;
3B71 002B  3925 m042    MOVLB 0x0B
3B72 01BC  3926         CLRF  responseFRCvalue
           3927                         ;          break;
           3928                         ;      }
           3929                         ;      break;
           3930                         ;  }
           3931                         ;DpaHandleReturnFALSE:
           3932                         ;  return FALSE;
3B73 1003  3933 m043    BCF   0x03,Carry
3B74 0008  3934         RETURN
           3935                         ;}
           3936                         ;
           3937                         ;//############################################################################################
           3938                         ;bit returnTRUE()
           3939                         ;//############################################################################################
           3940                         ;{
           3941 returnTRUE
           3942                         ;  return TRUE;
3B75 1403  3943         BSF   0x03,Carry
3B76 0008  3944         RETURN
           3945                         ;}
           3946                         ;
           3947                         ;//############################################################################################
           3948                         ;bit returnFALSE()
           3949                         ;//############################################################################################
           3950                         ;{
           3951 returnFALSE
           3952                         ;  return FALSE;
3B77 1003  3953         BCF   0x03,Carry
3B78 0008  3954         RETURN
           3955                         ;}
           3956                         ;
           3957                         ;//############################################################################################
           3958                         ;// Increases FSR1 and then stores the byte
           3959                         ;void setPlusPlusINDF1( uns8 data @ W )
           3960                         ;//############################################################################################
           3961                         ;{
           3962 setPlusPlusINDF1
           3963                         ;  FSR1++; // Note: must not modify W
3B79 3141  3964         ADDFSR INDF1,1
           3965                         ;  setINDF1( data );
3B7A 2934  3966         GOTO  setINDF1
           3967                         ;}
           3968                         ;
           3969                         ;//############################################################################################
           3970                         ;// Stores measured sensor value byte(s) and optionally sensor type to the FSR[+1...]
           3971                         ;void StoreValue( uns8 sensorType )
           3972                         ;//############################################################################################
           3973                         ;{
           3974 StoreValue
3B7B 002B  3975         MOVLB 0x0B
3B7C 00C1  3976         MOVWF sensorType
           3977                         ;  // Is the sensor type to be stored too?
           3978                         ;  if ( _PCMD == PCMD_STD_SENSORS_READ_TYPES_AND_VALUES )
3B7D 0025  3979         MOVLB 0x05
3B7E 0B2F  3980         DECFSZ PCMD,W
3B7F 3203  3981         BRA   m044
           3982                         ;    setPlusPlusINDF1( sensorType );
3B80 002B  3983         MOVLB 0x0B
3B81 0841  3984         MOVF  sensorType,W
3B82 2379  3985         CALL  setPlusPlusINDF1
           3986                         ;
           3987                         ;  // Store lower value byte
           3988                         ;  setPlusPlusINDF1( sensorValue.low8 );
3B83 0874  3989 m044    MOVF  sensorValue,W
3B84 2379  3990         CALL  setPlusPlusINDF1
           3991                         ;
           3992                         ;  // No more value bytes to store?
           3993                         ;  if ( sensorType.7 != 0 )
3B85 002B  3994         MOVLB 0x0B
3B86 1BC1  3995         BTFSC sensorType,7
           3996                         ;    return;
3B87 0008  3997         RETURN
           3998                         ;
           3999                         ;  // Store higher value byte
           4000                         ;  setPlusPlusINDF1( sensorValue.high8 );
3B88 0875  4001         MOVF  sensorValue+1,W
3B89 33EF  4002         BRA   setPlusPlusINDF1
           4003                         ;
           4004                         ;  // Note: this example implements sensors returning only 1 or 2 bytes of data. If another data widths are returned, then it must be implemented explicitly.
           4005                         ;}
           4006                         ;
           4007                         ;//############################################################################################
           4008                         ;bit setFRCerror()
           4009                         ;//############################################################################################
           4010                         ;{
           4011 setFRCerror
           4012                         ;  responseFRCvalue2B = 2;
3B8A 3002  4013         MOVLW 0x02
3B8B 002B  4014         MOVLB 0x0B
3B8C 00BC  4015         MOVWF responseFRCvalue2B
3B8D 01BD  4016         CLRF  responseFRCvalue2B+1
           4017                         ;  return returnTRUE();
3B8E 33E6  4018         BRA   returnTRUE
           4019                         ;}
           4020                         ;
           4021                         ;//############################################################################################
           4022                         ;bit sensorError;
           4023                         ;bit AdjustFrcTemperature()
           4024                         ;//############################################################################################
           4025                         ;{
           4026 AdjustFrcTemperature
           4027                         ;  // Test for supported FRC commands
           4028                         ;  switch ( _PCMD )
3B8F 0025  4029         MOVLB 0x05
3B90 082F  4030         MOVF  PCMD,W
3B91 3A90  4031         XORLW 0x90
3B92 1903  4032         BTFSC 0x03,Zero_
3B93 3204  4033         BRA   m045
3B94 3A70  4034         XORLW 0x70
3B95 1903  4035         BTFSC 0x03,Zero_
3B96 322E  4036         BRA   m048
3B97 33DF  4037         BRA   returnFALSE
           4038                         ;  {
           4039                         ;    default:
           4040                         ;      return returnFALSE();
           4041                         ;
           4042                         ;    case FRC_STD_SENSORS_1B:
           4043                         ;      // Return sensor FRC value 1B
           4044                         ;      // Check for out of limits
           4045                         ;      if ( sensorError || (int16)sensorValue > (int16)( 105.5 * 16 ) || (int16)sensorValue < ( (int16)-20 * 16 ) )
3B98 002B  4046 m045    MOVLB 0x0B
3B99 184E  4047         BTFSC 0x5CE,sensorError
3B9A 33EF  4048         BRA   setFRCerror
3B9B 1BF5  4049         BTFSC sensorValue+1,7
3B9C 320A  4050         BRA   m046
3B9D 3006  4051         MOVLW 0x06
3B9E 0275  4052         SUBWF sensorValue+1,W
3B9F 1C03  4053         BTFSS 0x03,Carry
3BA0 3206  4054         BRA   m046
3BA1 1D03  4055         BTFSS 0x03,Zero_
3BA2 33E7  4056         BRA   setFRCerror
3BA3 3099  4057         MOVLW 0x99
3BA4 0274  4058         SUBWF sensorValue,W
3BA5 1803  4059         BTFSC 0x03,Carry
3BA6 33E3  4060         BRA   setFRCerror
3BA7 1FF5  4061 m046    BTFSS sensorValue+1,7
3BA8 320A  4062         BRA   m047
3BA9 30FE  4063         MOVLW 0xFE
3BAA 0275  4064         SUBWF sensorValue+1,W
3BAB 1C03  4065         BTFSS 0x03,Carry
3BAC 33DD  4066         BRA   setFRCerror
3BAD 1D03  4067         BTFSS 0x03,Zero_
3BAE 3204  4068         BRA   m047
3BAF 30C0  4069         MOVLW 0xC0
3BB0 0274  4070         SUBWF sensorValue,W
3BB1 1C03  4071         BTFSS 0x03,Carry
           4072                         ;        return setFRCerror();
3BB2 33D7  4073         BRA   setFRCerror
           4074                         ;
           4075                         ;      // Convert to the "F = ( T + 22 ) * 2 " from 1/16 resolution
           4076                         ;      uns16 _sensorValue = sensorValue + 4;	// Note: do rounding when /8
3BB3 0875  4077 m047    MOVF  sensorValue+1,W
3BB4 002B  4078         MOVLB 0x0B
3BB5 00C2  4079         MOVWF _sensorValue+1
3BB6 3004  4080         MOVLW 0x04
3BB7 0774  4081         ADDWF sensorValue,W
3BB8 00C1  4082         MOVWF _sensorValue
3BB9 1803  4083         BTFSC 0x03,Carry
3BBA 0AC2  4084         INCF  _sensorValue+1,1
           4085                         ;      responseFRCvalue = (uns8)( _sensorValue / 8 ) + 44;
3BBB 0C42  4086         RRF   _sensorValue+1,W
3BBC 00C3  4087         MOVWF C1cnt
3BBD 0C41  4088         RRF   _sensorValue,W
3BBE 0CC3  4089         RRF   C1cnt,1
3BBF 0C89  4090         RRF   WREG,1
3BC0 0CC3  4091         RRF   C1cnt,1
3BC1 0C89  4092         RRF   WREG,1
3BC2 3E2C  4093         ADDLW 0x2C
3BC3 00BC  4094         MOVWF responseFRCvalue
           4095                         ;      break;
3BC4 33B0  4096         BRA   returnTRUE
           4097                         ;
           4098                         ;    case FRC_STD_SENSORS_2B:
           4099                         ;      // Return sensor FRC value 2B
           4100                         ;      if ( sensorError )
3BC5 002B  4101 m048    MOVLB 0x0B
3BC6 184E  4102         BTFSC 0x5CE,sensorError
           4103                         ;        return setFRCerror();
3BC7 33C2  4104         BRA   setFRCerror
           4105                         ;
           4106                         ;      responseFRCvalue2B = sensorValue ^ 0x8000;
3BC8 3080  4107         MOVLW 0x80
3BC9 0675  4108         XORWF sensorValue+1,W
3BCA 002B  4109         MOVLB 0x0B
3BCB 00BD  4110         MOVWF responseFRCvalue2B+1
3BCC 0874  4111         MOVF  sensorValue,W
3BCD 00BC  4112         MOVWF responseFRCvalue2B
           4113                         ;      break;
3BCE 33A6  4114         BRA   returnTRUE
           4115                         ;  }
           4116                         ;
           4117                         ;  return returnTRUE();
           4118                         ;}
           4119                         ;
           4120                         ;//############################################################################################
           4121                         ;// Sensor index 1: measure temperature using one of the DDC-SE-01 sensors
           4122                         ;bit Get0_Temperature()
           4123                         ;//############################################################################################
           4124                         ;{
           4125 Get0_Temperature
           4126                         ;  // Make sure FSR1 is not modified
           4127                         ;
           4128                         ;  // Measure temperature using DDC-SE-01 sensors
           4129                         ;  // Read temperature and check for an error
           4130                         ;
           4131                         ;  // Reads temperature from an enabled sensor
           4132                         ;#ifdef DALLASnotMCP
           4133                         ;  sensorError = FALSE;
3BCF 002B  4134         MOVLB 0x0B
3BD0 104E  4135         BCF   0x5CE,sensorError
           4136                         ;  // Temperature is ready at the background
           4137                         ;  sensorValue = temperature;
3BD1 0845  4138         MOVF  temperature,W
3BD2 00F4  4139         MOVWF sensorValue
3BD3 0846  4140         MOVF  temperature+1,W
3BD4 00F5  4141         MOVWF sensorValue+1
           4142                         ;  // When error, return standard (FRC) error value(s)
           4143                         ;  if ( STD_SENSOR_TYPE_TEMPERATURE_IS_ERROR( sensorValue ) )
3BD5 08F4  4144         MOVF  sensorValue,1
3BD6 1D03  4145         BTFSS 0x03,Zero_
3BD7 33B7  4146         BRA   AdjustFrcTemperature
3BD8 0875  4147         MOVF  sensorValue+1,W
3BD9 3A80  4148         XORLW 0x80
3BDA 1D03  4149         BTFSS 0x03,Zero_
3BDB 33B3  4150         BRA   AdjustFrcTemperature
           4151                         ;    sensorError = TRUE;
3BDC 144E  4152         BSF   0x5CE,sensorError
           4153                         ;#else
           4154                         ;  sensorError = TRUE;
           4155                         ;  // Temperature value must be read from I2C sensor
           4156                         ;  STD_SENSOR_TYPE_TEMPERATURE_SET_ERROR( sensorValue );
           4157                         ;  // MCP9802 address
           4158                         ;  i2c_start( I2C_ADR );
           4159                         ;  if ( !i2cTimeout )
           4160                         ;  {
           4161                         ;    // pointer: 1 = configuration register
           4162                         ;    i2c_write( 0x01 );
           4163                         ;    // configuration: 9-bit ADC
           4164                         ;    i2c_write( 0x00 );
           4165                         ;    i2c_stop();
           4166                         ;
           4167                         ;    // MCP9802 address
           4168                         ;    i2c_start( I2C_ADR );
           4169                         ;    // pointer: 0 = temperature
           4170                         ;    i2c_write( 0 );
           4171                         ;    i2c_stop();
           4172                         ;
           4173                         ;    // MCP9802 address + read
           4174                         ;    i2c_start( I2C_ADR | 1 );
           4175                         ;    // store the result
           4176                         ;    sensorValue.high8 = i2c_read( TRUE );
           4177                         ;    sensorValue.low8 = i2c_read( FALSE );
           4178                         ;    i2c_stop();
           4179                         ;
           4180                         ;    sensorValue += 0x10 / 2;
           4181                         ;    sensorValue /= 0x10;
           4182                         ;
           4183                         ;    sensorError = FALSE;
           4184                         ;  }
           4185                         ;#endif
           4186                         ;
           4187                         ;  // FrcValues
           4188                         ;  return AdjustFrcTemperature();
3BDD 33B1  4189         BRA   AdjustFrcTemperature
           4190                         ;}
           4191                         ;
           4192                         ;//############################################################################################
           4193                         ;// Sensor index 1: returns light intensity indicator value using DDC-SE-01
           4194                         ;bit Get_BinaryData_Final( uns8 _ADCON0 @ W )
           4195                         ;//############################################################################################
           4196                         ;{
           4197 Get_BinaryData_Final
           4198                         ;  ADCON0 = _ADCON0;
3BDE 0021  4199         MOVLB 0x01
3BDF 009D  4200         MOVWF ADCON0
           4201                         ;  // Read ADC
           4202                         ;
           4203                         ;  // ADC result - left justified, Fosc/8
           4204                         ;  ADCON1 = 0b0001.0000;
3BE0 3010  4205         MOVLW 0x10
3BE1 009E  4206         MOVWF ADCON1
           4207                         ;  // Do a smallest delay for ADC ACQUISITION TIME
           4208                         ;  waitMS( 1 );
3BE2 3001  4209         MOVLW 0x01
3BE3 2076  4210         CALL  waitMS
           4211                         ;  // start ADC
           4212                         ;  GO = 1;
3BE4 0021  4213         MOVLB 0x01
3BE5 149D  4214         BSF   0x9D,GO
           4215                         ;  // wait for ADC finish
           4216                         ;  while ( GO );
3BE6 0021  4217 m049    MOVLB 0x01
3BE7 189D  4218         BTFSC 0x9D,GO
3BE8 33FD  4219         BRA   m049
           4220                         ;  // Get ADC value
           4221                         ;  sensorValue.low8 = ADRESH / 2;
3BE9 1003  4222         BCF   0x03,Carry
3BEA 0021  4223         MOVLB 0x01
3BEB 0C1C  4224         RRF   ADRESH,W
3BEC 00F4  4225         MOVWF sensorValue
           4226                         ;
           4227                         ;  // Return sensor FRC value
           4228                         ;
           4229                         ;  // Test for supported FRC commands
           4230                         ;  switch ( _PCMD )
3BED 0025  4231         MOVLB 0x05
3BEE 082F  4232         MOVF  PCMD,W
3BEF 3A10  4233         XORLW 0x10
3BF0 1903  4234         BTFSC 0x03,Zero_
3BF1 3204  4235         BRA   m050
3BF2 3A80  4236         XORLW 0x80
3BF3 1903  4237         BTFSC 0x03,Zero_
3BF4 3211  4238         BRA   m052
3BF5 3381  4239         BRA   returnFALSE
           4240                         ;  {
           4241                         ;    default:
           4242                         ;      return returnFALSE();
           4243                         ;
           4244                         ;    case FRC_STD_SENSORS_BIT:
           4245                         ;      // If there is a sensor error, 2-bit FRC cannot indicate it, it returns [01]
           4246                         ;
           4247                         ;      // Number of shifts to get the bit out of the return value
           4248                         ;      uns8 bitLoop = ( INDF1 >> 5 ) + 1;
3BF6 0E01  4249 m050    SWAPF INDF1,W
3BF7 390F  4250         ANDLW 0x0F
3BF8 3609  4251         LSRF  WREG,W
3BF9 3E01  4252         ADDLW 0x01
3BFA 002B  4253         MOVLB 0x0B
3BFB 00C1  4254         MOVWF bitLoop
           4255                         ;      // Value to get the bit from
           4256                         ;      W = sensorValue.low8;
3BFC 0874  4257         MOVF  sensorValue,W
           4258                         ;      do
           4259                         ;      {
           4260                         ;        // Get the bit to Carry
           4261                         ;        W = rr( W );
3BFD 0C89  4262 m051    RRF   WREG,1
           4263                         ;        // Next bit
           4264                         ;      } while ( --bitLoop != 0 ); // Note: must not modify W and Carry
3BFE 002B  4265         MOVLB 0x0B
3BFF 0BC1  4266         DECFSZ bitLoop,1
3C00 33FC  4267         BRA   m051
           4268                         ;      // Current (prepared by DPA) FRC value is [01], change it to [11] (means bit is set)
           4269                         ;      responseFRCvalue.1 = 1; // Note: must not modify Carry
3C01 14BC  4270         BSF   responseFRCvalue,1
           4271                         ;      // Is bit set?
           4272                         ;      if ( !Carry )
3C02 1803  4273         BTFSC 0x03,Carry
3C03 3371  4274         BRA   returnTRUE
           4275                         ;        // Bit is NOT set, return [10]
           4276                         ;        responseFRCvalue.0 = 0;
3C04 103C  4277         BCF   responseFRCvalue,0
           4278                         ;      break;
3C05 336F  4279         BRA   returnTRUE
           4280                         ;
           4281                         ;    case FRC_STD_SENSORS_1B:
           4282                         ;      responseFRCvalue = sensorValue.low8 + 4;
3C06 3004  4283 m052    MOVLW 0x04
3C07 0774  4284         ADDWF sensorValue,W
3C08 002B  4285         MOVLB 0x0B
3C09 00BC  4286         MOVWF responseFRCvalue
           4287                         ;      break;
3C0A 336A  4288         BRA   returnTRUE
           4289                         ;  }
           4290                         ;
           4291                         ;  return returnTRUE();
           4292                         ;}
           4293                         ;
           4294                         ;//############################################################################################
           4295                         ;// Sensor index 1: returns light intensity indicator value using DDC-SE-01
           4296                         ;bit Get1_BinaryData_Light()
           4297                         ;//############################################################################################
           4298                         ;{
           4299 Get1_BinaryData_Light
           4300                         ;  // Make sure FSR1 is not modified
           4301                         ;
           4302                         ;  // ADC initialization (for more info see PIC datasheet) pin C1 (AN0) as analog input 
           4303                         ;  ANSELA.0 = 1;
3C0B 0023  4304         MOVLB 0x03
3C0C 140C  4305         BSF   ANSELA,0
           4306                         ;  // ADC setting (AN0 channel)
           4307                         ;  return Get_BinaryData_Final( 0b0.00000.01 );
3C0D 3001  4308         MOVLW 0x01
3C0E 33CF  4309         BRA   Get_BinaryData_Final
           4310                         ;}
           4311                         ;
           4312                         ;//############################################################################################
           4313                         ;// Sensor index 2: returns potentiometer value using DDC-SE-01
           4314                         ;bit Get2_BinaryData_Potentiometer()
           4315                         ;//############################################################################################
           4316                         ;{
           4317 Get2_BinaryData_Potentiometer
           4318                         ;  // Make sure FSR1 is not modified
           4319                         ;
           4320                         ;  // ADC initialization (for more info see PIC datasheet) pin C5 (AN4) as analog input 
           4321                         ;  ANSELA.5 = 1;
3C0F 0023  4322         MOVLB 0x03
3C10 168C  4323         BSF   ANSELA,5
           4324                         ;  // ADC setting (AN4 channel)
           4325                         ;  return Get_BinaryData_Final( 0b0.00100.01 );
3C11 3011  4326         MOVLW 0x11
3C12 33CB  4327         BRA   Get_BinaryData_Final
           4328                         ;}
           4329                         ;
           4330                         ;#ifdef DALLASnotMCP
           4331                         ;//############################################################################################
           4332                         ;// OneWire and Dallas 18B20 routines
           4333                         ;//############################################################################################
           4334                         ;
           4335                         ;//############################################################################################
           4336                         ;void Delay5us( uns8 val @ W ) // Absolutely precise timing but val != 0
           4337                         ;//############################################################################################
           4338                         ;{
           4339 Delay5us
           4340                         ;  // 16 MHz
           4341                         ;  // + 0.75us ( W=val, Call )
           4342                         ;  for ( ;; )
           4343                         ;  {         // loop time
           4344                         ;    nop2();	// 0.50us
3C13 3200  4345 m053    BRA   m054
           4346                         ;    nop2();	// 1.00us
3C14 3200  4347 m054    BRA   m055
           4348                         ;    nop2();	// 1.50us
3C15 3200  4349 m055    BRA   m056
           4350                         ;    nop2();	// 2.00us
3C16 3200  4351 m056    BRA   m057
           4352                         ;    nop2();	// 2.50us
3C17 3200  4353 m057    BRA   m058
           4354                         ;    nop2();	// 3.00us
3C18 3200  4355 m058    BRA   m059
           4356                         ;    nop();	// 3.25us
3C19 0000  4357 m059    NOP  
           4358                         ;    if ( --val == 0 ) // + 0.75us (W--, BTFS ) 
3C1A 3EFF  4359         ADDLW 0xFF
3C1B 1903  4360         BTFSC 0x03,Zero_
           4361                         ;      return;         // + 0.25us 
3C1C 0008  4362         RETURN
           4363                         ;    nop2();	// 4.50us
3C1D 3200  4364         BRA   m060
           4365                         ;  }         // 5.00us (Goto)
3C1E 33F4  4366 m060    BRA   m053
           4367                         ;}
           4368                         ;//############################################################################################
           4369                         ;
           4370                         ;#define	OneWireData0()	{ OneWire_TRIS = 0; }	  // 0.5us @ 16MHz
           4371                         ;#define OneWireData1()  { OneWire_TRIS = 1; }	  // 0.5us @ 16MHz
           4372                         ;
           4373                         ;//############################################################################################
           4374                         ;void OneWireWriteByte( uns8 byte )
           4375                         ;//############################################################################################
           4376                         ;{
           4377 OneWireWriteByte
3C1F 002B  4378         MOVLB 0x0B
3C20 00C2  4379         MOVWF byte
           4380                         ;  uns8 bitLoop = 8;
3C21 3008  4381         MOVLW 0x08
3C22 00C3  4382         MOVWF bitLoop_2
           4383                         ;  do
           4384                         ;  {
           4385                         ;    // Next sequence is time precision critical
           4386                         ;    GIE = FALSE;
3C23 138B  4387 m061    BCF   0x0B,GIE
           4388                         ;
           4389                         ;    OneWireData0();
3C24 0021  4390         MOVLB 0x01
3C25 118E  4391         BCF   TRISC,3
           4392                         ;    nop2();	        // 1 us [0.5 us]
3C26 3200  4393         BRA   m062
           4394                         ;    nop2();	        // [1.0 us]
3C27 3200  4395 m062    BRA   m063
           4396                         ;    if ( byte.0 )	// 2.5 us [1.75us]
3C28 002B  4397 m063    MOVLB 0x0B
3C29 1C42  4398         BTFSS byte,0
3C2A 3202  4399         BRA   m064
           4400                         ;      OneWireData1();
3C2B 0021  4401         MOVLB 0x01
3C2C 158E  4402         BSF   TRISC,3
           4403                         ;
           4404                         ;    // End of time precision critical sequence
           4405                         ;    GIE = TRUE;
3C2D 178B  4406 m064    BSF   0x0B,GIE
           4407                         ;
           4408                         ;    // 60us minimum in total, does not have to be precise
           4409                         ;    Delay5us( ( 60 - 3 ) / 5 + 1 );
3C2E 300C  4410         MOVLW 0x0C
3C2F 2413  4411         CALL  Delay5us
           4412                         ;
           4413                         ;    OneWireData1();
3C30 0021  4414         MOVLB 0x01
3C31 158E  4415         BSF   TRISC,3
           4416                         ;
           4417                         ;    byte >>= 1;
3C32 1003  4418         BCF   0x03,Carry
3C33 002B  4419         MOVLB 0x0B
3C34 0CC2  4420         RRF   byte,1
           4421                         ;  } while ( --bitLoop != 0 );
3C35 0BC3  4422         DECFSZ bitLoop_2,1
3C36 33EC  4423         BRA   m061
           4424                         ;}
3C37 0008  4425         RETURN
           4426                         ;
           4427                         ;//############################################################################################
           4428                         ;uns8 OneWireReadByte()
           4429                         ;//############################################################################################
           4430                         ;{
           4431 OneWireReadByte
           4432                         ;  uns8 result;
           4433                         ;  uns8 bitLoop = 8;
3C38 3008  4434         MOVLW 0x08
3C39 002B  4435         MOVLB 0x0B
3C3A 00C1  4436         MOVWF bitLoop_3
           4437                         ;  do
           4438                         ;  {
           4439                         ;    // Next sequence is time precision critical
           4440                         ;    GIE = FALSE;
3C3B 138B  4441 m065    BCF   0x0B,GIE
           4442                         ;
           4443                         ;    OneWireData0();
3C3C 0021  4444         MOVLB 0x01
3C3D 118E  4445         BCF   TRISC,3
           4446                         ;    nop2();	        // 1 us [0.5 us]
3C3E 3200  4447         BRA   m066
           4448                         ;#if F_OSC == 16000000
           4449                         ;    nop2();	        // [1.0 us]
3C3F 3200  4450 m066    BRA   m067
           4451                         ;#endif
           4452                         ;    OneWireData1();			// 2 us [1.5 us]
3C40 0021  4453 m067    MOVLB 0x01
3C41 158E  4454         BSF   TRISC,3
           4455                         ;    Delay5us( 15 / 5 );		// 17 us [16.5 us]
3C42 3003  4456         MOVLW 0x03
3C43 2413  4457         CALL  Delay5us
           4458                         ;
           4459                         ;    Carry = 0;				// 17.5 us [16.75 us]
3C44 1003  4460         BCF   0x03,Carry
           4461                         ;    if ( OneWire_IO_IN )	// 18.5 us [ 17.25 us] (condition must not modify Carry)
3C45 0020  4462         MOVLB 0x00
3C46 198E  4463         BTFSC PORTC,3
           4464                         ;      Carry = 1;
3C47 1403  4465         BSF   0x03,Carry
           4466                         ;
           4467                         ;    // End of time precision critical sequence
           4468                         ;    GIE = TRUE;				// must not modify Carry
3C48 178B  4469         BSF   0x0B,GIE
           4470                         ;    result = rr( result );
3C49 002B  4471         MOVLB 0x0B
3C4A 0CC0  4472         RRF   result,1
           4473                         ;
           4474                         ;    // 60us minimum in total, does not have to be precise
           4475                         ;    Delay5us( ( 60 - 20 ) / 5 + 1 );
3C4B 3009  4476         MOVLW 0x09
3C4C 2413  4477         CALL  Delay5us
           4478                         ;  } while ( --bitLoop != 0 );
3C4D 0BC1  4479         DECFSZ bitLoop_3,1
3C4E 33EC  4480         BRA   m065
           4481                         ;
           4482                         ;  return result;
3C4F 0840  4483         MOVF  result,W
3C50 0008  4484         RETURN
           4485                         ;}
           4486                         ;
           4487                         ;//############################################################################################
           4488                         ;bit OneWireReset()
           4489                         ;//############################################################################################
           4490                         ;{
           4491 OneWireReset
           4492                         ;  // Setting the pin once to low is enough
           4493                         ;  OneWire_IO_OUT = 0;
3C51 0022  4494         MOVLB 0x02
3C52 118E  4495         BCF   LATC,3
           4496                         ;  // Reset pulse
           4497                         ;  OneWireData0();
3C53 0021  4498         MOVLB 0x01
3C54 118E  4499         BCF   TRISC,3
           4500                         ;  Delay5us( 500 / 5 );
3C55 3064  4501         MOVLW 0x64
3C56 2413  4502         CALL  Delay5us
           4503                         ;  // Reset pulse end
           4504                         ;  OneWireData1();
3C57 158E  4505         BSF   TRISC,3
           4506                         ;  // Next sequence is time precision critical
           4507                         ;  GIE = FALSE;
3C58 138B  4508         BCF   0x0B,GIE
           4509                         ;  // Wait for presence pulse
           4510                         ;  Delay5us( 70 / 5 );
3C59 300E  4511         MOVLW 0x0E
3C5A 2413  4512         CALL  Delay5us
           4513                         ;  // End of time precision critical sequence
           4514                         ;  GIE = TRUE;
3C5B 178B  4515         BSF   0x0B,GIE
           4516                         ;  // Presence pulse?
           4517                         ;  if ( OneWire_IO_IN )
3C5C 0020  4518         MOVLB 0x00
3C5D 1D8E  4519         BTFSS PORTC,3
3C5E 3203  4520         BRA   m068
           4521                         ;  {
           4522                         ;    // No presence, finish initialization sequence
           4523                         ;    Delay5us( ( 500 - 70 ) / 5 );
3C5F 3056  4524         MOVLW 0x56
3C60 2413  4525         CALL  Delay5us
           4526                         ;    return returnFALSE();
3C61 3315  4527         BRA   returnFALSE
           4528                         ;  }
           4529                         ;  else
           4530                         ;  {
           4531                         ;    // Presence OK, finish initialization sequence
           4532                         ;    Delay5us( ( 500 - 70 ) / 5 );
3C62 3056  4533 m068    MOVLW 0x56
3C63 2413  4534         CALL  Delay5us
           4535                         ;    return returnTRUE();
3C64 3310  4536         BRA   returnTRUE
           4537                         ;  }
           4538                         ;}
           4539                         ;
           4540                         ;//############################################################################################
           4541                         ;void OneWireCmd( uns8 cmd )
           4542                         ;//############################################################################################
           4543                         ;{
           4544 OneWireCmd
3C65 002B  4545         MOVLB 0x0B
3C66 00C1  4546         MOVWF cmd
           4547                         ;  // OneWire: Skip ROM
           4548                         ;  OneWireWriteByte( CMD_SKIPROM );
3C67 30CC  4549         MOVLW 0xCC
3C68 241F  4550         CALL  OneWireWriteByte
           4551                         ;  // OneWire: Send command
           4552                         ;  OneWireWriteByte( cmd );
3C69 002B  4553         MOVLB 0x0B
3C6A 0841  4554         MOVF  cmd,W
3C6B 33B3  4555         BRA   OneWireWriteByte
           4556                         ;}
           4557                         ;
           4558                         ;//############################################################################################
           4559                         ;bit Ds18B20WriteConfig( uns8 value )
           4560                         ;//############################################################################################
           4561                         ;{
           4562 Ds18B20WriteConfig
3C6C 002B  4563         MOVLB 0x0B
3C6D 00C0  4564         MOVWF value_4
           4565                         ;  if ( OneWireReset() )
3C6E 2451  4566         CALL  OneWireReset
3C6F 1C03  4567         BTFSS 0x03,Carry
3C70 3306  4568         BRA   returnFALSE
           4569                         ;  {
           4570                         ;    // Write Scratchpad
           4571                         ;    OneWireCmd( CMD_WSCRATCHPAD );
3C71 304E  4572         MOVLW 0x4E
3C72 2465  4573         CALL  OneWireCmd
           4574                         ;
           4575                         ;    // Write TL = ? (we dot not care the value)
           4576                         ;    OneWireWriteByte( W );
3C73 241F  4577         CALL  OneWireWriteByte
           4578                         ;    // Write TH = ? (we dot not care the value)
           4579                         ;    OneWireWriteByte( W );
3C74 241F  4580         CALL  OneWireWriteByte
           4581                         ;    // Write Config byte
           4582                         ;    OneWireWriteByte( value );
3C75 002B  4583         MOVLB 0x0B
3C76 0840  4584         MOVF  value_4,W
3C77 241F  4585         CALL  OneWireWriteByte
           4586                         ;
           4587                         ;    if ( OneWireReset() )
3C78 2451  4588         CALL  OneWireReset
3C79 1C03  4589         BTFSS 0x03,Carry
3C7A 2B77  4590         GOTO  returnFALSE
           4591                         ;    {
           4592                         ;      //  Copy Scratchpad
           4593                         ;      OneWireCmd( CMD_CPYSCRATCHPAD );
3C7B 3048  4594         MOVLW 0x48
3C7C 2465  4595         CALL  OneWireCmd
           4596                         ;      return returnTRUE();
3C7D 2B75  4597         GOTO  returnTRUE
           4598                         ;    }
           4599                         ;  }
           4600                         ;  return returnFALSE();
           4601 
           4602   ; FILE ../../../../Development/include/DPA/DPAcustomHandler.h
           4603                         ;// *********************************************************************
           4604                         ;//   Main Custom DPA Handler header                                    *
           4605                         ;// *********************************************************************
           4606                         ;// Copyright (c) IQRF Tech s.r.o.
           4607                         ;//
           4608                         ;// File:    $RCSfile: DPAcustomHandler.h,v $
           4609                         ;// Version: $Revision: 1.113 $
           4610                         ;// Date:    $Date: 2020/02/27 13:17:18 $
           4611                         ;//
           4612                         ;// Revision history:
           4613                         ;//   2020/02/27  Release for DPA 4.13
           4614                         ;//   2020/01/09  Release for DPA 4.12
           4615                         ;//   2019/12/11  Release for DPA 4.11
           4616                         ;//   2019/10/09  Release for DPA 4.10
           4617                         ;//   2019/06/12  Release for DPA 4.03
           4618                         ;//   2019/06/03  Release for DPA 4.02
           4619                         ;//   2019/03/07  Release for DPA 4.01
           4620                         ;//   2019/01/10  Release for DPA 4.00
           4621                         ;//   2018/10/25  Release for DPA 3.03
           4622                         ;//   2017/11/16  Release for DPA 3.02
           4623                         ;//   2017/08/14  Release for DPA 3.01
           4624                         ;//   2017/03/13  Release for DPA 3.00
           4625                         ;//   2016/09/12  Release for DPA 2.28
           4626                         ;//   2016/04/14  Release for DPA 2.27
           4627                         ;//   2016/03/03  Release for DPA 2.26
           4628                         ;//   2016/01/21  Release for DPA 2.25
           4629                         ;//   2015/12/01  Release for DPA 2.24
           4630                         ;//   2015/10/23  Release for DPA 2.23
           4631                         ;//   2015/09/25  Release for DPA 2.22
           4632                         ;//   2015/09/03  Release for DPA 2.21
           4633                         ;//   2015/08/05  Release for DPA 2.20
           4634                         ;//   2014/10/31  Release for DPA 2.10
           4635                         ;//   2014/04/30  Release for DPA 2.00
           4636                         ;//   2013/10/03  Release for DPA 1.00
           4637                         ;//
           4638                         ;// *********************************************************************
           4639                         ;
           4640                         ;// Online DPA documentation https://doc.iqrf.org/DpaTechGuide/
           4641                         ;// IQRF Standards documentation https://www.iqrfalliance.org/iqrf-interoperability/
           4642                         ;
           4643                         ;#ifndef _CUSTOM_DPA_HANDLER_
           4644                         ;#define _CUSTOM_DPA_HANDLER_
           4645                         ;
           4646                         ;//############################################################################################
           4647                         ;// 1st include 
           4648                         ;
           4649                         ;// Custom DPA Handler routine declaration
           4650                         ;bit CustomDpaHandler();
           4651                         ;
           4652                         ;// Various DPA flags shared between DPA and Custom DPA Handler
           4653                         ;uns8 DpaFlags @ usedBank4[0];
           4654                         ;#ifdef COORDINATOR_CUSTOM_HANDLER
           4655                         ;// [C] TRUE if interface master is not connected (detected)
           4656                         ;bit IFaceMasterNotConnected @ DpaFlags.2;
           4657                         ;#endif
           4658                         ;// [N] [CN] DPA by interface notification is sent also when there was a "reading" like DPA request
           4659                         ;bit EnableIFaceNotificationOnRead @ DpaFlags.3;
           4660                         ;// [N] [NC] TRUE when node was just bonded using default bonding procedure
           4661                         ;bit NodeWasBonded @ DpaFlags.4;
           4662                         ;
           4663                         ;// [C] Ticks (decrementing) counter usable for timing in the coordinator's Customer DPA Handler
           4664                         ;uns16 DpaTicks @ usedBank4[1];
           4665                         ;// [N] [NC] toutRF for LP mode, read from configuration memory after reset
           4666                         ;uns8 LPtoutRF @ usedBank4[3];
           4667                         ;// DPA Request/Response HWPID
           4668                         ;uns16 _HWPID @ usedBank4[4];
           4669                         ;// Identifies type of reset (stored at UserReg0 upon module reset). See Reset chapter at IQRF User's Guide for more information
           4670                         ;uns8 ResetType @ usedBank4[6];
           4671                         ;// User DPA Values to return
           4672                         ;uns8 UserDpaValue @ usedBank4[7];
           4673                         ;// Network depth of the DPA request/response, increases on bridging, decreases on back-bridging
           4674                         ;uns8 NetDepth @ usedBank4[8];
           4675                         ;// TRUE when node was at DPA Service Mode after last boot
           4676                         ;bit DSMactivated @ usedBank4[9].0;
           4677                         ;// If set to TRUE, then LP RX mode in the main loop can be terminated by pin, see _RLPMAT
           4678                         ;bit LpRxPinTerminate @ usedBank4[9].1;
           4679                         ;// If set to TRUE, then [C] executes asynchronous DPA requests received from [N]
           4680                         ;bit AsyncReqAtCoordinator @ usedBank4[9].2;
           4681                         ;// RX filter used at the DPA main loop checkRF call
           4682                         ;uns8 RxFilter @ usedBank4[11];
           4683                         ;// Countdown variable for button bonding before going to deep sleep 
           4684                         ;uns16 BondingSleepCountdown @ usedBank4[12];
           4685                         ;#define BONDING_SLEEP_COUNTDOWN_UNIT  290
           4686                         ;// Non-zero pseudo-random value, read-only, updated on every Reset and Idle event, at [N] only.
           4687                         ;uns16 Random @ usedBank4[14];
           4688                         ;
           4689                         ;// Macro to return an error from the peripheral handler. If the code size is not an issue this macro is the right choice.
           4690                         ;#define DpaApiReturnPeripheralError(error) do { \
           4691                         ;	DpaApiSetPeripheralError( error ); \
           4692                         ;	return Carry; \
           4693                         ;  } while( 0 )
           4694                         ;
           4695                         ;// DPA API functions, see documentation for details
           4696                         ;#define	DpaApiRfTxDpaPacket( dpaValue, netDepthAndFlags ) DpaApiEntry( dpaValue, netDepthAndFlags, DPA_API_RFTX_DPAPACKET )
           4697                         ;#define	DpaApiReadConfigByte( index )					  DpaApiEntry( index, param3.low8, DPA_API_READ_CONFIG_BYTE )
           4698                         ;#define	DpaApiLocalRequest()							  DpaApiEntry( param2, param3.low8, DPA_API_LOCAL_REQUEST )
           4699                         ;#define	DpaApiSetPeripheralError( error )				  DpaApiEntry( error, param3.low8, DPA_API_SET_PERIPHERAL_ERROR )
           4700                         ;#define	DpaApiSendToIFaceMaster( dpaValue, flags )		  DpaApiEntry( dpaValue, flags, DPA_API_SEND_TO_IFACEMASTER )
           4701                         ;#define	DpaApiSetRfDefaults()							  DpaApiEntry( param2, param3.low8, DPA_API_SET_RF_DEFAULTS )
           4702                         ;
           4703                         ;#ifdef COORDINATOR_CUSTOM_HANDLER
           4704                         ;#define	DpaApiRfTxDpaPacketCoordinator()				  DpaApiEntry( param2, param3.low8, DPA_API_COORDINATOR_RFTX_DPAPACKET )
           4705                         ;#endif
           4706                         ;
           4707                         ;#ifdef COORDINATOR_CUSTOM_HANDLER
           4708                         ;#undef	DpaEvent_Interrupt
           4709                         ;#undef	DpaEvent_BeforeSleep
           4710                         ;#undef	DpaEvent_AfterSleep
           4711                         ;#undef	DpaEvent_FrcValue
           4712                         ;#undef	DpaEvent_FrcResponseTime
           4713                         ;#else
           4714                         ;#undef  DpaEvent_ReceiveDpaResponse
           4715                         ;#undef  DpaEvent_IFaceReceive
           4716                         ;#endif
           4717                         ;
           4718                         ;// To detect overlapping code in case someone would put some code before this header by mistake
           4719                         ;#pragma origin __APPLICATION_ADDRESS
           4720                         ;#pragma updateBank 0
           4721                         ;
           4722                         ;//############################################################################################
           4723                         ;// Main IQRF entry point jumps to the main DPA entry point
           4724                         ;void APPLICATION()
           4725                         ;//############################################################################################
           4726                         ;{
           4727                         ;  #asm
           4728                         ;    DW  __MOVLP( MAIN_DPA_ADDRESS >> 8 );
           4729                         ;  DW  __GOTO( MAIN_DPA_ADDRESS );
           4730                         ;  #endasm
           4731                         ;
           4732                         ;#ifndef NO_CUSTOM_DPA_HANDLER
           4733                         ;    // Fake call to force CustomDpaHandler() compilation
           4734                         ;    CustomDpaHandler();
           4735                         ;#endif
           4736                         ;
           4737                         ;  // Fake call to force DpaApiEntry() compilation
           4738                         ;  DpaApiEntry( param2, param3.low8, W );
           4739                         ;}
           4740                         ;
           4741                         ;//############################################################################################
           4742                         ;// Entry stub to the real DPA API entry
           4743                         ;#pragma origin DPA_API_ADDRESS_ENTRY
           4744                         ;uns8  DpaApiEntry( uns8 par1 @ param2, uns8 par2 @ param3.low8, uns8 apiIndex @ W )
           4745                         ;//############################################################################################
           4746                         ;{
           4747                         ;  #asm
           4748                         ;    DW  __MOVLP( DPA_API_ADDRESS >> 8 );
           4749                         ;  DW  __CALL( DPA_API_ADDRESS );
           4750                         ;  DW  __MOVLP( DPA_API_ADDRESS_ENTRY >> 8 );
           4751                         ;  #endasm
           4752                         ;
           4753                         ;    return W;
           4754                         ;}
           4755                         ;
           4756                         ;//############################################################################################
           4757                         ;#pragma origin DPA_API_ADDRESS_ENTRY + 0x08
           4758                         ;
           4759                         ;//############################################################################################
           4760                         ;
           4761                         ;#ifndef NO_CUSTOM_DPA_HANDLER
           4762                         ;// Next comes Custom DPA handler routine
           4763                         ;#pragma origin CUSTOM_HANDLER_ADDRESS
           4764                         ;#endif
           4765                         ;
           4766                         ;#pragma updateBank 1
           4767                         ;
           4768                         ;//############################################################################################
           4769                         ;#else // _CUSTOM_DPA_HANDLER_
           4770                         ;//############################################################################################
           4771                         ;// 2nd include
           4772                         ;
           4773                         ;#ifndef NO_CUSTOM_DPA_HANDLER
           4774                         ;// Code bumper to detect too long code of Custom DPA handler + other routines
           4775                         ;#pragma origin CUSTOM_HANDLER_ADDRESS_END
     0000  4776         ORG 0x3D80
           4777                         ;// To avoid adding some code after handler by mistake
           4778                         ;#pragma origin __MAX_FLASH_ADDRESS
     0000  4779         ORG 0x3FFF
           4780 
           4781         END
           4782 
           4783 
           4784 ; *** KEY INFO ***
           4785 
           4786 ; 0x0100 P0    5 word(s)  0 % : main
           4787 
           4788 ; 0x3A00 P7    4 word(s)  0 % : APPLICATION
           4789 ; 0x3810 P7    2 word(s)  0 % : dummy
           4790 ; 0x3816 P7    2 word(s)  0 % : iqrfSleep
           4791 ; 0x3819 P7    2 word(s)  0 % : _debug
           4792 ; 0x381C P7    2 word(s)  0 % : moduleInfo
           4793 ; 0x3822 P7    2 word(s)  0 % : pulsingLEDR
           4794 ; 0x3825 P7    2 word(s)  0 % : pulseLEDR
           4795 ; 0x3828 P7    2 word(s)  0 % : stopLEDR
           4796 ; 0x382B P7    2 word(s)  0 % : pulsingLEDG
           4797 ; 0x382E P7    2 word(s)  0 % : pulseLEDG
           4798 ; 0x3831 P7    2 word(s)  0 % : stopLEDG
           4799 ; 0x3834 P7    2 word(s)  0 % : setOnPulsingLED
           4800 ; 0x3837 P7    2 word(s)  0 % : setOffPulsingLED
           4801 ; 0x383A P7    2 word(s)  0 % : eeReadByte
           4802 ; 0x383D P7    2 word(s)  0 % : eeReadData
           4803 ; 0x3840 P7    2 word(s)  0 % : eeWriteByte
           4804 ; 0x3843 P7    2 word(s)  0 % : eeWriteData
           4805 ; 0x3846 P7    2 word(s)  0 % : readFromRAM
           4806 ; 0x384C P7    2 word(s)  0 % : clearBufferINFO
           4807 ; 0x384F P7    2 word(s)  0 % : swapBufferINFO
           4808 ; 0x3852 P7    2 word(s)  0 % : compareBufferINFO2RF
           4809 ; 0x3855 P7    2 word(s)  0 % : copyBufferINFO2COM
           4810 ; 0x3858 P7    2 word(s)  0 % : copyBufferINFO2RF
           4811 ; 0x385B P7    2 word(s)  0 % : copyBufferRF2COM
           4812 ; 0x385E P7    2 word(s)  0 % : copyBufferRF2INFO
           4813 ; 0x3861 P7    2 word(s)  0 % : copyBufferCOM2RF
           4814 ; 0x3864 P7    2 word(s)  0 % : copyBufferCOM2INFO
           4815 ; 0x3867 P7    2 word(s)  0 % : copyMemoryBlock
           4816 ; 0x386A P7    2 word(s)  0 % : startDelay
           4817 ; 0x386D P7    2 word(s)  0 % : startLongDelay
           4818 ; 0x3870 P7    2 word(s)  0 % : isDelay
           4819 ; 0x3873 P7    2 word(s)  0 % : waitDelay
           4820 ; 0x3876 P7    2 word(s)  0 % : waitMS
           4821 ; 0x3879 P7    2 word(s)  0 % : startCapture
           4822 ; 0x387C P7    2 word(s)  0 % : captureTicks
           4823 ; 0x3882 P7    2 word(s)  0 % : waitNewTick
           4824 ; 0x3885 P7    2 word(s)  0 % : enableSPI
           4825 ; 0x3888 P7    2 word(s)  0 % : disableSPI
           4826 ; 0x388B P7    2 word(s)  0 % : startSPI
           4827 ; 0x388E P7    2 word(s)  0 % : stopSPI
           4828 ; 0x3891 P7    2 word(s)  0 % : restartSPI
           4829 ; 0x3894 P7    2 word(s)  0 % : getStatusSPI
           4830 ; 0x3897 P7    2 word(s)  0 % : setRFpower
           4831 ; 0x389A P7    2 word(s)  0 % : setLEDG
           4832 ; 0x389D P7    2 word(s)  0 % : setRFchannel
           4833 ; 0x38A0 P7    2 word(s)  0 % : setRFmode
           4834 ; 0x38A3 P7    2 word(s)  0 % : setRFspeed
           4835 ; 0x38A6 P7    2 word(s)  0 % : setRFsleep
           4836 ; 0x38A9 P7    2 word(s)  0 % : setRFready
           4837 ; 0x38AC P7    2 word(s)  0 % : RFTXpacket
           4838 ; 0x38AF P7    2 word(s)  0 % : RFRXpacket
           4839 ; 0x38B2 P7    2 word(s)  0 % : checkRF
           4840 ; 0x38B8 P7    2 word(s)  0 % : amIBonded
           4841 ; 0x38BB P7    2 word(s)  0 % : removeBond
           4842 ; 0x38BE P7    2 word(s)  0 % : bondNewNode
           4843 ; 0x38C1 P7    2 word(s)  0 % : isBondedNode
           4844 ; 0x38C4 P7    2 word(s)  0 % : removeBondedNode
           4845 ; 0x38C7 P7    2 word(s)  0 % : rebondNode
           4846 ; 0x38CA P7    2 word(s)  0 % : clearAllBonds
           4847 ; 0x38CD P7    2 word(s)  0 % : setNonetMode
           4848 ; 0x38D0 P7    2 word(s)  0 % : setCoordinatorMode
           4849 ; 0x38D3 P7    2 word(s)  0 % : setNodeMode
           4850 ; 0x38D6 P7    2 word(s)  0 % : setNetworkFilteringOn
           4851 ; 0x38D9 P7    2 word(s)  0 % : setNetworkFilteringOff
           4852 ; 0x38DC P7    2 word(s)  0 % : getNetworkParams
           4853 ; 0x38DF P7    2 word(s)  0 % : setRoutingOn
           4854 ; 0x38E2 P7    2 word(s)  0 % : setRoutingOff
           4855 ; 0x38E8 P7    2 word(s)  0 % : answerSystemPacket
           4856 ; 0x38EB P7    2 word(s)  0 % : discovery
           4857 ; 0x38EE P7    2 word(s)  0 % : wasRouted
           4858 ; 0x38F1 P7    2 word(s)  0 % : optimizeHops
           4859 ; 0x38F4 P7    2 word(s)  0 % : getSupplyVoltage
           4860 ; 0x38F7 P7    2 word(s)  0 % : getTemperature
           4861 ; 0x38FA P7    2 word(s)  0 % : clearBufferRF
           4862 ; 0x3910 P7    2 word(s)  0 % : isDiscoveredNode
           4863 ; 0x3913 P7    2 word(s)  0 % : enableRFPGM
           4864 ; 0x3916 P7    2 word(s)  0 % : disableRFPGM
           4865 ; 0x3919 P7    2 word(s)  0 % : setupRFPGM
           4866 ; 0x391C P7    2 word(s)  0 % : runRFPGM
           4867 ; 0x391F P7    2 word(s)  0 % : iqrfDeepSleep
           4868 ; 0x3922 P7    2 word(s)  0 % : wasRFICrestarted
           4869 ; 0x3925 P7    2 word(s)  0 % : eeeWriteData
           4870 ; 0x3928 P7    2 word(s)  0 % : eeeReadData
           4871 ; 0x3931 P7    2 word(s)  0 % : setINDF0
           4872 ; 0x3934 P7    2 word(s)  0 % : setINDF1
           4873 ; 0x3937 P7    2 word(s)  0 % : getRSSI
           4874 ; 0x393A P7    2 word(s)  0 % : removeBondAddress
           4875 ; 0x393D P7    2 word(s)  0 % : sendFRC
           4876 ; 0x3940 P7    2 word(s)  0 % : responseFRC
           4877 ; 0x3943 P7    2 word(s)  0 % : bondRequestAdvanced
           4878 ; 0x3946 P7    2 word(s)  0 % : prebondNodeAtNode
           4879 ; 0x3949 P7    2 word(s)  0 % : nodeAuthorization
           4880 ; 0x394C P7    2 word(s)  0 % : dummy01
           4881 ; 0x3958 P7    2 word(s)  0 % : setAccessPassword
           4882 ; 0x395B P7    2 word(s)  0 % : setUserKey
           4883 ; 0x3961 P7    2 word(s)  0 % : amIRecipientOfFRC
           4884 ; 0x3964 P7    2 word(s)  0 % : setLEDR
           4885 ; 0x3967 P7    2 word(s)  0 % : encryptBufferRF
           4886 ; 0x396A P7    2 word(s)  0 % : decryptBufferRF
           4887 ; 0x396D P7    2 word(s)  0 % : prebondNodeAtCoordinator
           4888 ; 0x3970 P7    2 word(s)  0 % : setFSRs
           4889 ; 0x3973 P7    2 word(s)  0 % : updateCRC16
           4890 ; 0x3976 P7    2 word(s)  0 % : smartConnect
           4891 ; 0x3979 P7    2 word(s)  0 % : addressBitmap
           4892 ; 0x397C P7    3 word(s)  0 % : setServiceChannel
           4893 ; 0x3A08 P7    4 word(s)  0 % : DpaApiEntry
           4894 ; 0x3A20 P7  341 word(s) 16 % : CustomDpaHandler
           4895 ; 0x3BCF P7   15 word(s)  0 % : Get0_Temperature
           4896 ; 0x3C0B P7    4 word(s)  0 % : Get1_BinaryData_Light
           4897 ; 0x3C0F P7    4 word(s)  0 % : Get2_BinaryData_Potentiometer
           4898 ; 0x3B7B P7   15 word(s)  0 % : StoreValue
           4899 ; 0x3C6C P7   18 word(s)  0 % : Ds18B20WriteConfig
           4900 ; 0x3C51 P7   20 word(s)  0 % : OneWireReset
           4901 ; 0x3C38 P7   25 word(s)  1 % : OneWireReadByte
           4902 ; 0x3C1F P7   25 word(s)  1 % : OneWireWriteByte
           4903 ; 0x3B75 P7    2 word(s)  0 % : returnTRUE
           4904 ; 0x3B77 P7    2 word(s)  0 % : returnFALSE
           4905 ; 0x3B79 P7    2 word(s)  0 % : setPlusPlusINDF1
           4906 ; 0x3B8A P7    5 word(s)  0 % : setFRCerror
           4907 ; 0x3B8F P7   64 word(s)  3 % : AdjustFrcTemperature
           4908 ; 0x3BDE P7   45 word(s)  2 % : Get_BinaryData_Final
           4909 ; 0x3C13 P7   12 word(s)  0 % : Delay5us
           4910 ; 0x3C65 P7    7 word(s)  0 % : OneWireCmd
           4911 
           4912 ; RAM usage: 991 bytes (5 local), 33 bytes free
           4913 ; Maximum call level: 6
           4914 ;  Codepage 0 has    6 word(s) :   0 %
           4915 ;  Codepage 1 has    0 word(s) :   0 %
           4916 ;  Codepage 2 has    0 word(s) :   0 %
           4917 ;  Codepage 3 has    0 word(s) :   0 %
           4918 ;  Codepage 4 has    0 word(s) :   0 %
           4919 ;  Codepage 5 has    0 word(s) :   0 %
           4920 ;  Codepage 6 has    0 word(s) :   0 %
           4921 ;  Codepage 7 has  823 word(s) :  40 %
           4922 ; Total of 829 code words (5 %)
