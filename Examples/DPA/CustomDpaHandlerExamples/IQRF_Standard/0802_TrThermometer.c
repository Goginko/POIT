// *********************************************************************
//   Custom DPA Handler code example - Standard Sensors - Thermometer  *
// *********************************************************************
// Copyright (c) IQRF Tech s.r.o.
//
// File:    $RCSfile: 0802_TrThermometer.c,v $
// Version: $Revision: 1.20 $
// Date:    $Date: 2020/01/06 17:41:47 $
//
// Revision history:
//   2018/10/25  Release for DPA 3.03
//   2017/11/16  Release for DPA 3.02
//   2017/08/14  Release for DPA 3.01
//
// *********************************************************************

// Online DPA documentation https://doc.iqrf.org/DpaTechGuide/
// IQRF Standards documentation https://www.iqrfalliance.org/iqrf-interoperability/

// This example implements 1 temperature sensor according to the IQRF Sensors standard

// Default IQRF include (modify the path according to your setup)
#include "IQRF.h"

// Uncomment to implement Custom DPA Handler for Coordinator
//#define COORDINATOR_CUSTOM_HANDLER

// Default DPA header (modify the path according to your setup)
#include "DPA.h"
// Default Custom DPA Handler header (modify the path according to your setup)
#include "DPAcustomHandler.h"
// IQRF standards header (modify the path according to your setup)
#include "IQRFstandard.h"
#include "IQRF_HWPID.h"

//############################################################################################

// Calibration value address in the EEPROM
#define TEMP_CALIBRATION_ADDRESS  0

// Initial calibration value is 0
#pragma cdata[ __EESTART + TEMP_CALIBRATION_ADDRESS ] = 0, 0

// Calibrates temperature at param3, that was read by getTemperature()
void CalibrateParam3();

// Must be the 1st defined function in the source code in order to be placed at the correct FLASH location!
//############################################################################################
bit CustomDpaHandler()
//############################################################################################
{
  // This forces CC5X to wisely use MOVLB instructions (doc says:  The 'default' bank is used by the compiler for loops and labels when the algorithm gives up finding the optimal choice)
#pragma updateBank default = UserBank_01

  // Handler presence mark
  clrwdt();

  // Sleeping parameters, valid when Time != 0
  static TPerOSSleep_Request PerOSSleep_Request;

  // Detect DPA event to handle
  switch ( GetDpaEvent() )
  {
    // -------------------------------------------------
    case DpaEvent_Interrupt:
      // Do an extra quick background interrupt work
      // ! The time spent handling this event is critical.If there is no interrupt to handle return immediately otherwise keep the code as fast as possible.
      // ! Make sure the event is the 1st case in the main switch statement at the handler routine.This ensures that the event is handled as the 1st one.
      // ! It is desirable that this event is handled with immediate return even if it is not used by the custom handler because the Interrupt event is raised on every MCU interrupt and the “empty” return handler ensures the shortest possible interrupt routine response time.
      // ! Only global variables or local ones marked by static keyword can be used to allow reentrancy.
      // ! Make sure race condition does not occur when accessing those variables at other places.
      // ! Make sure( inspect.lst file generated by C compiler ) compiler does not create any hidden temporary local variable( occurs when using division, multiplication or bit shifts ) at the event handler code.The name of such variable is usually Cnumbercnt.
      // ! Do not call any OS functions except setINDFx().
      // ! Do not use any OS variables especially for writing access.
      // ! All above rules apply also to any other function being called from the event handler code, although calling any function from Interrupt event is not recommended because of additional MCU stack usage.

      return Carry;

      // -------------------------------------------------
    case DpaEvent_Idle:
      // Do a quick background work when RF packet is not received

      // Should go to sleep?
      if ( PerOSSleep_Request.Time != 0 )
      {
        // Copy sleep parameters to the DPA request
        _DpaMessage.PerOSSleep_Request.Time = PerOSSleep_Request.Time;
        _DpaMessage.PerOSSleep_Request.Control = PerOSSleep_Request.Control;
        // Switch off sleeping time=flag
        PerOSSleep_Request.Time = 0;
        // Finalize OS Sleep DPA Request
        _DpaDataLength = sizeof( _DpaMessage.PerOSSleep_Request );
        _PNUM = PNUM_OS;
        _PCMD = CMD_OS_SLEEP;
        // Perform local DPA Request to go to sleep
        DpaApiLocalRequest();
      }
      break;

      // -------------------------------------------------
    case DpaEvent_DpaRequest:
      // Called to interpret DPA request for peripherals
      // -------------------------------------------------
      // Peripheral enumeration
      if ( IsDpaEnumPeripheralsRequest() )
      {
        // We implement 1 standard peripheral
        _DpaMessage.EnumPeripheralsAnswer.UserPerNr = 1;
        FlagUserPer( _DpaMessage.EnumPeripheralsAnswer.UserPer, PNUM_STD_SENSORS );
        _DpaMessage.EnumPeripheralsAnswer.HWPID = HWPID_IQRF_TECH__DEMO_TR_THERMOMETER;
        _DpaMessage.EnumPeripheralsAnswer.HWPIDver = 0x0001;

DpaHandleReturnTRUE:
        return TRUE;
      }
      // -------------------------------------------------
      // Get information about peripheral
      else if ( IsDpaPeripheralInfoRequest() )
      {
        if ( _PNUM == PNUM_STD_SENSORS )
        {
          _DpaMessage.PeripheralInfoAnswer.PerT = PERIPHERAL_TYPE_STD_SENSORS;
          _DpaMessage.PeripheralInfoAnswer.PerTE = PERIPHERAL_TYPE_EXTENDED_READ_WRITE;
          // Set standard version
          _DpaMessage.PeripheralInfoAnswer.Par1 = 13;
          goto DpaHandleReturnTRUE;
        }

        break;
      }
      // -------------------------------------------------
      else
      {
        // Handle peripheral command

        // Supported peripheral number?
        if ( _PNUM == PNUM_STD_SENSORS )
        {
          // Supported commands?
          switch ( _PCMD )
          {
            // Invalid command
            default:
              // Return error
              W = ERROR_PCMD;
              goto _ERROR_W;

              // Sensor enumeration
            case PCMD_STD_ENUMERATE:
              if ( _DpaDataLength != 0 )
              {
_ERROR_DATA_LEN:
                W = ERROR_DATA_LEN;
                goto _ERROR_W;
              }

              _DpaDataLength |= 1; // = 1 (optimization as _DpaDataLength was 0 for sure)
              goto _Enumerate;

              // Supported commands. They are handled almost the same way
            case PCMD_STD_SENSORS_READ_VALUES:
            case PCMD_STD_SENSORS_READ_TYPES_AND_VALUES:
            {
              bit returnCalibration = FALSE;

              // No sensor bitmap specified? W = _DpaDataLength. Note: W is used to avoid MOVLB at next if
              W = _DpaDataLength;
              if ( W == 0 )	// Note: must not modify W
              {
                // Bitmap is 32 bits long = 4 (Note: using here save MOVLB)
                _DpaDataLength = W = 4;
                // Simulate 1st sensor in the bitmap (states of the other unimplemented sensors do not care)
                _DpaMessage.Request.PData[0].0 = 1; // Note: must not modify W
              }

              // Invalid bitmap (data) length (W = _DpaDataLength)?
              switch ( W )
              {
                // Yes!
                default:
                  // Return error
                  goto _ERROR_DATA_LEN;

                  // No extra data written to sensor
                case ( (uns8)( sizeof( _DpaMessageIqrfStd.PerStdSensorRead_Request.Bitmap ) ) ):
                  break;

                  // Extra data written to sensor
                case ( (uns8)( sizeof( _DpaMessageIqrfStd.PerStdSensorRead_Request.Bitmap ) + 5 ) ):
                  // To the 1st i.e. temperature sensor?
                  if ( FSR1[offsetof( TPerStdSensorRead_Request, WrittenData ) + 0] != 0 )
                  {
                    // No, error
_ERROR_DATA:
                    W = ERROR_DATA;
_ERROR_W:
                    DpaApiReturnPeripheralError( W );
                  }

                  // Parse data content
                  switch ( FSR1[offsetof( TPerStdSensorRead_Request, WrittenData ) + 1] )
                  {
                    // Invalid 1st "header" byte
                    default:
                      goto _ERROR_DATA;

                      // Get calibration temperature
                    case STD_SENSOR_TYPE_TEMPERATURE_DATA_GET_1_POINT_CALIBRATION:
                      returnCalibration = TRUE;
                      break;

                      // Set calibration temperature
                    case STD_SENSOR_TYPE_TEMPERATURE_DATA_SET_1_POINT_CALIBRATION:
                      // Write calibration to the memory
                      bufferINFO[0] = FSR1[offsetof( TPerStdSensorRead_Request, WrittenData ) + 2];
                      bufferINFO[1] = FSR1[offsetof( TPerStdSensorRead_Request, WrittenData ) + 3];
                      eeWriteData( TEMP_CALIBRATION_ADDRESS, sizeof( uns16 ) );
                      break;
                  }
                  break;
              }

              // Get ready return data length for temperature data only (Note: optimization, 2 = 4/2 is used to save)
              _DpaDataLength = sizeof( uns16 );

              // Is my only sensor selected?
              if ( _DpaMessage.Request.PData[0].0 )
              {
                // Measure temperature?
                if ( !returnCalibration )
                {
                  // Error reading temperature? Note: param3 holds temperature value after calling getTemperature()
                  if ( getTemperature() == -128 )
                    // Return standard error value
                    STD_SENSOR_TYPE_TEMPERATURE_SET_ERROR( param3 );
                  else
                    CalibrateParam3();
                }
                else
                {
                  // No, return calibration
                  param3 = 0;
                  CalibrateParam3();
                }

                // Return the sensor type too?
                if ( _PCMD == PCMD_STD_SENSORS_READ_TYPES_AND_VALUES )
                {
                  // 3 bytes (1 byte with type, 2 bytes with temperature value) will be returned
                  _DpaDataLength++;
_Enumerate:
                  // 1st byte is sensor type
                  _DpaMessage.Response.PData[0] = STD_SENSOR_TYPE_TEMPERATURE;
                  // 3rd byte is higher byte of temperature value
                  _DpaMessage.Response.PData[2] = param3.high8;
                  // 2nd byte is lower byte of temperature value
                  W = param3.low8;
                }
                else
                {
                  // 2 bytes to return
                  // 1st byte is lower byte of temperature value
                  _DpaMessage.Response.PData[0] = param3.low8;
                  // 2nd byte is higher byte of temperature value
                  W = param3.high8;
                }

                // Store 2nd byte for both supported commands
                _DpaMessage.Response.PData[1] = W;
                // Handled!
                goto DpaHandleReturnTRUE;
              }
              else
              {
                // My sensor not selected, so no data returned
                _DpaDataLength = 0;
                goto DpaHandleReturnTRUE;
              }
            }
          }
        }

        break;
      }

      // -------------------------------------------------
    case DpaEvent_FrcValue:
      // Called to get FRC value

      // Check for correct FRC and FRC user data (signature byte and sensor index == 0)
      switch ( _PCMD )
      {
        case FRC_STD_SENSORS_1B:
        case FRC_STD_SENSORS_2B:
          // FSR1 for optimization purposes (avoid MOVLB) will be used to point to DataOutBeforeResponseFRC[0...]
          FSR1 = &DataOutBeforeResponseFRC[0];

          if ( *FSR1++ /*DataOutBeforeResponseFRC[0]*/ == PNUM_STD_SENSORS &&
            ( *FSR1 /*DataOutBeforeResponseFRC[1]*/ == 0x00 || *FSR1 /*DataOutBeforeResponseFRC[1]*/ == STD_SENSOR_TYPE_TEMPERATURE ) &&
               ( *++FSR1 /*DataOutBeforeResponseFRC[2]*/ & 0x1f ) == 0 )
          {
            // Return error code
            responseFRCvalue2B = 2;
            // Get temperature and adjust it for FRC
            // Temperature OK?
            if ( getTemperature() != -128 )
            {
              // Calibrate the temperatures
              CalibrateParam3();
              // Return sensor FRC value 2B
              responseFRCvalue2B = param3 ^ 0x8000;

              // Return sensor FRC value 1B
              // Check for out of limits
              if ( (int16)param3 <= (int16)( 105.5 * 16 ) && (int16)param3 >= ( (int16)-20 * 16 ) )
              {
                // CC5x reports "Sign problems, please typecast one operand to unsigned (uns16)"
                // param3 = (int16)param3 / 8;
                param3.high8 = asr( param3.high8 );
                param3.low8 = rr( param3.low8 );
                param3.high8 = asr( param3.high8 );
                param3.low8 = rr( param3.low8 );
                param3.high8 = asr( param3.high8 );
                param3.low8 = rr( param3.low8 );

                responseFRCvalue = (int8)param3.low8 + 44;
              }
            }

            // The sensor was measured by FRC, check if there is a sleep request
            FSR1++;
            if ( INDF1.0 ) // Note: same as DataOutBeforeResponseFRC[3].0
            {
              // Remember sleep parameters to go to sleep at the Idle event later
              PerOSSleep_Request.Time.low8 = FSR1[4 - 3]; // Note: same as DataOutBeforeResponseFRC[4]
              PerOSSleep_Request.Time.high8 = FSR1[5 - 3]; // Note: same as DataOutBeforeResponseFRC[5]
              PerOSSleep_Request.Control = FSR1[6 - 3]; // Note: same as DataOutBeforeResponseFRC[6]
            }
          }
          break;
      }
      break;

      // -------------------------------------------------
    case DpaEvent_FrcResponseTime:
      // Called to get FRC response time

      // In this example the FRC command is a fast one
      switch ( DataOutBeforeResponseFRC[0] )
      {
        case FRC_STD_SENSORS_1B:
        case FRC_STD_SENSORS_2B:
          responseFRCvalue = _FRC_RESPONSE_TIME_40_MS;
          break;
      }
      break;
  }

DpaHandleReturnFALSE:
  return FALSE;
}


//############################################################################################
void CalibrateParam3()
//############################################################################################
{
  // Read calibration
  eeReadData( TEMP_CALIBRATION_ADDRESS, sizeof( uns16 ) );
  uns16 calib @ bufferINFO[0];
  param3 += calib;
}

//############################################################################################
// Default Custom DPA Handler header; 2nd include to implement Code bumper to detect too long code of the Custom DPA Handler (modify the path according to your setup) 
#include "DPAcustomHandler.h"
//############################################################################################
