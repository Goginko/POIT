// *********************************************************************
//   Custom DPA Handler code example - Standard Sensors - Template     *
// *********************************************************************
// Copyright (c) IQRF Tech s.r.o.
//
// File:    $RCSfile: 1402_Sensor-Template.c,v $
// Version: $Revision: 1.28 $
// Date:    $Date: 2020/02/20 17:18:58 $
//
// Revision history:
//   2020/01/09  Release for DPA 4.12
//   2018/10/25  Release for DPA 3.03
//   2017/11/16  Release for DPA 3.02
//   2017/08/14  Release for DPA 3.01
//
// *********************************************************************

// Online DPA documentation https://doc.iqrf.org/DpaTechGuide/
// IQRF Standards documentation https://www.iqrfalliance.org/iqrf-interoperability/

// This example implements 6 sensors according to the IQRF Sensors standard. The example does not implement writing data to the sensors.

// Default IQRF include (modify the path according to your setup)
#include "IQRF.h"

// Uncomment to implement Custom DPA Handler for Coordinator
//#define COORDINATOR_CUSTOM_HANDLER

// Default DPA header (modify the path according to your setup)
#include "DPA.h"
// Default Custom DPA Handler header (modify the path according to your setup)
#include "DPAcustomHandler.h"
// IQRF standards header (modify the path according to your setup)
#include "IQRFstandard.h"
#include "IQRF_HWPID.h"

//############################################################################################

// Number of implemented sensors
#define	SENSORS_COUNT 7

// Variables to store sensor value at Get?_????() methods.
uns16 sensorValue @ param3;
uns16 sensorValueHighWord @ param4;

// Reads sensor value to the sensorValue variable and to responseFRCvalue(2B,4B) variable(s) based on FRC command @ _PCMD
// Returns TRUE if the FRC is prepared
bit Get0_Temperature();
bit Get1_CO2();
bit Get2_VOC();
bit Get3_Humidity();
bit Get4_Binary7();
bit Get5_DataBlock();
bit Get6_Binary30();

// Stores sensor value byte(s) to the FSR1[+1...], in case of PCMD_STD_SENSORS_READ_TYPES_AND_VALUES sensor type is stored before value byte(s)
void StoreValue( uns8 sensorType );

// FRC parameter
uns8  sensorIndexAndData;

// Must be the 1st defined function in the source code in order to be placed at the correct FLASH location!
//############################################################################################
bit CustomDpaHandler()
//############################################################################################
{
  // This forces CC5X to wisely use MOVLB instructions (doc says:  The 'default' bank is used by the compiler for loops and labels when the algorithm gives up finding the optimal choice)
#pragma updateBank default = UserBank_01

// Handler presence mark
  clrwdt();

  // Sleeping parameters, valid when Time != 0
  static TPerOSSleep_Request PerOSSleep_Request;

  // Detect DPA event to handle
  switch ( GetDpaEvent() )
  {
    // -------------------------------------------------
    case DpaEvent_Interrupt:
      // Do an extra quick background interrupt work
      // ! The time spent handling this event is critical.If there is no interrupt to handle return immediately otherwise keep the code as fast as possible.
      // ! Make sure the event is the 1st case in the main switch statement at the handler routine.This ensures that the event is handled as the 1st one.
      // ! It is desirable that this event is handled with immediate return even if it is not used by the custom handler because the Interrupt event is raised on every MCU interrupt and the “empty” return handler ensures the shortest possible interrupt routine response time.
      // ! Only global variables or local ones marked by static keyword can be used to allow reentrancy.
      // ! Make sure race condition does not occur when accessing those variables at other places.
      // ! Make sure( inspect.lst file generated by C compiler ) compiler does not create any hidden temporary local variable( occurs when using division, multiplication or bit shifts ) at the event handler code.The name of such variable is usually Cnumbercnt.
      // ! Do not call any OS functions except setINDFx().
      // ! Do not use any OS variables especially for writing access.
      // ! All above rules apply also to any other function being called from the event handler code, although calling any function from Interrupt event is not recommended because of additional MCU stack usage.
      return Carry;

      // -------------------------------------------------
    case DpaEvent_Idle:
      // Do a quick background work when RF packet is not received

      // Should go to sleep?
      if ( PerOSSleep_Request.Time != 0 )
      {
        // Copy sleep parameters to the DPA request
        _DpaMessage.PerOSSleep_Request.Time = PerOSSleep_Request.Time;
        _DpaMessage.PerOSSleep_Request.Control = PerOSSleep_Request.Control;
        // Switch off sleeping time=flag
        PerOSSleep_Request.Time = 0;
        // Finalize OS Sleep DPA Request
        _DpaDataLength = sizeof( _DpaMessage.PerOSSleep_Request );
        _PNUM = PNUM_OS;
        _PCMD = CMD_OS_SLEEP;
        // Perform local DPA Request to go to sleep
        DpaApiLocalRequest();
      }
      break;

      // -------------------------------------------------
    case DpaEvent_DpaRequest:
      // Called to interpret DPA request for peripherals
      // -------------------------------------------------
      // Peripheral enumeration
      if ( IsDpaEnumPeripheralsRequest() )
      {
        // We implement 1 standard peripheral
        _DpaMessage.EnumPeripheralsAnswer.UserPerNr = 1;
        FlagUserPer( _DpaMessage.EnumPeripheralsAnswer.UserPer, PNUM_STD_SENSORS );
        // ToDo: use actual IQRF Alliance allocated HWPID and current version of this handler
        _DpaMessage.EnumPeripheralsAnswer.HWPID = HWPID_IQRF_TECH__DEMO_SENSOR_TEMPLATE;
        _DpaMessage.EnumPeripheralsAnswer.HWPIDver = 0x0002;

DpaHandleReturnTRUE:
        return TRUE;
      }
      // -------------------------------------------------
      // Get information about peripheral
      else if ( IsDpaPeripheralInfoRequest() )
      {
        if ( _PNUM == PNUM_STD_SENSORS )
        {
          _DpaMessage.PeripheralInfoAnswer.PerT = PERIPHERAL_TYPE_STD_SENSORS;
          _DpaMessage.PeripheralInfoAnswer.PerTE = PERIPHERAL_TYPE_EXTENDED_READ_WRITE;
          // Set standard version
          _DpaMessage.PeripheralInfoAnswer.Par1 = 13;
          goto DpaHandleReturnTRUE;
        }

        break;
      }
      // -------------------------------------------------
      else
      {
        // Handle peripheral command

        // Supported peripheral number?
        if ( _PNUM == PNUM_STD_SENSORS )
        {
          // Supported commands?
          switch ( _PCMD )
          {
            // Invalid command
            default:
              // Return error
              DpaApiReturnPeripheralError( ERROR_PCMD );

              // Sensor enumeration
            case PCMD_STD_ENUMERATE:
              if ( _DpaDataLength != 0 )
                goto _ERROR_DATA_LEN;

              // Then just enumerate their types
              _DpaMessage.Response.PData[0] = STD_SENSOR_TYPE_TEMPERATURE;
              _DpaMessage.Response.PData[1] = STD_SENSOR_TYPE_CO2;
              _DpaMessage.Response.PData[2] = STD_SENSOR_TYPE_VOC;
              _DpaMessage.Response.PData[3] = STD_SENSOR_TYPE_HUMIDITY;
              _DpaMessage.Response.PData[4] = STD_SENSOR_TYPE_BINARYDATA7;
              _DpaMessage.Response.PData[5] = STD_SENSOR_TYPE_DATA_BLOCK;
              _DpaMessage.Response.PData[6] = STD_SENSOR_TYPE_BINARYDATA30;
              W = SENSORS_COUNT;
              goto _W2_DpaDataLength;

              // Supported commands. They are handled the same way except one "if" at StoreValue() method
            case PCMD_STD_SENSORS_READ_VALUES:
            case PCMD_STD_SENSORS_READ_TYPES_AND_VALUES:
            {
              // No sensor bitmap specified? W = _DpaDataLength. Note: W is used to avoid MOVLB at next if
              W = _DpaDataLength;
              if ( W == 0 )	// Note: must not modify W
              {
                // Actually clears the bitmap
#if &_DpaMessage.Request.PData[0] != &bufferRF[0]
#error
#endif
                clearBufferRF();
                // Simulate 1st only sensor in the bitmap (states of the other unimplemented sensors do not care)
                _DpaMessage.Request.PData[0].0 = 1;
                // Bitmap is 32 bits long = 4
                _DpaDataLength = W = 4;
              }

              // Invalid bitmap (data) length (W = _DpaDataLength)?
              if ( W != 4 )
              {
_ERROR_DATA_LEN:
                // Return error
                DpaApiReturnPeripheralError( ERROR_DATA_LEN );
              }

              // Now read the sensors

              // Prepare pointer (minus 1, see below) to store sensor (types and) values to
              // Note: 5 sensors at this example cannot return more than DPA_MAX_DATA_LENGTH bytes of data, so it does not have to be checked...
              // ... If it would be the case, then ERROR_FAIL must be returned
              FSR1 = &_DpaMessage.Response.PData[-1];

              // Store bitmap of sensors to get values from
              uns8	sensorsBitmap = FSR1[1];

              // 1st sensor (index 0) selected?
              if ( sensorsBitmap.0 )
              {
                Get0_Temperature();
                StoreValue( STD_SENSOR_TYPE_TEMPERATURE );
              }

              // 2nd sensor (index 1) selected?
              if ( sensorsBitmap.1 )
              {
                Get1_CO2();
                StoreValue( STD_SENSOR_TYPE_CO2 );
              }

              // 3rd sensor (index 2) selected?
              if ( sensorsBitmap.2 )
              {
                Get2_VOC();
                StoreValue( STD_SENSOR_TYPE_VOC );
              }

              // 4th sensor (index 3) selected?
              if ( sensorsBitmap.3 )
              {
                Get3_Humidity();
                StoreValue( STD_SENSOR_TYPE_HUMIDITY );
              }

              // 5th sensor (index 4) selected?
              if ( sensorsBitmap.4 )
              {
                Get4_Binary7();
                StoreValue( STD_SENSOR_TYPE_BINARYDATA7 );
              }

              // 6th sensor (index 5) selected?
              if ( sensorsBitmap.5 )
              {
                Get5_DataBlock();
                StoreValue( STD_SENSOR_TYPE_DATA_BLOCK );
              }

              // 6th sensor (index 5) selected?
              if ( sensorsBitmap.6 )
              {
                Get6_Binary30();
                StoreValue( STD_SENSOR_TYPE_BINARYDATA30 );
              }

              // Compute returned data bytes count
              W = FSR1L - ( (uns16)&_DpaMessage.Response.PData[0] & 0xFF ) + 1;
              // Optimization: return W long block of bytes at response
_W2_DpaDataLength:
              _DpaDataLength = W;
              goto DpaHandleReturnTRUE;
            }
          }
        }

        break;
      }

      // -------------------------------------------------
    case DpaEvent_Init:
      // Do a one time initialization before main loop starts

      // Setup all free GPIOs as inputs (used at Binary7 simulation)
      TRISA |= 0b0010.0001;
      TRISC |= 0b1111.1100;
      TRISB |= 0b0001.0000;

      break;

      // -------------------------------------------------
    case DpaEvent_FrcValue:
      // Called to get FRC value

      // FSR1 for optimization purposes (avoid MOVLB) will be used to point to DataOutBeforeResponseFRC[0...]
      FSR1 = &DataOutBeforeResponseFRC[0];
      // Check for correct FRC user data
      if ( *FSR1++ /*DataOutBeforeResponseFRC[0]*/ == PNUM_STD_SENSORS )
      {
        // Data and index
        sensorIndexAndData = FSR1[1]; /*DataOutBeforeResponseFRC[2]*/
        // Actually used sensor index
        uns8 sensorIndex = FSR1[1] /*DataOutBeforeResponseFRC[2]*/ & 0x1f;
        // Test sensor type
        switch ( *FSR1++ /*DataOutBeforeResponseFRC[1]*/ )
        {
          default:
            goto DpaHandleReturnFALSE;

            // No type specified, use specified index value
          case 0x00:
            goto _KeepSensorIndex;

            // For other types make the index value based on the requested index value and sensor type
          case STD_SENSOR_TYPE_TEMPERATURE:
            if ( sensorIndex > 0 )
              goto DpaHandleReturnFALSE;
            W = 0;
            break;

          case STD_SENSOR_TYPE_CO2:
            if ( sensorIndex > 0 )
              goto DpaHandleReturnFALSE;
            W = 1;
            break;

          case STD_SENSOR_TYPE_VOC:
            if ( sensorIndex > 0 )
              goto DpaHandleReturnFALSE;
            W = 2;
            break;

          case STD_SENSOR_TYPE_HUMIDITY:
            if ( sensorIndex > 0 )
              goto DpaHandleReturnFALSE;
            W = 3;
            break;

          case STD_SENSOR_TYPE_BINARYDATA7:
            if ( sensorIndex > 0 )
              goto DpaHandleReturnFALSE;
            W = 4;
            break;

          case STD_SENSOR_TYPE_BINARYDATA30:
            if ( sensorIndex > 0 )
              goto DpaHandleReturnFALSE;
            W = 6;
            break;
        }

        // New sensor index based on type and requested index
        sensorIndex = W;
_KeepSensorIndex:

        // Test for supported FRC commands
        switch ( _PCMD )
        {
          default:
            goto DpaHandleReturnFALSE;

          case FRC_STD_SENSORS_BIT:
          case FRC_STD_SENSORS_1B:
          case FRC_STD_SENSORS_2B:
          case FRC_STD_SENSORS_4B:
            switch ( sensorIndex )
            {
              default:
                goto DpaHandleReturnFALSE;

              case 0:
                Carry = Get0_Temperature();
                break;

              case 1:
                Carry = Get1_CO2();
                break;

              case 2:
                Carry = Get2_VOC();
                break;

              case 3:
                Carry = Get3_Humidity();
                break;

              case 4:
                Carry = Get4_Binary7();
                break;

              case 6:
                Carry = Get6_Binary30();
                break;
            }

            // This type of FRC is not valid for the specified sensor
            if ( !Carry )
              goto DpaHandleReturnFALSE;

            break;
        }

        // Some sensor was measured by FRC, check if there is a sleep request
        FSR1++;
        if ( INDF1.0 ) // Note: same as DataOutBeforeResponseFRC[3].0
        {
          // Remember sleep parameters to go to sleep at the Idle event later
          PerOSSleep_Request.Time.low8 = FSR1[4 - 3]; // Note: same as DataOutBeforeResponseFRC[4];
          PerOSSleep_Request.Time.high8 = FSR1[5 - 3]; // Note: same as DataOutBeforeResponseFRC[5];
          PerOSSleep_Request.Control = FSR1[6 - 3]; // Note: same as DataOutBeforeResponseFRC[6];
        }
      }

      break;

      // -------------------------------------------------
    case DpaEvent_FrcResponseTime:
      // Called to get FRC response time

      // In this example the FRC commands are fast 
      switch ( DataOutBeforeResponseFRC[0] )
      {
        case FRC_STD_SENSORS_BIT:
        case FRC_STD_SENSORS_1B:
        case FRC_STD_SENSORS_2B:
        case FRC_STD_SENSORS_4B:
          responseFRCvalue = _FRC_RESPONSE_TIME_40_MS;
          break;
      }
      break;
  }
DpaHandleReturnFALSE:
  return FALSE;
}

//############################################################################################
// Increases FSR1 and then stores the byte
void setPlusPlusINDF1( uns8 data @ W )
//############################################################################################
{
  FSR1++; // Note: must not modify W
  setINDF1( data );
}

//############################################################################################
// Stores measured sensor value byte(s) and optionally sensor type to the FSR[+1...]
void StoreValue( uns8 sensorType )
//############################################################################################
{
  // Is the sensor type to be stored too?
  if ( _PCMD == PCMD_STD_SENSORS_READ_TYPES_AND_VALUES )
    setPlusPlusINDF1( sensorType );

  // Store lower value byte (or length in case of multiple bytes)
  setPlusPlusINDF1( sensorValue.low8 );

  // 2 bytes?
  if ( sensorType.7 == 0 )
  {
    // Store higher value byte
    setPlusPlusINDF1( sensorValue.high8 );
    return;
  }

  // 4 bytes?
  if ( ( sensorType & 0b1110.0000 ) == 0b1010.0000 )
  {
    setPlusPlusINDF1( sensorValue.high8 );
    setPlusPlusINDF1( sensorValueHighWord.low8 );
    setPlusPlusINDF1( sensorValueHighWord.high8 );
    return;
  }

  // Multiple bytes?
  if ( ( sensorType & 0b1100.0000 ) == 0b1100.0000 )
  {
    // Data is expected at bufferINFO, length at sensorValue.low8
    setFSR0( _FSR_INFO );
    do
    {
      // Store all data
      setPlusPlusINDF1( *FSR0++ );
    } while ( --sensorValue.low8 != 0 );
    return;
  }
  }

//############################################################################################
bit setFRCerror()
//############################################################################################
{
#ifndef __CC5XFREE__
  responseFRCvalue4B = 2;
#else
  responseFRCvalue4B.low16 = 2;
  responseFRCvalue4B.high16 = 0;
#endif
  return TRUE;
}

//############################################################################################
// Sensor index 0: measure temperature using the TR sensor
bit Get0_Temperature()
//############################################################################################
{
  // Make sure FSR1 is not modified

  // Measure temperature using TR sensor
  bit sensorError = FALSE;
  // When error, then adjust the standard error values
  if ( getTemperature() == -128 )
  {
    sensorError = TRUE;
    STD_SENSOR_TYPE_TEMPERATURE_SET_ERROR( param3 );
  }

  // Return sensor value
  sensorValue = param3;

  // Test for supported FRC commands
  switch ( _PCMD )
  {
    default:
      return FALSE;

    case FRC_STD_SENSORS_1B:
      // Return sensor FRC value 1B
      // Check for out of limits
      if ( sensorError || (int16)sensorValue > (int16)( 105.5 * 16 ) || (int16)sensorValue < ( (int16)-20 * 16 ) )
        return setFRCerror();

      // Convert to the "F = ( T + 22 ) * 2 " from 1/16 resolution
      uns16 _sensorValue = sensorValue + 4;	// Note: do rounding when /8
      responseFRCvalue = (uns8)( _sensorValue / 8 ) + 44;
      break;

    case FRC_STD_SENSORS_2B:
      // Return sensor FRC value 2B
      if ( sensorError )
        return setFRCerror();

      responseFRCvalue2B = sensorValue ^ 0x8000;
      break;
  }

  return TRUE;
}

//############################################################################################
// Sensor index 1: simulate measuring CO2
bit Get1_CO2()
//############################################################################################
{
  // Make sure FSR1 is not modified

  bit sensorError = FALSE;
  // Fake CO2 return value
  sensorValue = 0x0987;
  // When error, return standard (FRC) error value(s)
  if ( STD_SENSOR_TYPE_CO2_IS_ERROR( sensorValue ) )
    sensorError = TRUE;

  // Test for supported FRC commands
  switch ( _PCMD )
  {
    default:
      return FALSE;

    case FRC_STD_SENSORS_1B:
      // Return sensor FRC value 1B
      // Check for out of limits
      if ( sensorError || sensorValue > 4016 )
        return setFRCerror();

      responseFRCvalue = sensorValue / 16 + 4;
      break;

    case FRC_STD_SENSORS_2B:
      // Return sensor FRC value 2B
      if ( sensorError )
        return setFRCerror();

      responseFRCvalue2B = sensorValue + 4;
      break;
  }

  return TRUE;
}

//############################################################################################
// Sensor index 2: simulate measuring VOC
bit Get2_VOC()
//############################################################################################
{
  // Make sure FSR1 is not modified

  bit sensorError = FALSE;
  // Fake VOC return value
  sensorValue = 0x0123;
  // When error, return standard (FRC) error value(s)
  if ( STD_SENSOR_TYPE_VOC_IS_ERROR( sensorValue ) )
    sensorError = TRUE;

  // Test for supported FRC commands
  switch ( _PCMD )
  {
    default:
      return FALSE;

    case FRC_STD_SENSORS_1B:
      // Return sensor FRC value 1B
      // Check for out of limits
      if ( sensorError || sensorValue > 4016 )
        return setFRCerror();

      responseFRCvalue = sensorValue / 16 + 4;
      break;

    case FRC_STD_SENSORS_2B:
      // Return sensor FRC value 2B
      if ( sensorError )
        return setFRCerror();

      responseFRCvalue2B = sensorValue + 4;
      break;
  }

  return TRUE;
}

//############################################################################################
// Sensor index 3: simulate measuring humidity
bit Get3_Humidity()
//############################################################################################
{
  // Make sure FSR1 is not modified

  // Fake humidity return value
  sensorValue.low8 = lastRSSI & 0x7F;

  // Test for supported FRC commands
  switch ( _PCMD )
  {
    default:
      return FALSE;

    case FRC_STD_SENSORS_1B:
      // Return sensor FRC value 1B
      if ( STD_SENSOR_TYPE_HUMIDITY_IS_ERROR( sensorValue.low8 ) )
        return setFRCerror();

      responseFRCvalue = sensorValue.low8 + 4;
      break;
  }
  return TRUE;
}

//############################################################################################
// Sensor index 4: simulate binary data
bit Get4_Binary7()
//############################################################################################
{
  // Make sure FSR1 is not modified

  bit sensorError = FALSE;
  // Fake humidity return value
  sensorValue.low8 = 0;

  // Get bits from the available user GPIO inputs (DDC-IO-01 can be used for the simulation)
  if ( PORTA.0 )  // SIM C1
    sensorValue.0 = 1;
  if ( PORTC.2 )  // SIM C2
    sensorValue.1 = 1;
  if ( PORTA.5 )  // SIM C5
    sensorValue.2 = 1;
  if ( PORTC.3 )  // SIM C6
    sensorValue.3 = 1;
  if ( PORTC.4 )  // SIM C7
    sensorValue.4 = 1;
  if ( PORTC.5 )  // SIM C8
    sensorValue.5 = 1;

  // When error, return standard (FRC) error value(s)
  if ( STD_SENSOR_TYPE_BINARYDATA7_IS_ERROR( sensorValue.low8 ) )
    sensorError = TRUE;

  // Test for supported FRC commands
  switch ( _PCMD )
  {
    default:
      return FALSE;

    case FRC_STD_SENSORS_BIT:
      // If there is a sensor error, 2-bit FRC cannot indicate it, it returns [01]
      if ( !sensorError )
      {
        // Number of shifts to get the bit out of the return value
        uns8 bitLoop = ( INDF1 >> 5 ) + 1;
        // Value to get the bit from
        W = sensorValue.low8;
        do
        {
          // Get the bit to Carry
          W = rr( W );
          // Next bit
        } while ( --bitLoop != 0 ); // Note: must not modify W and Carry
        // Current (prepared by DPA) FRC value is [01], change it to [11] (means bit is set)
        responseFRCvalue.1 = 1; // Note: must not modify Carry
        // Is bit set?
        if ( !Carry )
          // Bit is NOT set, return [10]
          responseFRCvalue.0 = 0;
      }
      break;

    case FRC_STD_SENSORS_1B:
      // Return sensor FRC value 1B
      if ( sensorError )
        return setFRCerror();

      responseFRCvalue = sensorValue.low8 + 4;
      break;
  }
  return TRUE;
}

//############################################################################################
// Sensor index 5: simulate data block
bit Get5_DataBlock()
//############################################################################################
{
  // Make sure FSR1 is not modified
  uns16 saveFSR1 = FSR1;

  // Get data to bufferINFO
  moduleInfo();
  // Return length
  sensorValue.low8 = sizeof( TModuleInfo );

  FSR1 = saveFSR1;
  return FALSE;
}

//############################################################################################
// Sensor index 6: simulate 30 bit data
bit Get6_Binary30()
//############################################################################################
{
  // Make sure FSR1 is not modified
  uns16 saveFSR1 = FSR1;
  moduleInfo();
  sensorValue.low8 = ModuleInfo.MID[0];
  sensorValue.high8 = ModuleInfo.MID[1];
  sensorValueHighWord.low8 = ModuleInfo.MID[2];
  sensorValueHighWord.high8 = ModuleInfo.MID[3];
  FSR1 = saveFSR1;

  responseFRCvalue4B.low16 = sensorValue;
  responseFRCvalue4B.high16 = sensorValueHighWord;

  // Test for supported FRC commands
  switch ( _PCMD )
  {
    default:
      return FALSE;

    case FRC_STD_SENSORS_2B:
      if ( ( sensorIndexAndData & 0b10.0000 ) != 0 )
#ifndef __CC5XFREE__
        responseFRCvalue4B >>= 15;
#else
      {
        // Carry = responseFRCvalue4B.15
        W = rl( responseFRCvalue4B.midH8 );
        responseFRCvalue4B.midL8 = rl( responseFRCvalue4B.midL8 );
        responseFRCvalue4B.low8 = rl( responseFRCvalue4B.low8 );
        responseFRCvalue4B.low16 = responseFRCvalue4B.high16;
      }
#endif

      responseFRCvalue2B.15 = 0;
      responseFRCvalue2B += 4;
      break;

    case FRC_STD_SENSORS_4B:
#ifndef __CC5XFREE__
      responseFRCvalue4B += 4;
#else
      W = 4;
      responseFRCvalue4B.low8 += W;
      W = 0;
      responseFRCvalue4B.midL8 = addWFC( responseFRCvalue4B.midL8 );
      responseFRCvalue4B.midH8 = addWFC( responseFRCvalue4B.midH8 );
      responseFRCvalue4B.high8 = addWFC( responseFRCvalue4B.high8 );
#endif
      break;
  }
  return TRUE;
}
//############################################################################################

// Default Custom DPA Handler header; 2nd include to implement Code bumper to detect too long code of the Custom DPA Handler (modify the path according to your setup) 
#include "DPAcustomHandler.h"
//############################################################################################
