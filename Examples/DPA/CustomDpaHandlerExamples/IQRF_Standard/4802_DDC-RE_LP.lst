CC5X Version 3.7D,   File: D:\DP\IQRF_Startup_Package_OS403D_TR-7xD_200302\IQRF_OS403_7xD\Examples\DPA\CustomDpaHandlerExamples\IQRF_Standard\4802_DDC-RE_LP.c 28. Mar 2020  11:19   Page 1

ADDR CODE  LINE SOURCE

           0001 
           0002 ; CC5X Version 3.7D, Copyright (c) B Knudsen Data
           0003 ; C compiler for the PICmicro family
           0004 ; ************  28. Mar 2020  11:19  *************
           0005 
           0006         processor  16F1938
           0007         radix  DEC
           0008 
     0000  0009 INDF0       EQU   0x00
     0001  0010 INDF1       EQU   0x01
     0006  0011 FSR1        EQU   0x06
     0000  0012 Carry       EQU   0
     0002  0013 Zero_       EQU   2
     008E  0014 TRISC       EQU   0x8E
     010E  0015 LATC        EQU   0x10E
     0070  0016 userReg0    EQU   0x70
     0074  0017 param3      EQU   0x74
     02A1  0018 DLEN        EQU   0x2A1
     02AE  0019 PNUM        EQU   0x2AE
     02AF  0020 PCMD        EQU   0x2AF
     04A0  0021 DpaRfMessage EQU   0x4A0
     0073  0022 par1        EQU   0x73
     04A0  0023 _DpaMessageIqrfStd EQU   0x4A0
     05C0  0024 index       EQU   0x5C0
     05C1  0025 timer       EQU   0x5C1
     05C3  0026 timerStart  EQU   0x5C3
     05C0  0027 inBitmap    EQU   0x5C0
     04A0  0028 outBitmap   EQU   0x4A0
     05C1  0029 bitmapMask  EQU   0x5C1
     05C2  0030 outputsCount EQU   0x5C2
     05C3  0031 index_2     EQU   0x5C3
     05C4  0032 byte        EQU   0x5C4
     05C4  0033 time        EQU   0x5C4
     05C6  0034 state       EQU   0x5C6
     05C7  0035 coef        EQU   0x5C7
     05C9  0036 coef_2      EQU   0x5C9
     05C9  0037 C1cnt       EQU   0x5C9
     05CA  0038 C2tmp       EQU   0x5CA
     05C7  0039 state_2     EQU   0x5C7
           0040 
0000 2900  0041         GOTO main
           0042 
           0043   ; FILE ../../../../Development/include/IQRF_OS/IQRF.h
           0044                         ;// *********************************************************************
           0045                         ;// *                   IQRF OS basic include file                      *
           0046                         ;// *********************************************************************
           0047                         ;//
           0048                         ;// Online IQRF OS Reference Guide: http://www.iqrf.org/IQRF-OS-Reference-guide/
           0049                         ;//
           0050                         ;// Copyright (c) IQRF Tech s.r.o.
           0051                         ;//
           0052                         ;// Intended for:
           0053                         ;//	 HW: TR-72D, TR-76D, TR-77D, TR-78D, TR-75D
           0054                         ;//   OS: v4.03D
           0055                         ;//
           0056                         ;// File:    IQRF.h
           0057                         ;// Version: v1.00                                   Revision: 10/05/2018
           0058                         ;//
           0059                         ;// Revision history:
           0060                         ;//	 v1.00: 10/05/2018 	First release for OS 4.03D.
           0061                         ;//
           0062                         ;// *********************************************************************
           0063                         ;
           0064                         ;#if IQRFOS != 403
           0065                         ;    #error Invalid IQRF OS version, V4.03 is expected. Make sure matching header files and project IQRF OS version setting are used.
           0066                         ;#endif
           0067                         ;
           0068                         ;#if defined TR72D
           0069                         ;    #message Compilation for TR-72D modules (PIC16LF1938) and IQRF OS 4.03D.
           0070                         ;    #define TR7xD
           0071                         ;#elif defined TR76D
           0072                         ;    #message Compilation for TR-76D modules (PIC16LF1938) and IQRF OS 4.03D.
           0073                         ;    #define TR7xD
           0074                         ;#elif defined TR77D
           0075                         ;    #message Compilation for TR-77D modules (PIC16LF1938) and IQRF OS 4.03D.
           0076                         ;    #define TR7xD
           0077                         ;#elif defined TR78D
           0078                         ;    #message Compilation for TR-78D modules (PIC16LF1938) and IQRF OS 4.03D.
           0079                         ;    #define TR7xD
           0080                         ;#elif defined TR75D
           0081                         ;    #message Compilation for TR-75D modules (PIC16LF1938) and IQRF OS 4.03D.
           0082                         ;    #define TR7xD
           0083                         ;#else
           0084                         ;    #error Unsupported TR module type.
           0085                         ;#endif
           0086                         ;
           0087                         ;#pragma chip PIC16F1938
           0088                         ;
           0089                         ;#if __CC5X__ < 3701
           0090                         ;    #warning Insufficient CC5X compiler version, V3.7A is recommended.
           0091                         ;#endif
           0092                         ;
           0093                         ;#pragma origin 0x100
     0000  0094         ORG 0x0100
           0095                         ;#pragma update_RP 0
           0096                         ;
           0097                         ;void APPLICATION();
           0098                         ;
           0099                         ;void main()                                	// Skipped during Upload
           0100                         ;{
           0101 main
           0102                         ;    APPLICATION();
0100 31B8  0103         MOVLP 0x38
0101 2200  0104         CALL  APPLICATION
0102 3180  0105         MOVLP 0x00
           0106                         ;}
0103 0063  0107         SLEEP
0104 2900  0108         GOTO main
           0109 
           0110   ; FILE ../../../../Development/include/IQRF_OS/IQRF-functions.h
           0111                         ;// *********************************************************************
           0112                         ;//      				   IQRF OS functions						   *
           0113                         ;// *********************************************************************
           0114                         ;// Intended for:
           0115                         ;//    OS: v4.03D
           0116                         ;//
           0117                         ;// Online IQRF OS Reference Guide: http://www.iqrf.org/IQRF-OS-Reference-guide/
           0118                         ;//
           0119                         ;// Copyright (c) IQRF Tech s.r.o.
           0120                         ;//
           0121                         ;// File:    IQRF-functions.h
           0122                         ;// Version: v1.00                                   Revision: 27/06/2018
           0123                         ;//
           0124                         ;// Revision history:
           0125                         ;//   v1.00: 27/06/2018  First release for OS 4.03D.
           0126                         ;//
           0127                         ;// *********************************************************************
           0128                         ; 
           0129                         ;#pragma optimize 0
           0130                         ;#pragma update_PAGE 0
           0131                         ;#pragma update_RP 0
           0132                         ;
           0133                         ;#define	dummy_address	0x3810
           0134                         ;#pragma origin dummy_address
     0000  0135         ORG 0x3810
           0136                         ;void dummy()
           0137                         ;{
           0138 dummy
           0139                         ;  #asm
           0140                         ;    DW 0x2000
3810 2000  0141         DW    0x2000
           0142                         ;  #endasm
           0143                         ;  #pragma updateBank exit=UserBank_01
           0144                         ;}
3811 0008  0145         RETURN
           0146                         ;
           0147                         ;#define	iqrfSleep_address	0x3816
           0148                         ;#pragma origin iqrfSleep_address
     0000  0149         ORG 0x3816
           0150                         ;void iqrfSleep()
           0151                         ;{
           0152 iqrfSleep
           0153                         ;  #asm
           0154                         ;    DW 0x2000
3816 2000  0155         DW    0x2000
           0156                         ;  #endasm
           0157                         ;  #pragma updateBank exit=UserBank_01
           0158                         ;}
3817 0008  0159         RETURN
           0160                         ;
           0161                         ;#define	_debug_address	0x3819
           0162                         ;#pragma origin _debug_address
     0000  0163         ORG 0x3819
           0164                         ;void _debug()
           0165                         ;{
           0166 _debug
           0167                         ;  #asm
           0168                         ;    DW 0x2000
3819 2000  0169         DW    0x2000
           0170                         ;  #endasm
           0171                         ;  #pragma updateBank exit=UserBank_01
           0172                         ;}
381A 0008  0173         RETURN
           0174                         ;
           0175                         ;#define debug()	    \
           0176                         ;	do {			\
           0177                         ;		_debug();	\
           0178                         ;        nop();      \
           0179                         ;	} while (0)
           0180                         ;
           0181                         ;#define	moduleInfo_address	0x381c
           0182                         ;#pragma origin moduleInfo_address
     0000  0183         ORG 0x381C
           0184                         ;void moduleInfo()
           0185                         ;{
           0186 moduleInfo
           0187                         ;  #asm
           0188                         ;    DW 0x2000
381C 2000  0189         DW    0x2000
           0190                         ;  #endasm
           0191                         ;  #pragma updateBank exit=UserBank_01
           0192                         ;}
381D 0008  0193         RETURN
           0194                         ;
           0195                         ;#define	pulsingLEDR_address	0x3822
           0196                         ;#pragma origin pulsingLEDR_address
     0000  0197         ORG 0x3822
           0198                         ;void pulsingLEDR()
           0199                         ;{
           0200 pulsingLEDR
           0201                         ;  #asm
           0202                         ;    DW 0x2000
3822 2000  0203         DW    0x2000
           0204                         ;  #endasm
           0205                         ;  #pragma updateBank exit=UserBank_01
           0206                         ;}
3823 0008  0207         RETURN
           0208                         ;
           0209                         ;#define	pulseLEDR_address	0x3825
           0210                         ;#pragma origin pulseLEDR_address
     0000  0211         ORG 0x3825
           0212                         ;void pulseLEDR()
           0213                         ;{
           0214 pulseLEDR
           0215                         ;  #asm
           0216                         ;    DW 0x2000
3825 2000  0217         DW    0x2000
           0218                         ;  #endasm
           0219                         ;  #pragma updateBank exit=UserBank_01
           0220                         ;}
3826 0008  0221         RETURN
           0222                         ;
           0223                         ;#define	stopLEDR_address	0x3828
           0224                         ;#pragma origin stopLEDR_address
     0000  0225         ORG 0x3828
           0226                         ;void stopLEDR()
           0227                         ;{
           0228 stopLEDR
           0229                         ;  #asm
           0230                         ;    DW 0x2000
3828 2000  0231         DW    0x2000
           0232                         ;  #endasm
           0233                         ;  #pragma updateBank exit=UserBank_01
           0234                         ;}
3829 0008  0235         RETURN
           0236                         ;
           0237                         ;#define	pulsingLEDG_address	0x382b
           0238                         ;#pragma origin pulsingLEDG_address
     0000  0239         ORG 0x382B
           0240                         ;void pulsingLEDG()
           0241                         ;{
           0242 pulsingLEDG
           0243                         ;  #asm
           0244                         ;    DW 0x2000
382B 2000  0245         DW    0x2000
           0246                         ;  #endasm
           0247                         ;  #pragma updateBank exit=UserBank_01
           0248                         ;}
382C 0008  0249         RETURN
           0250                         ;
           0251                         ;#define	pulseLEDG_address	0x382e
           0252                         ;#pragma origin pulseLEDG_address
     0000  0253         ORG 0x382E
           0254                         ;void pulseLEDG()
           0255                         ;{
           0256 pulseLEDG
           0257                         ;  #asm
           0258                         ;    DW 0x2000
382E 2000  0259         DW    0x2000
           0260                         ;  #endasm
           0261                         ;  #pragma updateBank exit=UserBank_01
           0262                         ;}
382F 0008  0263         RETURN
           0264                         ;
           0265                         ;#define	stopLEDG_address	0x3831
           0266                         ;#pragma origin stopLEDG_address
     0000  0267         ORG 0x3831
           0268                         ;void stopLEDG()
           0269                         ;{
           0270 stopLEDG
           0271                         ;  #asm
           0272                         ;    DW 0x2000
3831 2000  0273         DW    0x2000
           0274                         ;  #endasm
           0275                         ;  #pragma updateBank exit=UserBank_01
           0276                         ;}
3832 0008  0277         RETURN
           0278                         ;
           0279                         ;#define	setOnPulsingLED_address	0x3834
           0280                         ;#pragma origin setOnPulsingLED_address
     0000  0281         ORG 0x3834
           0282                         ;void setOnPulsingLED(uns8 ticks @ W)
           0283                         ;{
           0284 setOnPulsingLED
           0285                         ;  #asm
           0286                         ;    DW 0x2000
3834 2000  0287         DW    0x2000
           0288                         ;  #endasm
           0289                         ;  #pragma updateBank exit=UserBank_01
           0290                         ;}
3835 0008  0291         RETURN
           0292                         ;
           0293                         ;#define	setOffPulsingLED_address	0x3837
           0294                         ;#pragma origin setOffPulsingLED_address
     0000  0295         ORG 0x3837
           0296                         ;void setOffPulsingLED(uns8 ticks @ W)
           0297                         ;{
           0298 setOffPulsingLED
           0299                         ;  #asm
           0300                         ;    DW 0x2000
3837 2000  0301         DW    0x2000
           0302                         ;  #endasm
           0303                         ;  #pragma updateBank exit=UserBank_01
           0304                         ;}
3838 0008  0305         RETURN
           0306                         ;
           0307                         ;#define	eeReadByte_address	0x383a
           0308                         ;#pragma origin eeReadByte_address
     0000  0309         ORG 0x383A
           0310                         ;uns8 eeReadByte(uns8 address @ W)
           0311                         ;{
           0312 eeReadByte
           0313                         ;  #asm
           0314                         ;    DW 0x2000
383A 2000  0315         DW    0x2000
           0316                         ;  #endasm
           0317                         ;  #pragma updateBank exit=UserBank_01
           0318                         ;  return 1;
383B 3401  0319         RETLW 0x01
           0320                         ;}
           0321                         ;
           0322                         ;#define	eeReadData_address	0x383d
           0323                         ;#pragma origin eeReadData_address
     0000  0324         ORG 0x383D
           0325                         ;bit eeReadData(uns8 address @ param2, uns8 length @ W)
           0326                         ;{
           0327 eeReadData
           0328                         ;  #asm
           0329                         ;    DW 0x2000
383D 2000  0330         DW    0x2000
           0331                         ;  #endasm
           0332                         ;  #pragma updateBank exit=UserBank_01
           0333                         ;  return Carry;
383E 0008  0334         RETURN
           0335                         ;}
           0336                         ;
           0337                         ;#define	eeWriteByte_address	0x3840
           0338                         ;#pragma origin eeWriteByte_address
     0000  0339         ORG 0x3840
           0340                         ;void eeWriteByte(uns8 address @ param2, uns8 data @ W)
           0341                         ;{
           0342 eeWriteByte
           0343                         ;  #asm
           0344                         ;    DW 0x2000
3840 2000  0345         DW    0x2000
           0346                         ;  #endasm
           0347                         ;  #pragma updateBank exit=UserBank_01
           0348                         ;}
3841 0008  0349         RETURN
           0350                         ;
           0351                         ;#define	eeWriteData_address	0x3843
           0352                         ;#pragma origin eeWriteData_address
     0000  0353         ORG 0x3843
           0354                         ;void eeWriteData(uns8 address @ param2, uns8 length @ W)
           0355                         ;{
           0356 eeWriteData
           0357                         ;  #asm
           0358                         ;    DW 0x2000
3843 2000  0359         DW    0x2000
           0360                         ;  #endasm
           0361                         ;  #pragma updateBank exit=UserBank_01
           0362                         ;}
3844 0008  0363         RETURN
           0364                         ;
           0365                         ;#define	readFromRAM_address	0x3846
           0366                         ;#pragma origin readFromRAM_address
     0000  0367         ORG 0x3846
           0368                         ;uns8 readFromRAM(uns16 address @ FSR0)
           0369                         ;{
           0370 readFromRAM
           0371                         ;  #asm
           0372                         ;    DW 0x2000
3846 2000  0373         DW    0x2000
           0374                         ;  #endasm
           0375                         ;  #pragma updateBank exit=UserBank_01
           0376                         ;  return 1;
3847 3401  0377         RETLW 0x01
           0378                         ;}
           0379                         ;
           0380                         ;#define	clearBufferINFO_address	0x384c
           0381                         ;#pragma origin clearBufferINFO_address
     0000  0382         ORG 0x384C
           0383                         ;void clearBufferINFO()
           0384                         ;{
           0385 clearBufferINFO
           0386                         ;  #asm
           0387                         ;    DW 0x2000
384C 2000  0388         DW    0x2000
           0389                         ;  #endasm
           0390                         ;  #pragma updateBank exit=UserBank_01
           0391                         ;}
384D 0008  0392         RETURN
           0393                         ;
           0394                         ;#define	swapBufferINFO_address	0x384f
           0395                         ;#pragma origin swapBufferINFO_address
     0000  0396         ORG 0x384F
           0397                         ;void swapBufferINFO()
           0398                         ;{
           0399 swapBufferINFO
           0400                         ;  #asm
           0401                         ;    DW 0x2000
384F 2000  0402         DW    0x2000
           0403                         ;  #endasm
           0404                         ;  #pragma updateBank exit=UserBank_01
           0405                         ;}
3850 0008  0406         RETURN
           0407                         ;
           0408                         ;#define	compareBufferINFO2RF_address	0x3852
           0409                         ;#pragma origin compareBufferINFO2RF_address
     0000  0410         ORG 0x3852
           0411                         ;bit compareBufferINFO2RF(uns8 length @ W)
           0412                         ;{
           0413 compareBufferINFO2RF
           0414                         ;  #asm
           0415                         ;    DW 0x2000
3852 2000  0416         DW    0x2000
           0417                         ;  #endasm
           0418                         ;  #pragma updateBank exit=UserBank_01
           0419                         ;  return Carry;
3853 0008  0420         RETURN
           0421                         ;}
           0422                         ;
           0423                         ;#define	copyBufferINFO2COM_address	0x3855
           0424                         ;#pragma origin copyBufferINFO2COM_address
     0000  0425         ORG 0x3855
           0426                         ;void copyBufferINFO2COM()
           0427                         ;{
           0428 copyBufferINFO2COM
           0429                         ;  #asm
           0430                         ;    DW 0x2000
3855 2000  0431         DW    0x2000
           0432                         ;  #endasm
           0433                         ;  #pragma updateBank exit=UserBank_01
           0434                         ;}
3856 0008  0435         RETURN
           0436                         ;
           0437                         ;#define	copyBufferINFO2RF_address	0x3858
           0438                         ;#pragma origin copyBufferINFO2RF_address
     0000  0439         ORG 0x3858
           0440                         ;void copyBufferINFO2RF()
           0441                         ;{
           0442 copyBufferINFO2RF
           0443                         ;  #asm
           0444                         ;    DW 0x2000
3858 2000  0445         DW    0x2000
           0446                         ;  #endasm
           0447                         ;  #pragma updateBank exit=UserBank_01
           0448                         ;}
3859 0008  0449         RETURN
           0450                         ;
           0451                         ;#define	copyBufferRF2COM_address	0x385b
           0452                         ;#pragma origin copyBufferRF2COM_address
     0000  0453         ORG 0x385B
           0454                         ;void copyBufferRF2COM()
           0455                         ;{
           0456 copyBufferRF2COM
           0457                         ;  #asm
           0458                         ;    DW 0x2000
385B 2000  0459         DW    0x2000
           0460                         ;  #endasm
           0461                         ;  #pragma updateBank exit=UserBank_01
           0462                         ;}
385C 0008  0463         RETURN
           0464                         ;
           0465                         ;#define	copyBufferRF2INFO_address	0x385e
           0466                         ;#pragma origin copyBufferRF2INFO_address
     0000  0467         ORG 0x385E
           0468                         ;void copyBufferRF2INFO()
           0469                         ;{
           0470 copyBufferRF2INFO
           0471                         ;  #asm
           0472                         ;    DW 0x2000
385E 2000  0473         DW    0x2000
           0474                         ;  #endasm
           0475                         ;  #pragma updateBank exit=UserBank_01
           0476                         ;}
385F 0008  0477         RETURN
           0478                         ;
           0479                         ;#define	copyBufferCOM2RF_address	0x3861
           0480                         ;#pragma origin copyBufferCOM2RF_address
     0000  0481         ORG 0x3861
           0482                         ;void copyBufferCOM2RF()
           0483                         ;{
           0484 copyBufferCOM2RF
           0485                         ;  #asm
           0486                         ;    DW 0x2000
3861 2000  0487         DW    0x2000
           0488                         ;  #endasm
           0489                         ;  #pragma updateBank exit=UserBank_01
           0490                         ;}
3862 0008  0491         RETURN
           0492                         ;
           0493                         ;#define	copyBufferCOM2INFO_address	0x3864
           0494                         ;#pragma origin copyBufferCOM2INFO_address
     0000  0495         ORG 0x3864
           0496                         ;void copyBufferCOM2INFO()
           0497                         ;{
           0498 copyBufferCOM2INFO
           0499                         ;  #asm
           0500                         ;    DW 0x2000
3864 2000  0501         DW    0x2000
           0502                         ;  #endasm
           0503                         ;  #pragma updateBank exit=UserBank_01
           0504                         ;}
3865 0008  0505         RETURN
           0506                         ;
           0507                         ;#define	copyMemoryBlock_address	0x3867
           0508                         ;#pragma origin copyMemoryBlock_address
     0000  0509         ORG 0x3867
           0510                         ;void copyMemoryBlock(uns16 from @ FSR0, uns16 to @ FSR1, uns8 length @ W)
           0511                         ;{
           0512 copyMemoryBlock
           0513                         ;  #asm
           0514                         ;    DW 0x2000
3867 2000  0515         DW    0x2000
           0516                         ;  #endasm
           0517                         ; #pragma updateBank exit=UserBank_01
           0518                         ;}
3868 0008  0519         RETURN
           0520                         ;
           0521                         ;#define	startDelay_address	0x386a
           0522                         ;#pragma origin startDelay_address
     0000  0523         ORG 0x386A
           0524                         ;void startDelay(uns8 ticks @ W)
           0525                         ;{
           0526 startDelay
           0527                         ;  #asm
           0528                         ;    DW 0x2000
386A 2000  0529         DW    0x2000
           0530                         ;  #endasm
           0531                         ;  #pragma updateBank exit=UserBank_01
           0532                         ;}
386B 0008  0533         RETURN
           0534                         ;
           0535                         ;#define	startLongDelay_address	0x386d
           0536                         ;#pragma origin startLongDelay_address
     0000  0537         ORG 0x386D
           0538                         ;void startLongDelay(uns16 ticks @ param3)
           0539                         ;{
           0540 startLongDelay
           0541                         ;  #asm
           0542                         ;    DW 0x2000
386D 2000  0543         DW    0x2000
           0544                         ;  #endasm
           0545                         ;  #pragma updateBank exit=UserBank_01
           0546                         ;}
386E 0008  0547         RETURN
           0548                         ;
           0549                         ;#define	isDelay_address	0x3870
           0550                         ;#pragma origin isDelay_address
     0000  0551         ORG 0x3870
           0552                         ;bit isDelay()
           0553                         ;{
           0554 isDelay
           0555                         ;  #asm
           0556                         ;    DW 0x2000
3870 2000  0557         DW    0x2000
           0558                         ;  #endasm
           0559                         ;  #pragma updateBank exit=UserBank_01
           0560                         ;  return Carry;
3871 0008  0561         RETURN
           0562                         ;}
           0563                         ;
           0564                         ;#define	waitDelay_address	0x3873
           0565                         ;#pragma origin waitDelay_address
     0000  0566         ORG 0x3873
           0567                         ;void waitDelay(uns8 ticks @ W)
           0568                         ;{
           0569 waitDelay
           0570                         ;  #asm
           0571                         ;    DW 0x2000
3873 2000  0572         DW    0x2000
           0573                         ;  #endasm
           0574                         ;  #pragma updateBank exit=UserBank_01
           0575                         ;}
3874 0008  0576         RETURN
           0577                         ;
           0578                         ;#define	waitMS_address	0x3876
           0579                         ;#pragma origin waitMS_address
     0000  0580         ORG 0x3876
           0581                         ;void waitMS(uns8 ms @ W)
           0582                         ;{
           0583 waitMS
           0584                         ;  #asm
           0585                         ;    DW 0x2000
3876 2000  0586         DW    0x2000
           0587                         ;  #endasm
           0588                         ;  #pragma updateBank exit=UserBank_01
           0589                         ;}
3877 0008  0590         RETURN
           0591                         ;
           0592                         ;#define	startCapture_address	0x3879
           0593                         ;#pragma origin startCapture_address
     0000  0594         ORG 0x3879
           0595                         ;void startCapture()
           0596                         ;{
           0597 startCapture
           0598                         ;  #asm
           0599                         ;    DW 0x2000
3879 2000  0600         DW    0x2000
           0601                         ;  #endasm
           0602                         ;  #pragma updateBank exit=UserBank_01
           0603                         ;}
387A 0008  0604         RETURN
           0605                         ;
           0606                         ;#define	captureTicks_address	0x387c
           0607                         ;#pragma origin captureTicks_address
     0000  0608         ORG 0x387C
           0609                         ;void captureTicks()
           0610                         ;{
           0611 captureTicks
           0612                         ;  #asm
           0613                         ;    DW 0x2000
387C 2000  0614         DW    0x2000
           0615                         ;  #endasm
           0616                         ;  #pragma updateBank exit=UserBank_01
           0617                         ;}
387D 0008  0618         RETURN
           0619                         ;
           0620                         ;#define	waitNewTick_address	0x3882
           0621                         ;#pragma origin waitNewTick_address
     0000  0622         ORG 0x3882
           0623                         ;void waitNewTick()
           0624                         ;{
           0625 waitNewTick
           0626                         ;  #asm
           0627                         ;    DW 0x2000
3882 2000  0628         DW    0x2000
           0629                         ;  #endasm
           0630                         ;  #pragma updateBank exit=UserBank_01
           0631                         ;}
3883 0008  0632         RETURN
           0633                         ;
           0634                         ;#define	enableSPI_address	0x3885
           0635                         ;#pragma origin enableSPI_address
     0000  0636         ORG 0x3885
           0637                         ;void enableSPI()
           0638                         ;{
           0639 enableSPI
           0640                         ;  #asm
           0641                         ;    DW 0x2000
3885 2000  0642         DW    0x2000
           0643                         ;  #endasm
           0644                         ;  #pragma updateBank exit=UserBank_01
           0645                         ;}
3886 0008  0646         RETURN
           0647                         ;
           0648                         ;#define	disableSPI_address	0x3888
           0649                         ;#pragma origin disableSPI_address
     0000  0650         ORG 0x3888
           0651                         ;void disableSPI()
           0652                         ;{
           0653 disableSPI
           0654                         ;  #asm
           0655                         ;    DW 0x2000
3888 2000  0656         DW    0x2000
           0657                         ;  #endasm
           0658                         ;  #pragma updateBank exit=UserBank_01
           0659                         ;}
3889 0008  0660         RETURN
           0661                         ;
           0662                         ;#define	startSPI_address	0x388b
           0663                         ;#pragma origin startSPI_address
     0000  0664         ORG 0x388B
           0665                         ;void startSPI(uns8 length @ W)
           0666                         ;{
           0667 startSPI
           0668                         ;  #asm
           0669                         ;    DW 0x2000
388B 2000  0670         DW    0x2000
           0671                         ;  #endasm
           0672                         ;  #pragma updateBank exit=UserBank_01
           0673                         ;}
388C 0008  0674         RETURN
           0675                         ;
           0676                         ;#define	stopSPI_address	0x388e
           0677                         ;#pragma origin stopSPI_address
     0000  0678         ORG 0x388E
           0679                         ;void stopSPI()
           0680                         ;{
           0681 stopSPI
           0682                         ;  #asm
           0683                         ;    DW 0x2000
388E 2000  0684         DW    0x2000
           0685                         ;  #endasm
           0686                         ;  #pragma updateBank exit=UserBank_01
           0687                         ;}
388F 0008  0688         RETURN
           0689                         ;
           0690                         ;#define	restartSPI_address	0x3891
           0691                         ;#pragma origin restartSPI_address
     0000  0692         ORG 0x3891
           0693                         ;void restartSPI()
           0694                         ;{
           0695 restartSPI
           0696                         ;  #asm
           0697                         ;    DW 0x2000
3891 2000  0698         DW    0x2000
           0699                         ;  #endasm
           0700                         ;  #pragma updateBank exit=UserBank_01
           0701                         ;}
3892 0008  0702         RETURN
           0703                         ;
           0704                         ;#define	getStatusSPI_address	0x3894
           0705                         ;#pragma origin getStatusSPI_address
     0000  0706         ORG 0x3894
           0707                         ;bit getStatusSPI()
           0708                         ;{
           0709 getStatusSPI
           0710                         ;  #asm
           0711                         ;    DW 0x2000
3894 2000  0712         DW    0x2000
           0713                         ;  #endasm
           0714                         ;  #pragma updateBank exit=UserBank_01
           0715                         ;  return Carry;
3895 0008  0716         RETURN
           0717                         ;}
           0718                         ;
           0719                         ;#define	setRFpower_address	0x3897
           0720                         ;#pragma origin setRFpower_address
     0000  0721         ORG 0x3897
           0722                         ;void setRFpower(uns8 level @ W)
           0723                         ;{
           0724 setRFpower
           0725                         ;  #asm
           0726                         ;    DW 0x2000
3897 2000  0727         DW    0x2000
           0728                         ;  #endasm
           0729                         ;  #pragma updateBank exit=UserBank_01
           0730                         ;}
3898 0008  0731         RETURN
           0732                         ;
           0733                         ;#define	setLEDG_address	0x389a
           0734                         ;#pragma origin setLEDG_address
     0000  0735         ORG 0x389A
           0736                         ;void setLEDG()
           0737                         ;{
           0738 setLEDG
           0739                         ;  #asm
           0740                         ;    DW 0x2000
389A 2000  0741         DW    0x2000
           0742                         ;  #endasm
           0743                         ;  #pragma updateBank exit=UserBank_01
           0744                         ;}
389B 0008  0745         RETURN
           0746                         ;
           0747                         ;#define	setRFchannel_address	0x389d
           0748                         ;#pragma origin setRFchannel_address
     0000  0749         ORG 0x389D
           0750                         ;void setRFchannel(uns8 channel @ W)
           0751                         ;{
           0752 setRFchannel
           0753                         ;  #asm
           0754                         ;    DW 0x2000
389D 2000  0755         DW    0x2000
           0756                         ;  #endasm
           0757                         ;  #pragma updateBank exit=UserBank_01
           0758                         ;}
389E 0008  0759         RETURN
           0760                         ;
           0761                         ;#define	setRFmode_address	0x38a0
           0762                         ;#pragma origin setRFmode_address
     0000  0763         ORG 0x38A0
           0764                         ;void setRFmode(uns8 mode @ W)
           0765                         ;{
           0766 setRFmode
           0767                         ;  #asm
           0768                         ;    DW 0x2000
38A0 2000  0769         DW    0x2000
           0770                         ;  #endasm
           0771                         ;  #pragma updateBank exit=UserBank_01
           0772                         ;}
38A1 0008  0773         RETURN
           0774                         ;
           0775                         ;#define	setRFspeed_address	0x38a3
           0776                         ;#pragma origin setRFspeed_address
     0000  0777         ORG 0x38A3
           0778                         ;void setRFspeed(uns8 speed @ W)
           0779                         ;{
           0780 setRFspeed
           0781                         ;  #asm
           0782                         ;    DW 0x2000
38A3 2000  0783         DW    0x2000
           0784                         ;  #endasm
           0785                         ;  #pragma updateBank exit=UserBank_01
           0786                         ;}
38A4 0008  0787         RETURN
           0788                         ;
           0789                         ;#define	setRFsleep_address	0x38a6
           0790                         ;#pragma origin setRFsleep_address
     0000  0791         ORG 0x38A6
           0792                         ;void setRFsleep()
           0793                         ;{
           0794 setRFsleep
           0795                         ;  #asm
           0796                         ;    DW 0x2000
38A6 2000  0797         DW    0x2000
           0798                         ;  #endasm
           0799                         ;  #pragma updateBank exit=UserBank_01
           0800                         ;}
38A7 0008  0801         RETURN
           0802                         ;
           0803                         ;#define	setRFready_address	0x38a9
           0804                         ;#pragma origin setRFready_address
     0000  0805         ORG 0x38A9
           0806                         ;void setRFready()
           0807                         ;{
           0808 setRFready
           0809                         ;  #asm
           0810                         ;    DW 0x2000
38A9 2000  0811         DW    0x2000
           0812                         ;  #endasm
           0813                         ;  #pragma updateBank exit=UserBank_01
           0814                         ;}
38AA 0008  0815         RETURN
           0816                         ;
           0817                         ;#define	RFTXpacket_address	0x38ac
           0818                         ;#pragma origin RFTXpacket_address
     0000  0819         ORG 0x38AC
           0820                         ;void RFTXpacket()
           0821                         ;{
           0822 RFTXpacket
           0823                         ;  #asm
           0824                         ;    DW 0x2000
38AC 2000  0825         DW    0x2000
           0826                         ;  #endasm
           0827                         ;  #pragma updateBank exit=UserBank_01
           0828                         ;}
38AD 0008  0829         RETURN
           0830                         ;
           0831                         ;#define	RFRXpacket_address	0x38af
           0832                         ;#pragma origin RFRXpacket_address
     0000  0833         ORG 0x38AF
           0834                         ;bit RFRXpacket()
           0835                         ;{
           0836 RFRXpacket
           0837                         ;  #asm
           0838                         ;    DW 0x2000
38AF 2000  0839         DW    0x2000
           0840                         ;  #endasm
           0841                         ;  #pragma updateBank exit=UserBank_01
           0842                         ;  return Carry;
38B0 0008  0843         RETURN
           0844                         ;}
           0845                         ;
           0846                         ;#define	checkRF_address	0x38b2
           0847                         ;#pragma origin checkRF_address
     0000  0848         ORG 0x38B2
           0849                         ;bit checkRF(uns8 level @ W)
           0850                         ;{
           0851 checkRF
           0852                         ;  #asm
           0853                         ;    DW 0x2000
38B2 2000  0854         DW    0x2000
           0855                         ;  #endasm
           0856                         ;  #pragma updateBank exit=UserBank_01
           0857                         ;  return Carry;
38B3 0008  0858         RETURN
           0859                         ;}
           0860                         ;
           0861                         ;#define	amIBonded_address	0x38b8
           0862                         ;#pragma origin amIBonded_address
     0000  0863         ORG 0x38B8
           0864                         ;bit amIBonded()
           0865                         ;{
           0866 amIBonded
           0867                         ;  #asm
           0868                         ;    DW 0x2000
38B8 2000  0869         DW    0x2000
           0870                         ;  #endasm
           0871                         ;  #pragma updateBank exit=UserBank_01
           0872                         ;  return Carry;
38B9 0008  0873         RETURN
           0874                         ;}
           0875                         ;
           0876                         ;#define	removeBond_address	0x38bb
           0877                         ;#pragma origin removeBond_address
     0000  0878         ORG 0x38BB
           0879                         ;void removeBond()
           0880                         ;{
           0881 removeBond
           0882                         ;  #asm
           0883                         ;    DW 0x2000
38BB 2000  0884         DW    0x2000
           0885                         ;  #endasm
           0886                         ;  #pragma updateBank exit=UserBank_01
           0887                         ;}
38BC 0008  0888         RETURN
           0889                         ;
           0890                         ;#define	bondNewNode_address	0x38be
           0891                         ;#pragma origin bondNewNode_address
     0000  0892         ORG 0x38BE
           0893                         ;bit bondNewNode(uns8 address @ W)
           0894                         ;{
           0895 bondNewNode
           0896                         ;  #asm
           0897                         ;    DW 0x2000
38BE 2000  0898         DW    0x2000
           0899                         ;  #endasm
           0900                         ;  #pragma updateBank exit=UserBank_01
           0901                         ;  return Carry;
38BF 0008  0902         RETURN
           0903                         ;}
           0904                         ;
           0905                         ;#define	isBondedNode_address	0x38c1
           0906                         ;#pragma origin isBondedNode_address
     0000  0907         ORG 0x38C1
           0908                         ;bit isBondedNode(uns8 node @ W)
           0909                         ;{
           0910 isBondedNode
           0911                         ;  #asm
           0912                         ;    DW 0x2000
38C1 2000  0913         DW    0x2000
           0914                         ;  #endasm
           0915                         ;  #pragma updateBank exit=UserBank_01
           0916                         ;  return Carry;
38C2 0008  0917         RETURN
           0918                         ;}
           0919                         ;
           0920                         ;#define	removeBondedNode_address	0x38c4
           0921                         ;#pragma origin removeBondedNode_address
     0000  0922         ORG 0x38C4
           0923                         ;void removeBondedNode(uns8 node @ W)
           0924                         ;{
           0925 removeBondedNode
           0926                         ;  #asm
           0927                         ;    DW 0x2000
38C4 2000  0928         DW    0x2000
           0929                         ;  #endasm
           0930                         ;  #pragma updateBank exit=UserBank_01
           0931                         ;}
38C5 0008  0932         RETURN
           0933                         ;
           0934                         ;#define	rebondNode_address	0x38c7
           0935                         ;#pragma origin rebondNode_address
     0000  0936         ORG 0x38C7
           0937                         ;bit rebondNode(uns8 node @ W)
           0938                         ;{
           0939 rebondNode
           0940                         ;  #asm
           0941                         ;    DW 0x2000
38C7 2000  0942         DW    0x2000
           0943                         ;  #endasm
           0944                         ;  #pragma updateBank exit=UserBank_01
           0945                         ;  return Carry;
38C8 0008  0946         RETURN
           0947                         ;}
           0948                         ;
           0949                         ;#define	clearAllBonds_address	0x38ca
           0950                         ;#pragma origin clearAllBonds_address
     0000  0951         ORG 0x38CA
           0952                         ;void clearAllBonds()
           0953                         ;{
           0954 clearAllBonds
           0955                         ;  #asm
           0956                         ;    DW 0x2000
38CA 2000  0957         DW    0x2000
           0958                         ;  #endasm
           0959                         ;  #pragma updateBank exit=UserBank_01
           0960                         ;}
38CB 0008  0961         RETURN
           0962                         ;
           0963                         ;#define	setNonetMode_address	0x38cd
           0964                         ;#pragma origin setNonetMode_address
     0000  0965         ORG 0x38CD
           0966                         ;void setNonetMode()
           0967                         ;{
           0968 setNonetMode
           0969                         ;  #asm
           0970                         ;    DW 0x2000
38CD 2000  0971         DW    0x2000
           0972                         ;  #endasm
           0973                         ;  #pragma updateBank exit=UserBank_01
           0974                         ;}
38CE 0008  0975         RETURN
           0976                         ;
           0977                         ;#define	setCoordinatorMode_address	0x38d0
           0978                         ;#pragma origin setCoordinatorMode_address
     0000  0979         ORG 0x38D0
           0980                         ;void setCoordinatorMode()
           0981                         ;{
           0982 setCoordinatorMode
           0983                         ;  #asm
           0984                         ;    DW 0x2000
38D0 2000  0985         DW    0x2000
           0986                         ;  #endasm
           0987                         ;  #pragma updateBank exit=UserBank_01
           0988                         ;}
38D1 0008  0989         RETURN
           0990                         ;
           0991                         ;#define	setNodeMode_address	0x38d3
           0992                         ;#pragma origin setNodeMode_address
     0000  0993         ORG 0x38D3
           0994                         ;void setNodeMode()
           0995                         ;{
           0996 setNodeMode
           0997                         ;  #asm
           0998                         ;    DW 0x2000
38D3 2000  0999         DW    0x2000
           1000                         ;  #endasm
           1001                         ;  #pragma updateBank exit=UserBank_01
           1002                         ;}
38D4 0008  1003         RETURN
           1004                         ;
           1005                         ;#define	setNetworkFilteringOn_address	0x38d6
           1006                         ;#pragma origin setNetworkFilteringOn_address
     0000  1007         ORG 0x38D6
           1008                         ;void setNetworkFilteringOn()
           1009                         ;{
           1010 setNetworkFilteringOn
           1011                         ;  #asm
           1012                         ;    DW 0x2000
38D6 2000  1013         DW    0x2000
           1014                         ;  #endasm
           1015                         ;  #pragma updateBank exit=UserBank_01
           1016                         ;}
38D7 0008  1017         RETURN
           1018                         ;
           1019                         ;#define	setNetworkFilteringOff_address	0x38d9
           1020                         ;#pragma origin setNetworkFilteringOff_address
     0000  1021         ORG 0x38D9
           1022                         ;void setNetworkFilteringOff()
           1023                         ;{
           1024 setNetworkFilteringOff
           1025                         ;  #asm
           1026                         ;    DW 0x2000
38D9 2000  1027         DW    0x2000
           1028                         ;  #endasm
           1029                         ;  #pragma updateBank exit=UserBank_01
           1030                         ;}
38DA 0008  1031         RETURN
           1032                         ;
           1033                         ;#define	getNetworkParams_address	0x38dc
           1034                         ;#pragma origin getNetworkParams_address
     0000  1035         ORG 0x38DC
           1036                         ;uns8 getNetworkParams()
           1037                         ;{
           1038 getNetworkParams
           1039                         ;  #asm
           1040                         ;    DW 0x2000
38DC 2000  1041         DW    0x2000
           1042                         ;  #endasm
           1043                         ;  #pragma updateBank exit=UserBank_01
           1044                         ;  return 1;
38DD 3401  1045         RETLW 0x01
           1046                         ;}
           1047                         ;
           1048                         ;#define	setRoutingOn_address	0x38df
           1049                         ;#pragma origin setRoutingOn_address
     0000  1050         ORG 0x38DF
           1051                         ;void setRoutingOn()
           1052                         ;{
           1053 setRoutingOn
           1054                         ;  #asm
           1055                         ;    DW 0x2000
38DF 2000  1056         DW    0x2000
           1057                         ;  #endasm
           1058                         ;  #pragma updateBank exit=UserBank_01
           1059                         ;}
38E0 0008  1060         RETURN
           1061                         ;
           1062                         ;#define	setRoutingOff_address	0x38e2
           1063                         ;#pragma origin setRoutingOff_address
     0000  1064         ORG 0x38E2
           1065                         ;void setRoutingOff()
           1066                         ;{
           1067 setRoutingOff
           1068                         ;  #asm
           1069                         ;    DW 0x2000
38E2 2000  1070         DW    0x2000
           1071                         ;  #endasm
           1072                         ;  #pragma updateBank exit=UserBank_01
           1073                         ;}
38E3 0008  1074         RETURN
           1075                         ;
           1076                         ;#define	answerSystemPacket_address	0x38e8
           1077                         ;#pragma origin answerSystemPacket_address
     0000  1078         ORG 0x38E8
           1079                         ;void answerSystemPacket()
           1080                         ;{
           1081 answerSystemPacket
           1082                         ;  #asm
           1083                         ;    DW 0x2000
38E8 2000  1084         DW    0x2000
           1085                         ;  #endasm
           1086                         ;  #pragma updateBank exit=UserBank_01
           1087                         ;}
38E9 0008  1088         RETURN
           1089                         ;
           1090                         ;#define	discovery_address	0x38eb
           1091                         ;#pragma origin discovery_address
     0000  1092         ORG 0x38EB
           1093                         ;uns8 discovery(uns8 MaxNodeAddress @ W)
           1094                         ;{
           1095 discovery
           1096                         ;  #asm
           1097                         ;    DW 0x2000
38EB 2000  1098         DW    0x2000
           1099                         ;  #endasm
           1100                         ;  #pragma updateBank exit=UserBank_01
           1101                         ;  return 1;
38EC 3401  1102         RETLW 0x01
           1103                         ;}
           1104                         ;
           1105                         ;#define	wasRouted_address	0x38ee
           1106                         ;#pragma origin wasRouted_address
     0000  1107         ORG 0x38EE
           1108                         ;bit wasRouted()
           1109                         ;{
           1110 wasRouted
           1111                         ;  #asm
           1112                         ;    DW 0x2000
38EE 2000  1113         DW    0x2000
           1114                         ;  #endasm
           1115                         ;  #pragma updateBank exit=UserBank_01
           1116                         ;  return Carry;
38EF 0008  1117         RETURN
           1118                         ;}
           1119                         ;
           1120                         ;#define	optimizeHops_address	0x38f1
           1121                         ;#pragma origin optimizeHops_address
     0000  1122         ORG 0x38F1
           1123                         ;bit optimizeHops(uns8 method @ W)
           1124                         ;{
           1125 optimizeHops
           1126                         ;  #asm
           1127                         ;    DW 0x2000
38F1 2000  1128         DW    0x2000
           1129                         ;  #endasm
           1130                         ;  #pragma updateBank exit=UserBank_01
           1131                         ;  return Carry;
38F2 0008  1132         RETURN
           1133                         ;}
           1134                         ;
           1135                         ;#define	getSupplyVoltage_address	0x38f4
           1136                         ;#pragma origin getSupplyVoltage_address
     0000  1137         ORG 0x38F4
           1138                         ;uns8 getSupplyVoltage()
           1139                         ;{
           1140 getSupplyVoltage
           1141                         ;  #asm
           1142                         ;    DW 0x2000
38F4 2000  1143         DW    0x2000
           1144                         ;  #endasm
           1145                         ;  #pragma updateBank exit=UserBank_01
           1146                         ;  return 1;
38F5 3401  1147         RETLW 0x01
           1148                         ;}
           1149                         ;
           1150                         ;#define	getTemperature_address	0x38f7
           1151                         ;#pragma origin getTemperature_address
     0000  1152         ORG 0x38F7
           1153                         ;int8 getTemperature()
           1154                         ;{
           1155 getTemperature
           1156                         ;  #asm
           1157                         ;    DW 0x2000
38F7 2000  1158         DW    0x2000
           1159                         ;  #endasm
           1160                         ;  #pragma updateBank exit=UserBank_01
           1161                         ;  return W;
38F8 0008  1162         RETURN
           1163                         ;}
           1164                         ;
           1165                         ;#define	clearBufferRF_address	0x38fa
           1166                         ;#pragma origin clearBufferRF_address
     0000  1167         ORG 0x38FA
           1168                         ;void clearBufferRF()
           1169                         ;{
           1170 clearBufferRF
           1171                         ;  #asm
           1172                         ;    DW 0x2000
38FA 2000  1173         DW    0x2000
           1174                         ;  #endasm
           1175                         ;  #pragma updateBank exit=UserBank_01
           1176                         ;}
38FB 0008  1177         RETURN
           1178                         ;
           1179                         ;#define	isDiscoveredNode_address	0x3910
           1180                         ;#pragma origin isDiscoveredNode_address
     0000  1181         ORG 0x3910
           1182                         ;bit isDiscoveredNode(uns8 address @ W)
           1183                         ;{
           1184 isDiscoveredNode
           1185                         ;  #asm
           1186                         ;    DW 0x2000
3910 2000  1187         DW    0x2000
           1188                         ;  #endasm
           1189                         ;  #pragma updateBank exit=UserBank_01
           1190                         ;  return Carry;
3911 0008  1191         RETURN
           1192                         ;}
           1193                         ;
           1194                         ;#define	enableRFPGM_address	0x3913
           1195                         ;#pragma origin enableRFPGM_address
     0000  1196         ORG 0x3913
           1197                         ;void enableRFPGM()
           1198                         ;{
           1199 enableRFPGM
           1200                         ;  #asm
           1201                         ;    DW 0x2000
3913 2000  1202         DW    0x2000
           1203                         ;  #endasm
           1204                         ;  #pragma updateBank exit=UserBank_01
           1205                         ;}
3914 0008  1206         RETURN
           1207                         ;
           1208                         ;#define	disableRFPGM_address	0x3916
           1209                         ;#pragma origin disableRFPGM_address
     0000  1210         ORG 0x3916
           1211                         ;void disableRFPGM()
           1212                         ;{
           1213 disableRFPGM
           1214                         ;  #asm
           1215                         ;    DW 0x2000
3916 2000  1216         DW    0x2000
           1217                         ;  #endasm
           1218                         ;  #pragma updateBank exit=UserBank_01
           1219                         ;}
3917 0008  1220         RETURN
           1221                         ;
           1222                         ;#define	setupRFPGM_address	0x3919
           1223                         ;#pragma origin setupRFPGM_address
     0000  1224         ORG 0x3919
           1225                         ;void setupRFPGM(uns8 x @ W)
           1226                         ;{
           1227 setupRFPGM
           1228                         ;  #asm
           1229                         ;    DW 0x2000
3919 2000  1230         DW    0x2000
           1231                         ;  #endasm
           1232                         ;  #pragma updateBank exit=UserBank_01
           1233                         ;}
391A 0008  1234         RETURN
           1235                         ;
           1236                         ;#define	runRFPGM_address	0x391c
           1237                         ;#pragma origin runRFPGM_address
     0000  1238         ORG 0x391C
           1239                         ;void runRFPGM()
           1240                         ;{
           1241 runRFPGM
           1242                         ;  #asm
           1243                         ;    DW 0x2000
391C 2000  1244         DW    0x2000
           1245                         ;  #endasm
           1246                         ;  #pragma updateBank exit=UserBank_01
           1247                         ;}
391D 0008  1248         RETURN
           1249                         ;
           1250                         ;#define	iqrfDeepSleep_address	0x391f
           1251                         ;#pragma origin iqrfDeepSleep_address
     0000  1252         ORG 0x391F
           1253                         ;void iqrfDeepSleep()
           1254                         ;{
           1255 iqrfDeepSleep
           1256                         ;  #asm
           1257                         ;    DW 0x2000
391F 2000  1258         DW    0x2000
           1259                         ;  #endasm
           1260                         ;  #pragma updateBank exit=UserBank_01
           1261                         ;}
3920 0008  1262         RETURN
           1263                         ;
           1264                         ;#define	wasRFICrestarted_address	0x3922
           1265                         ;#pragma origin wasRFICrestarted_address
     0000  1266         ORG 0x3922
           1267                         ;uns8 wasRFICrestarted()
           1268                         ;{
           1269 wasRFICrestarted
           1270                         ;  #asm
           1271                         ;    DW 0x2000
3922 2000  1272         DW    0x2000
           1273                         ;  #endasm
           1274                         ;  #pragma updateBank exit=UserBank_01
           1275                         ;  return 1;
3923 3401  1276         RETLW 0x01
           1277                         ;}
           1278                         ;
           1279                         ;#define	eeeWriteData_address	0x3925
           1280                         ;#pragma origin eeeWriteData_address
     0000  1281         ORG 0x3925
           1282                         ;bit eeeWriteData(uns16 address @ param3)
           1283                         ;{
           1284 eeeWriteData
           1285                         ;  #asm
           1286                         ;    DW 0x2000
3925 2000  1287         DW    0x2000
           1288                         ;  #endasm
           1289                         ;  #pragma updateBank exit=UserBank_01
           1290                         ;  return Carry;
3926 0008  1291         RETURN
           1292                         ;}
           1293                         ;
           1294                         ;#define	eeeReadData_address	0x3928
           1295                         ;#pragma origin eeeReadData_address
     0000  1296         ORG 0x3928
           1297                         ;bit eeeReadData(uns16 address @ param3)
           1298                         ;{
           1299 eeeReadData
           1300                         ;  #asm
           1301                         ;    DW 0x2000
3928 2000  1302         DW    0x2000
           1303                         ;  #endasm
           1304                         ;  #pragma updateBank exit=UserBank_01
           1305                         ;  return Carry;
3929 0008  1306         RETURN
           1307                         ;}
           1308                         ;
           1309                         ;#define	setINDF0_address	0x3931
           1310                         ;#pragma origin setINDF0_address
     0000  1311         ORG 0x3931
           1312                         ;void setINDF0(uns8 value @ W)
           1313                         ;{
           1314 setINDF0
           1315                         ;  #asm
           1316                         ;    DW 0x2000
3931 2000  1317         DW    0x2000
           1318                         ;  #endasm
           1319                         ;  #pragma updateBank exit=UserBank_01
           1320                         ;}
3932 0008  1321         RETURN
           1322                         ;
           1323                         ;#define	setINDF1_address	0x3934
           1324                         ;#pragma origin setINDF1_address
     0000  1325         ORG 0x3934
           1326                         ;void setINDF1(uns8 value @ W)
           1327                         ;{
           1328 setINDF1
           1329                         ;  #asm
           1330                         ;    DW 0x2000
3934 2000  1331         DW    0x2000
           1332                         ;  #endasm
           1333                         ;  #pragma updateBank exit=UserBank_01
           1334                         ;}
3935 0008  1335         RETURN
           1336                         ;
           1337                         ;#define	getRSSI_address	0x3937
           1338                         ;#pragma origin getRSSI_address
     0000  1339         ORG 0x3937
           1340                         ;uns8 getRSSI()
           1341                         ;{
           1342 getRSSI
           1343                         ;  #asm
           1344                         ;    DW 0x2000
3937 2000  1345         DW    0x2000
           1346                         ;  #endasm
           1347                         ;  #pragma updateBank exit=UserBank_01
           1348                         ;  return 1;
3938 3401  1349         RETLW 0x01
           1350                         ;}
           1351                         ;
           1352                         ;#define	removeBondAddress_address	0x393a
           1353                         ;#pragma origin removeBondAddress_address
     0000  1354         ORG 0x393A
           1355                         ;void removeBondAddress()
           1356                         ;{
           1357 removeBondAddress
           1358                         ;  #asm
           1359                         ;    DW 0x2000
393A 2000  1360         DW    0x2000
           1361                         ;  #endasm
           1362                         ;  #pragma updateBank exit=UserBank_01
           1363                         ;}
393B 0008  1364         RETURN
           1365                         ;
           1366                         ;#define	sendFRC_address	0x393d
           1367                         ;#pragma origin sendFRC_address
     0000  1368         ORG 0x393D
           1369                         ;uns8 sendFRC(uns8 command @ W)
           1370                         ;{
           1371 sendFRC
           1372                         ;  #asm
           1373                         ;    DW 0x2000
393D 2000  1374         DW    0x2000
           1375                         ;  #endasm
           1376                         ;  #pragma updateBank exit=UserBank_01
           1377                         ;  return 1;
393E 3401  1378         RETLW 0x01
           1379                         ;}
           1380                         ;
           1381                         ;#define	responseFRC_address	0x3940
           1382                         ;#pragma origin responseFRC_address
     0000  1383         ORG 0x3940
           1384                         ;void responseFRC()
           1385                         ;{
           1386 responseFRC
           1387                         ;  #asm
           1388                         ;    DW 0x2000
3940 2000  1389         DW    0x2000
           1390                         ;  #endasm
           1391                         ;  #pragma updateBank exit=UserBank_01
           1392                         ;}
3941 0008  1393         RETURN
           1394                         ;
           1395                         ;#define	bondRequestAdvanced_address	0x3943
           1396                         ;#pragma origin bondRequestAdvanced_address
     0000  1397         ORG 0x3943
           1398                         ;bit bondRequestAdvanced()
           1399                         ;{
           1400 bondRequestAdvanced
           1401                         ;  #asm
           1402                         ;    DW 0x2000
3943 2000  1403         DW    0x2000
           1404                         ;  #endasm
           1405                         ;  #pragma updateBank exit=UserBank_01
           1406                         ;  return Carry;
3944 0008  1407         RETURN
           1408                         ;}
           1409                         ;
           1410                         ;#define	prebondNodeAtNode_address	0x3946
           1411                         ;#pragma origin prebondNodeAtNode_address
     0000  1412         ORG 0x3946
           1413                         ;bit prebondNodeAtNode()
           1414                         ;{
           1415 prebondNodeAtNode
           1416                         ;  #asm
           1417                         ;    DW 0x2000
3946 2000  1418         DW    0x2000
           1419                         ;  #endasm
           1420                         ;  #pragma updateBank exit=UserBank_01
           1421                         ;  return Carry;
3947 0008  1422         RETURN
           1423                         ;}
           1424                         ;
           1425                         ;#define	nodeAuthorization_address	0x3949
           1426                         ;#pragma origin nodeAuthorization_address
     0000  1427         ORG 0x3949
           1428                         ;bit nodeAuthorization(uns8 address @ W)
           1429                         ;{
           1430 nodeAuthorization
           1431                         ;  #asm
           1432                         ;    DW 0x2000
3949 2000  1433         DW    0x2000
           1434                         ;  #endasm
           1435                         ;  #pragma updateBank exit=UserBank_01
           1436                         ;  return Carry;
394A 0008  1437         RETURN
           1438                         ;}
           1439                         ;
           1440                         ;#define	dummy01_address	0x394c
           1441                         ;#pragma origin dummy01_address
     0000  1442         ORG 0x394C
           1443                         ;void dummy01()
           1444                         ;{
           1445 dummy01
           1446                         ;  #asm
           1447                         ;  DW 0x2000
394C 2000  1448         DW    0x2000
           1449                         ;  #endasm
           1450                         ;  #pragma updateBank exit=UserBank_01
           1451                         ;}
394D 0008  1452         RETURN
           1453                         ;
           1454                         ;#define	setAccessPassword_address	0x3958
           1455                         ;#pragma origin setAccessPassword_address
     0000  1456         ORG 0x3958
           1457                         ;void setAccessPassword()
           1458                         ;{
           1459 setAccessPassword
           1460                         ;  #asm
           1461                         ;    DW 0x2000
3958 2000  1462         DW    0x2000
           1463                         ;  #endasm
           1464                         ;  #pragma updateBank exit=UserBank_01
           1465                         ;}
3959 0008  1466         RETURN
           1467                         ;
           1468                         ;#define	setUserKey_address	0x395b
           1469                         ;#pragma origin setUserKey_address
     0000  1470         ORG 0x395B
           1471                         ;void setUserKey()
           1472                         ;{
           1473 setUserKey
           1474                         ;  #asm
           1475                         ;    DW 0x2000
395B 2000  1476         DW    0x2000
           1477                         ;  #endasm
           1478                         ;  #pragma updateBank exit=UserBank_01
           1479                         ;}
395C 0008  1480         RETURN
           1481                         ;
           1482                         ;#define	amIRecipientOfFRC_address	0x3961
           1483                         ;#pragma origin amIRecipientOfFRC_address
     0000  1484         ORG 0x3961
           1485                         ;bit amIRecipientOfFRC()
           1486                         ;{
           1487 amIRecipientOfFRC
           1488                         ;  #asm
           1489                         ;    DW 0x2000
3961 2000  1490         DW    0x2000
           1491                         ;  #endasm
           1492                         ;  #pragma updateBank exit=UserBank_01
           1493                         ;  return Carry;
3962 0008  1494         RETURN
           1495                         ;}
           1496                         ;
           1497                         ;#define	setLEDR_address	0x3964
           1498                         ;#pragma origin setLEDR_address
     0000  1499         ORG 0x3964
           1500                         ;void setLEDR()
           1501                         ;{
           1502 setLEDR
           1503                         ;  #asm
           1504                         ;    DW 0x2000
3964 2000  1505         DW    0x2000
           1506                         ;  #endasm
           1507                         ;  #pragma updateBank exit=UserBank_01
           1508                         ;}
3965 0008  1509         RETURN
           1510                         ;
           1511                         ;#define	encryptBufferRF_address	0x3967
           1512                         ;#pragma origin encryptBufferRF_address
     0000  1513         ORG 0x3967
           1514                         ;void encryptBufferRF(uns8 blocks @ W)
           1515                         ;{
           1516 encryptBufferRF
           1517                         ;  #asm
           1518                         ;    DW 0x2000
3967 2000  1519         DW    0x2000
           1520                         ;  #endasm
           1521                         ;  #pragma updateBank exit=UserBank_01
           1522                         ;}
3968 0008  1523         RETURN
           1524                         ;
           1525                         ;#define	decryptBufferRF_address	0x396a
           1526                         ;#pragma origin decryptBufferRF_address
     0000  1527         ORG 0x396A
           1528                         ;void decryptBufferRF(uns8 blocks @ W)
           1529                         ;{
           1530 decryptBufferRF
           1531                         ;  #asm
           1532                         ;    DW 0x2000
396A 2000  1533         DW    0x2000
           1534                         ;  #endasm
           1535                         ;  #pragma updateBank exit=UserBank_01
           1536                         ;}
396B 0008  1537         RETURN
           1538                         ;
           1539                         ;#define	prebondNodeAtCoordinator_address	0x396d
           1540                         ;#pragma origin prebondNodeAtCoordinator_address
     0000  1541         ORG 0x396D
           1542                         ;bit prebondNodeAtCoordinator(uns8 address @ W)
           1543                         ;{
           1544 prebondNodeAtCoordinator
           1545                         ;  #asm
           1546                         ;    DW 0x2000
396D 2000  1547         DW    0x2000
           1548                         ;  #endasm
           1549                         ;  #pragma updateBank exit=UserBank_01
           1550                         ;  return Carry;
396E 0008  1551         RETURN
           1552                         ;}
           1553                         ;
           1554                         ;#define	setFSRs_address	0x3970
           1555                         ;#pragma origin setFSRs_address
     0000  1556         ORG 0x3970
           1557                         ;uns8 setFSRs(uns8 fsrs @ W)
           1558                         ;{
           1559 setFSRs
           1560                         ;  #asm
           1561                         ;    DW 0x2000
3970 2000  1562         DW    0x2000
           1563                         ;  #endasm
           1564                         ;  #pragma updateBank exit=UserBank_01
           1565                         ;  return 1;
3971 3401  1566         RETLW 0x01
           1567                         ;}
           1568                         ;
           1569                         ;// For internal usage only
           1570                         ;#define	updateCRC16_address	0x3973
           1571                         ;#pragma origin updateCRC16_address
     0000  1572         ORG 0x3973
           1573                         ;void updateCRC16(uns8 value @ W)
           1574                         ;{
           1575 updateCRC16
           1576                         ;  #asm
           1577                         ;    DW 0x2000
3973 2000  1578         DW    0x2000
           1579                         ;  #endasm
           1580                         ;  #pragma updateBank exit=UserBank_01
           1581                         ;}
3974 0008  1582         RETURN
           1583                         ;
           1584                         ;#define	smartConnect_address	0x3976
           1585                         ;#pragma origin smartConnect_address
     0000  1586         ORG 0x3976
           1587                         ;bit smartConnect(uns8 address @ W)
           1588                         ;{
           1589 smartConnect
           1590                         ;  #asm
           1591                         ;    DW 0x2000
3976 2000  1592         DW    0x2000
           1593                         ;  #endasm
           1594                         ;  #pragma updateBank exit=UserBank_01
           1595                         ;  return Carry;
3977 0008  1596         RETURN
           1597                         ;}
           1598                         ;
           1599                         ;#define	addressBitmap_address	0x3979
           1600                         ;#pragma origin addressBitmap_address
     0000  1601         ORG 0x3979
           1602                         ;uns8 addressBitmap(uns8 bitIndex @ W)
           1603                         ;{
           1604 addressBitmap
           1605                         ;  #asm
           1606                         ;    DW 0x2000
3979 2000  1607         DW    0x2000
           1608                         ;  #endasm
           1609                         ;  #pragma updateBank exit=UserBank_01
           1610                         ;  return 1;
397A 3401  1611         RETLW 0x01
           1612                         ;}
           1613                         ;
           1614                         ;#define	setServiceChannel_address	0x397c
           1615                         ;#pragma origin setServiceChannel_address
     0000  1616         ORG 0x397C
           1617                         ;bit setServiceChannel(uns8 channelNumber @ W)
           1618                         ;{
           1619 setServiceChannel
           1620                         ;  #asm
           1621                         ;    DW 0x2000
397C 2000  1622         DW    0x2000
           1623                         ;  #endasm
           1624                         ;  #pragma updateBank exit=UserBank_01
           1625                         ;  return 1;
397D 1403  1626         BSF   0x03,Carry
397E 0008  1627         RETURN
           1628                         ;}
           1629                         ;
           1630                         ;#pragma optimize 1
           1631                         ;#pragma update_RP 1
           1632                         ;#pragma update_PAGE 1
           1633                         ;#pragma origin __APPLICATION_ADDRESS
     0000  1634         ORG 0x3A00
           1635 
           1636   ; FILE ../../../../Development/include/DPA/DPA.h
           1637                         ;// *********************************************************************
           1638                         ;//   General public DPA header file                                    *
           1639                         ;// *********************************************************************
           1640                         ;// Copyright (c) IQRF Tech s.r.o.
           1641                         ;//
           1642                         ;// File:    $RCSfile: DPA.h,v $
           1643                         ;// Version: $Revision: 1.275 $
           1644                         ;// Date:    $Date: 2020/02/27 13:17:17 $
           1645                         ;//
           1646                         ;// Revision history:
           1647                         ;//   2020/02/27  Release for DPA 4.13
           1648                         ;//   2020/01/09  Release for DPA 4.12
           1649                         ;//   2019/12/11  Release for DPA 4.11
           1650                         ;//   2019/10/09  Release for DPA 4.10
           1651                         ;//   2019/06/12  Release for DPA 4.03
           1652                         ;//   2019/06/03  Release for DPA 4.02
           1653                         ;//   2019/03/07  Release for DPA 4.01
           1654                         ;//   2019/01/10  Release for DPA 4.00
           1655                         ;//   2018/10/25  Release for DPA 3.03
           1656                         ;//   2017/11/16  Release for DPA 3.02
           1657                         ;//   2017/08/14  Release for DPA 3.01
           1658                         ;//   2017/03/13  Release for DPA 3.00
           1659                         ;//   2016/09/12  Release for DPA 2.28
           1660                         ;//   2016/04/14  Release for DPA 2.27
           1661                         ;//   2016/03/03  Release for DPA 2.26
           1662                         ;//   2016/01/21  Release for DPA 2.25
           1663                         ;//   2015/12/01  Release for DPA 2.24
           1664                         ;//   2015/10/23  Release for DPA 2.23
           1665                         ;//   2015/09/25  Release for DPA 2.22
           1666                         ;//   2015/09/03  Release for DPA 2.21
           1667                         ;//   2015/08/05  Release for DPA 2.20
           1668                         ;//   2014/10/31  Release for DPA 2.10
           1669                         ;//   2014/04/30  Release for DPA 2.00
           1670                         ;//   2013/10/03  Release for DPA 1.00
           1671                         ;//
           1672                         ;// *********************************************************************
           1673                         ;
           1674                         ;// Online DPA documentation https://doc.iqrf.org/DpaTechGuide/
           1675                         ;// IQRF Standards documentation https://www.iqrfalliance.org/iqrf-interoperability/
           1676                         ;
           1677                         ;#ifndef _DPA_HEADER_
           1678                         ;#define _DPA_HEADER_
           1679                         ;
           1680                         ;//############################################################################################
           1681                         ;
           1682                         ;// DPA version
           1683                         ;#define	DPA_VERSION_MASTER			0x0413
           1684                         ;
           1685                         ;#ifdef __CC5X__
           1686                         ;// Compiled only at CC5X
           1687                         ;#if __CC5X__ < 3703
           1688                         ;#error Insufficient CC5X compiler version, V3.7C is minimum
           1689                         ;#endif
           1690                         ;
           1691                         ;#if IQRFOS < 403
           1692                         ;#error IQRF OS 4.03+ is required
           1693                         ;#endif
           1694                         ;
           1695                         ;// Bank for custom variables
           1696                         ;#pragma rambank = UserBank_01
           1697                         ;
           1698                         ;// Main DPA API entry address (also start of the licensed FLASH) 
           1699                         ;#define	DPA_API_ADDRESS				__LICENSED_FLASH
           1700                         ;
           1701                         ;// Main DPA entry address
           1702                         ;#define	MAIN_DPA_ADDRESS			( DPA_API_ADDRESS + 4 )
           1703                         ;
           1704                         ;// Main DPA API entry address stub
           1705                         ;#define	DPA_API_ADDRESS_ENTRY		0x3A08
           1706                         ;
           1707                         ;// Address of the DPA Custom Handler
           1708                         ;#define	CUSTOM_HANDLER_ADDRESS		0x3A20
           1709                         ;
           1710                         ;// Address of the DPA Custom Handler end + 1
           1711                         ;#define	CUSTOM_HANDLER_ADDRESS_END	0x3D80
           1712                         ;
           1713                         ;// DPA API entry function
           1714                         ;uns8  DpaApiEntry( uns8 par1, uns8 par2, uns8 apiIndex );
           1715                         ;
           1716                         ;// DPA API codes
           1717                         ;#define	DPA_API_RFTX_DPAPACKET				0
           1718                         ;#define	DPA_API_READ_CONFIG_BYTE			1
           1719                         ;#define	DPA_API_SEND_TO_IFACEMASTER			2
           1720                         ;#define	DPA_API_COORDINATOR_RFTX_DPAPACKET	3
           1721                         ;#define	DPA_API_LOCAL_REQUEST				4
           1722                         ;#define	DPA_API_SET_PERIPHERAL_ERROR		5
           1723                         ;#define	DPA_API_SET_RF_DEFAULTS				6
           1724                         ;
           1725                         ;// Used buffer size symbols
           1726                         ;#define	sizeofBufferRF						sizeof( bufferRF )
           1727                         ;#define	sizeofBufferAUX						sizeof( bufferAUX )
           1728                         ;#define	sizeofBufferCOM						sizeof( bufferCOM )
           1729                         ;
           1730                         ;#define	STRUCTATTR
           1731                         ;
           1732                         ;#else //__CC5X__
           1733                         ;// Not compiled at CC5X
           1734                         ;
           1735                         ;// Define CC5X types
           1736                         ;typedef uint8_t	  uns8;
           1737                         ;typedef uint16_t  uns16;
           1738                         ;
           1739                         ;// Define some types missing at Arduino
           1740                         ;#ifdef Arduino_h
           1741                         ;typedef int8_t  int8;
           1742                         ;typedef int16_t int16;
           1743                         ;#endif
           1744                         ;
           1745                         ;// Fake buffer sizes
           1746                         ;#define	sizeofBufferRF  64
           1747                         ;#define	sizeofBufferAUX 64
           1748                         ;#define	sizeofBufferCOM 64
           1749                         ;
           1750                         ;// Disables alignment of members of structures
           1751                         ;#define	STRUCTATTR	__attribute__((packed))
           1752                         ;
           1753                         ;#endif	// __CC5X__
           1754                         ;
           1755                         ;// Indexes of configuration bytes used by DpaApiReadConfigByte( index )
           1756                         ;// Checksum
           1757                         ;#define	CFGIND_CHECKSUM			0x00
           1758                         ;// Embedded peripherals
           1759                         ;#define	CFGIND_DPA_PERIPHERALS	0x01
           1760                         ;// DPA configuration flags #0
           1761                         ;#define	CFGIND_DPA_FLAGS		0x05
           1762                         ;// Main RF channel, used by the subordinate network
           1763                         ;#define	CFGIND_CHANNEL_2ND_A	0x06
           1764                         ;// Second RF channel, used by the subordinate network
           1765                         ;#define	CFGIND_CHANNEL_2ND_B	0x07
           1766                         ;// TX power
           1767                         ;#define	CFGIND_TXPOWER 			0x08
           1768                         ;// RX filter used by checkRF()
           1769                         ;#define	CFGIND_RXFILTER			0x09
           1770                         ;// toutRF for LP mode
           1771                         ;#define	CFGIND_DPA_LP_TOUTRF	0x0A
           1772                         ;// UART interface baud rate
           1773                         ;#define	CFGIND_DPA_UART_IFACE_SPEED 0x0B
           1774                         ;// Alternate DSM channel
           1775                         ;#define	CFGIND_ALTERNATE_DSM_CHANNEL 0x0C
           1776                         ;// Main RF channel
           1777                         ;#define	CFGIND_CHANNEL_A		0x11
           1778                         ;// Second RF channel
           1779                         ;#define	CFGIND_CHANNEL_B		0x12
           1780                         ;
           1781                         ;// 0: checks only mandatory precondition in order to prevent critical side-effects
           1782                         ;// 1: as above plus checks meaningful parameter conditions
           1783                         ;// 2: full implemented parameter checking (default)
           1784                         ;#ifndef PARAM_CHECK_LEVEL
           1785                         ;#define	PARAM_CHECK_LEVEL 2
           1786                         ;#endif
           1787                         ;
           1788                         ;// "foursome" at IFace structure
           1789                         ;typedef struct
           1790                         ;{
           1791                         ;  // Node address low byte
           1792                         ;  uns8	NADRlow;
           1793                         ;  // Node address high byte
           1794                         ;  uns8	NADRhigh;
           1795                         ;  // Peripheral number
           1796                         ;  uns8	PNUM;
           1797                         ;  // Peripheral command
           1798                         ;  uns8	PCMD;
           1799                         ;  // HWPID
           1800                         ;  uns16	HWPID;
           1801                         ;} STRUCTATTR TDpaIFaceHeader;
           1802                         ;
           1803                         ;// Maximum command PCMD value (except reserved 0x3F = CMD_GET_PER_INFO)
           1804                         ;#define	PCMD_MAX					0x7f
           1805                         ;// Bit mask at PCMD that indicates DPA Response message
           1806                         ;#define	RESPONSE_FLAG				0x80
           1807                         ;
           1808                         ;// IQMESH coordinator address
           1809                         ;#define COORDINATOR_ADDRESS			0x00
           1810                         ;// IQMESH broadcast address
           1811                         ;#define BROADCAST_ADDRESS			0xff
           1812                         ;// IQMESH temporary address, assigned by pre-bonding before authorization is done
           1813                         ;#define TEMPORARY_ADDRESS			0xfe
           1814                         ;// Address of the local device addressed by IFace
           1815                         ;#define LOCAL_ADDRESS				0xfc
           1816                         ;// Maximum IQMESH network device address
           1817                         ;#define MAX_ADDRESS					( 240 - 1 )
           1818                         ;
           1819                         ;// Time slots lengths in 10 ms
           1820                         ;#define	MIN_STD_TIMESLOT	4
           1821                         ;#define	MAX_STD_TIMESLOT	6
           1822                         ;
           1823                         ;#define	MIN_LP_TIMESLOT		8
           1824                         ;#define	MAX_LP_TIMESLOT		10
           1825                         ;
           1826                         ;// Maximum number of DPA PData bytes ( minus 8 = 6B foursome + 8b error code + 8b DpaValue )
           1827                         ;#define DPA_MAX_DATA_LENGTH			( sizeofBufferCOM - sizeof( TDpaIFaceHeader ) - 2 * sizeof( uns8 ) )
           1828                         ;
           1829                         ;// Maximum number of peripherals info that can fit in the message
           1830                         ;#define	MAX_PERIPHERALS_PER_BLOCK_INFO	( DPA_MAX_DATA_LENGTH / sizeof( TPeripheralInfoAnswer ) )
           1831                         ;
           1832                         ;// Embedded peripheral numbers
           1833                         ;#define	PNUM_COORDINATOR	0x00
           1834                         ;#define	PNUM_NODE			0x01
           1835                         ;#define	PNUM_OS				0x02
           1836                         ;#define	PNUM_EEPROM			0x03
           1837                         ;#define	PNUM_EEEPROM		0x04
           1838                         ;#define	PNUM_RAM			0x05
           1839                         ;#define	PNUM_LEDR			0x06
           1840                         ;#define	PNUM_LEDG			0x07
           1841                         ;#define	PNUM_SPI			0x08
           1842                         ;#define	PNUM_IO				0x09
           1843                         ;#define	PNUM_THERMOMETER	0x0A
           1844                         ;#define	PNUM_UART			0x0C
           1845                         ;#define	PNUM_FRC			0x0D
           1846                         ;
           1847                         ;// Number of the 1st user peripheral
           1848                         ;#define	PNUM_USER			0x20
           1849                         ;// Number of the last user peripheral
           1850                         ;#define	PNUM_USER_MAX		0x3E
           1851                         ;// Maximum peripheral number
           1852                         ;#define	PNUM_MAX			0x7F
           1853                         ;
           1854                         ;// Fake peripheral number used to flag DPA response with error sent by RF
           1855                         ;#define	PNUM_ERROR_FLAG		0xFE
           1856                         ;// Special peripheral used for enumeration
           1857                         ;#define	PNUM_ENUMERATION	0xFF
           1858                         ;
           1859                         ;// DPA Commands for embedded peripherals
           1860                         ;#define	CMD_COORDINATOR_ADDR_INFO  0
           1861                         ;#define	CMD_COORDINATOR_DISCOVERED_DEVICES 1
           1862                         ;#define	CMD_COORDINATOR_BONDED_DEVICES 2
           1863                         ;#define	CMD_COORDINATOR_CLEAR_ALL_BONDS 3
           1864                         ;#define	CMD_COORDINATOR_BOND_NODE 4
           1865                         ;#define	CMD_COORDINATOR_REMOVE_BOND 5
           1866                         ;#define	CMD_COORDINATOR_DISCOVERY 7
           1867                         ;#define	CMD_COORDINATOR_SET_DPAPARAMS 8
           1868                         ;#define	CMD_COORDINATOR_SET_HOPS 9
           1869                         ;#define	CMD_COORDINATOR_BACKUP 11
           1870                         ;#define	CMD_COORDINATOR_RESTORE 12
           1871                         ;#define	CMD_COORDINATOR_AUTHORIZE_BOND 13
           1872                         ;#define	CMD_COORDINATOR_BRIDGE 14
           1873                         ;#define	CMD_COORDINATOR_SMART_CONNECT 18
           1874                         ;#define	CMD_COORDINATOR_SET_MID 19
           1875                         ;
           1876                         ;#define	CMD_NODE_READ 0
           1877                         ;#define	CMD_NODE_REMOVE_BOND 1
           1878                         ;#define	CMD_NODE_BACKUP 6
           1879                         ;#define	CMD_NODE_RESTORE 7
           1880                         ;#define	CMD_NODE_VALIDATE_BONDS 8
           1881                         ;
           1882                         ;#define	CMD_OS_READ 0
           1883                         ;#define	CMD_OS_RESET 1
           1884                         ;#define	CMD_OS_READ_CFG 2
           1885                         ;#define	CMD_OS_RFPGM 3
           1886                         ;#define	CMD_OS_SLEEP 4
           1887                         ;#define	CMD_OS_BATCH 5
           1888                         ;#define	CMD_OS_SET_SECURITY 6
           1889                         ;#define	CMD_OS_INDICATE 7
           1890                         ;#define	CMD_OS_RESTART 8
           1891                         ;#define	CMD_OS_WRITE_CFG_BYTE 9
           1892                         ;#define	CMD_OS_LOAD_CODE 10
           1893                         ;#define	CMD_OS_SELECTIVE_BATCH 11
           1894                         ;#define	CMD_OS_TEST_RF_SIGNAL 12
           1895                         ;#define	CMD_OS_FACTORY_SETTINGS 13
           1896                         ;#define	CMD_OS_WRITE_CFG 15
           1897                         ;
           1898                         ;#define	CMD_RAM_READ 0
           1899                         ;#define	CMD_RAM_WRITE 1
           1900                         ;#define	CMD_RAM_READ_ANY    15
           1901                         ;
           1902                         ;#define	CMD_EEPROM_READ CMD_RAM_READ
           1903                         ;#define	CMD_EEPROM_WRITE CMD_RAM_WRITE
           1904                         ;
           1905                         ;#define	CMD_EEEPROM_XREAD ( CMD_RAM_READ + 2 )
           1906                         ;#define	CMD_EEEPROM_XWRITE ( CMD_RAM_WRITE + 2 )
           1907                         ;
           1908                         ;#define	CMD_LED_SET_OFF 0
           1909                         ;#define	CMD_LED_SET_ON 1
           1910                         ;#define	CMD_LED_PULSE 3
           1911                         ;#define	CMD_LED_FLASHING 4
           1912                         ;
           1913                         ;#define	CMD_SPI_WRITE_READ 0
           1914                         ;
           1915                         ;#define	CMD_IO_DIRECTION  0
           1916                         ;#define	CMD_IO_SET	1
           1917                         ;#define	CMD_IO_GET	2
           1918                         ;
           1919                         ;#define	CMD_THERMOMETER_READ 0
           1920                         ;
           1921                         ;#define	CMD_UART_OPEN 0
           1922                         ;#define	CMD_UART_CLOSE 1
           1923                         ;#define	CMD_UART_WRITE_READ 2
           1924                         ;#define	CMD_UART_CLEAR_WRITE_READ 3
           1925                         ;
           1926                         ;#define	CMD_FRC_SEND 0
           1927                         ;#define	CMD_FRC_EXTRARESULT 1
           1928                         ;#define	CMD_FRC_SEND_SELECTIVE 2
           1929                         ;#define	CMD_FRC_SET_PARAMS 3
           1930                         ;
           1931                         ;#define	CMD_GET_PER_INFO  0x3f
           1932                         ;
           1933                         ;// DPA peripheral type
           1934                         ;typedef enum
           1935                         ;{
           1936                         ;  PERIPHERAL_TYPE_DUMMY = 0x00,
           1937                         ;  PERIPHERAL_TYPE_COORDINATOR = 0x01,
           1938                         ;  PERIPHERAL_TYPE_NODE = 0x02,
           1939                         ;  PERIPHERAL_TYPE_OS = 0x03,
           1940                         ;  PERIPHERAL_TYPE_EEPROM = 0x04,
           1941                         ;  PERIPHERAL_TYPE_BLOCK_EEPROM = 0x05,
           1942                         ;  PERIPHERAL_TYPE_RAM = 0x06,
           1943                         ;  PERIPHERAL_TYPE_LED = 0x07,
           1944                         ;  PERIPHERAL_TYPE_SPI = 0x08,
           1945                         ;  PERIPHERAL_TYPE_IO = 0x09,
           1946                         ;  PERIPHERAL_TYPE_UART = 0x0a,
           1947                         ;  PERIPHERAL_TYPE_THERMOMETER = 0x0b,
           1948                         ;  PERIPHERAL_TYPE_ADC = 0x0c,
           1949                         ;  PERIPHERAL_TYPE_PWM = 0x0d,
           1950                         ;  PERIPHERAL_TYPE_FRC = 0x0e,
           1951                         ;  // Starts peripheral type number interval for user peripherals
           1952                         ;  PERIPHERAL_TYPE_USER_AREA = 0x80
           1953                         ;} TDpaPeripheralType;
           1954                         ;
           1955                         ;// Peripheral extended information
           1956                         ;typedef enum
           1957                         ;{
           1958                         ;  PERIPHERAL_TYPE_EXTENDED_DEFAULT = 0x00,
           1959                         ;  PERIPHERAL_TYPE_EXTENDED_READ = 0x01,
           1960                         ;  PERIPHERAL_TYPE_EXTENDED_WRITE = 0x02,
           1961                         ;  PERIPHERAL_TYPE_EXTENDED_READ_WRITE = PERIPHERAL_TYPE_EXTENDED_READ | PERIPHERAL_TYPE_EXTENDED_WRITE
           1962                         ;} TDpaPeripheralTypeExtended;
           1963                         ;
           1964                         ;// Response packet error codes
           1965                         ;typedef enum
           1966                         ;{
           1967                         ;  // No error
           1968                         ;  STATUS_NO_ERROR = 0,
           1969                         ;
           1970                         ;  // General fail
           1971                         ;  ERROR_FAIL = 1,
           1972                         ;  // Incorrect PCMD
           1973                         ;  ERROR_PCMD = 2,
           1974                         ;  // Incorrect PNUM or PCMD
           1975                         ;  ERROR_PNUM = 3,
           1976                         ;  // Incorrect Address value when addressing memory type peripherals
           1977                         ;  ERROR_ADDR = 4,
           1978                         ;  // Incorrect Data length
           1979                         ;  ERROR_DATA_LEN = 5,
           1980                         ;  // Incorrect Data
           1981                         ;  ERROR_DATA = 6,
           1982                         ;  // Incorrect HWPID used
           1983                         ;  ERROR_HWPID = 7,
           1984                         ;  // Incorrect NADR
           1985                         ;  ERROR_NADR = 8,
           1986                         ;  // IFACE data consumed by Custom DPA Handler
           1987                         ;  ERROR_IFACE_CUSTOM_HANDLER = 9,
           1988                         ;  // Custom DPA Handler is missing
           1989                         ;  ERROR_MISSING_CUSTOM_DPA_HANDLER = 10,
           1990                         ;
           1991                         ;  // Beginning of the user code error interval
           1992                         ;  ERROR_USER_FROM = 0x20,
           1993                         ;  // End of the user code error interval
           1994                         ;  ERROR_USER_TO = 0x3f,
           1995                         ;
           1996                         ;  // Bit/flag reserved for a future use
           1997                         ;  STATUS_RESERVED_FLAG = 0x40,
           1998                         ;  // Bit to flag asynchronous DPA Response from [N]
           1999                         ;  STATUS_ASYNC_RESPONSE = 0x80,
           2000                         ;  // Error code used to mark DPA Confirmation
           2001                         ;  STATUS_CONFIRMATION = 0xff
           2002                         ;} TErrorCodes;
           2003                         ;
           2004                         ;// Embedded FRC commands
           2005                         ;typedef enum
           2006                         ;{
           2007                         ;  // 2 bits
           2008                         ;  FRC_Ping = 0x00,
           2009                         ;  FRC_AcknowledgedBroadcastBits = 0x02,
           2010                         ;  FRC_PrebondedAlive = 0x03,
           2011                         ;  FRC_SupplyVoltage = 0x04,
           2012                         ;  // 1 byte
           2013                         ;  FRC_Temperature = 0x80,
           2014                         ;  FRC_AcknowledgedBroadcastBytes = 0x81,
           2015                         ;  FRC_MemoryRead = 0x82,
           2016                         ;  FRC_MemoryReadPlus1 = 0x83,
           2017                         ;  FRC_FrcResponseTime = 0x84,
           2018                         ;  FRC_TestRFsignal = 0x85,
           2019                         ;  // 4 bytes
           2020                         ;  FRC_PrebondedMemoryReadPlus1 = 0xF8,
           2021                         ;  FRC_MemoryRead4B = 0xFA
           2022                         ;} TFRCommands;
           2023                         ;
           2024                         ;// Intervals of user FRC codes
           2025                         ;#define	FRC_USER_BIT_FROM	  0x40
           2026                         ;#define	FRC_USER_BIT_TO		  0x7F
           2027                         ;#define	FRC_USER_BYTE_FROM	  0xC0
           2028                         ;#define	FRC_USER_BYTE_TO	  0xDF
           2029                         ;#define	FRC_USER_2BYTE_FROM	  0xF0
           2030                         ;#define	FRC_USER_2BYTE_TO	  0xF7
           2031                         ;#define	FRC_USER_4BYTE_FROM	  0xFC
           2032                         ;#define	FRC_USER_4BYTE_TO	  0xFF
           2033                         ;
           2034                         ;// No HWPID specified
           2035                         ;#define HWPID_Default         0x0000
           2036                         ;// Use this type to override HWPID check
           2037                         ;#define HWPID_DoNotCheck      0xFfFf
           2038                         ;
           2039                         ;// RAM peripheral block definitions
           2040                         ;#define	PERIPHERAL_RAM_LENGTH		48
           2041                         ;
           2042                         ;// Start address of EEPROM peripheral in the real EEPROM
           2043                         ;#ifndef COORDINATOR_CUSTOM_HANDLER // Node
           2044                         ;#define	PERIPHERAL_EEPROM_START		( (uns8)0x00 )
           2045                         ;#else // Coordinator
           2046                         ;#define	PERIPHERAL_EEPROM_START		( (uns8)0x80 )
           2047                         ;#endif
           2048                         ;
           2049                         ;// Length of the readable area of serial EEEPROM from the EEEPROM DPA peripheral write point of view. 
           2050                         ;#define	EEEPROM_READ_LENGTH					0x8000
           2051                         ;// Length of the writable area of serial EEEPROM from the EEEPROM DPA peripheral write point of view. 
           2052                         ;#define	EEEPROM_WRITE_LENGTH				0x4000
           2053                         ;
           2054                         ;// Starting address of the Autoexec DPA storage at external EEPROM
           2055                         ;#define	AUTOEXEC_EEEPROM_ADDR				0x0000
           2056                         ;// Length of the autoexec memory block
           2057                         ;#define	AUTOEXEC_LENGTH						sizeofBufferAUX
           2058                         ;
           2059                         ;// Starting address of the IO Setup DPA storage at external EEPROM
           2060                         ;#define	IOSETUP_EEEPROM_ADDR				( AUTOEXEC_EEEPROM_ADDR + AUTOEXEC_LENGTH )
           2061                         ;// Length of the IO setup memory block
           2062                         ;#define	IOSETUP_LENGTH						sizeofBufferAUX
           2063                         ;
           2064                         ;// ---------------------------------------------------------
           2065                         ;
           2066                         ;// Enumerate peripherals structure
           2067                         ;typedef struct
           2068                         ;{
           2069                         ;  uns16	DpaVersion;
           2070                         ;  uns8	UserPerNr;
           2071                         ;  uns8	EmbeddedPers[PNUM_USER / 8];
           2072                         ;  uns16	HWPID;
           2073                         ;  uns16	HWPIDver;
           2074                         ;  uns8	Flags;
           2075                         ;  uns8	UserPer[( PNUM_MAX - PNUM_USER + 1 + 7 ) / 8];
           2076                         ;} STRUCTATTR TEnumPeripheralsAnswer;
           2077                         ;
           2078                         ;#define	FlagUserPer(UserPersArray,UserPerNumber)	UserPersArray[((UserPerNumber)-PNUM_USER) / 8] |= (uns8)0x01 << (((UserPerNumber)-PNUM_USER) % 8);
           2079                         ;
           2080                         ;// Get peripheral info structure (CMD_GET_PER_INFO)
           2081                         ;typedef struct
           2082                         ;{
           2083                         ;  uns8	PerTE;
           2084                         ;  uns8	PerT;
           2085                         ;  uns8	Par1;
           2086                         ;  uns8	Par2;
           2087                         ;} STRUCTATTR TPeripheralInfoAnswer;
           2088                         ;
           2089                         ;// Error DPA response (PNUM_ERROR_FLAG)
           2090                         ;typedef struct
           2091                         ;{
           2092                         ;  uns8	ErrN;
           2093                         ;  uns8	PNUMoriginal;
           2094                         ;} STRUCTATTR TErrorAnswer;
           2095                         ;
           2096                         ;// Structure returned by CMD_COORDINATOR_ADDR_INFO
           2097                         ;typedef struct
           2098                         ;{
           2099                         ;  uns8	DevNr;
           2100                         ;  uns8	DID;
           2101                         ;} STRUCTATTR TPerCoordinatorAddrInfo_Response;
           2102                         ;
           2103                         ;// Structure for CMD_COORDINATOR_BOND_NODE
           2104                         ;typedef struct
           2105                         ;{
           2106                         ;  uns8	ReqAddr;
           2107                         ;  uns8	BondingTestRetries;
           2108                         ;} STRUCTATTR TPerCoordinatorBondNode_Request;
           2109                         ;
           2110                         ;// Structure returned by CMD_COORDINATOR_BOND_NODE or CMD_COORDINATOR_SMART_CONNECT
           2111                         ;typedef struct
           2112                         ;{
           2113                         ;  uns8	BondAddr;
           2114                         ;  uns8	DevNr;
           2115                         ;} STRUCTATTR TPerCoordinatorBondNodeSmartConnect_Response;
           2116                         ;
           2117                         ;// Structure for CMD_COORDINATOR_REMOVE_BOND
           2118                         ;typedef struct
           2119                         ;{
           2120                         ;  uns8	BondAddr;
           2121                         ;} STRUCTATTR TPerCoordinatorRemoveBond_Request;
           2122                         ;
           2123                         ;// Structure returned by CMD_COORDINATOR_REMOVE_BOND
           2124                         ;typedef struct
           2125                         ;{
           2126                         ;  uns8	DevNr;
           2127                         ;} STRUCTATTR TPerCoordinatorRemoveBond_Response;
           2128                         ;
           2129                         ;// Structure for CMD_COORDINATOR_DISCOVERY
           2130                         ;typedef struct
           2131                         ;{
           2132                         ;  uns8	TxPower;
           2133                         ;  uns8	MaxAddr;
           2134                         ;} STRUCTATTR TPerCoordinatorDiscovery_Request;
           2135                         ;
           2136                         ;// Structure returned by CMD_COORDINATOR_DISCOVERY
           2137                         ;typedef struct
           2138                         ;{
           2139                         ;  uns8	DiscNr;
           2140                         ;} STRUCTATTR TPerCoordinatorDiscovery_Response;
           2141                         ;
           2142                         ;// Structure for and also returned by CMD_COORDINATOR_SET_DPAPARAMS
           2143                         ;typedef struct
           2144                         ;{
           2145                         ;  uns8	DpaParam;
           2146                         ;} STRUCTATTR TPerCoordinatorSetDpaParams_Request_Response;
           2147                         ;
           2148                         ;// Structure for and also returned by CMD_COORDINATOR_SET_HOPS
           2149                         ;typedef struct
           2150                         ;{
           2151                         ;  uns8	RequestHops;
           2152                         ;  uns8	ResponseHops;
           2153                         ;} STRUCTATTR TPerCoordinatorSetHops_Request_Response;
           2154                         ;
           2155                         ;// Structure for CMD_COORDINATOR_BACKUP and CMD_NODE_BACKUP
           2156                         ;typedef struct
           2157                         ;{
           2158                         ;  uns8	Index;
           2159                         ;} STRUCTATTR TPerCoordinatorNodeBackup_Request;
           2160                         ;
           2161                         ;// Structure returned by CMD_COORDINATOR_BACKUP and CMD_NODE_BACKUP
           2162                         ;typedef struct
           2163                         ;{
           2164                         ;  uns8	NetworkData[49];
           2165                         ;} STRUCTATTR TPerCoordinatorNodeBackup_Response;
           2166                         ;
           2167                         ;// Structure for CMD_COORDINATOR_RESTORE and CMD_NODE_RESTORE
           2168                         ;typedef struct
           2169                         ;{
           2170                         ;  uns8	NetworkData[49];
           2171                         ;} STRUCTATTR TPerCoordinatorNodeRestore_Request;
           2172                         ;
           2173                         ;// Structure for CMD_COORDINATOR_AUTHORIZE_BOND
           2174                         ;typedef struct
           2175                         ;{
           2176                         ;  uns8	ReqAddr;
           2177                         ;  uns8	MID[4];
           2178                         ;} STRUCTATTR TPerCoordinatorAuthorizeBond_Request;
           2179                         ;
           2180                         ;// Structure returned by CMD_COORDINATOR_AUTHORIZE_BOND
           2181                         ;typedef struct
           2182                         ;{
           2183                         ;  uns8	BondAddr;
           2184                         ;  uns8	DevNr;
           2185                         ;} STRUCTATTR TPerCoordinatorAuthorizeBond_Response;
           2186                         ;
           2187                         ;// Structure for CMD_COORDINATOR_BRIDGE
           2188                         ;typedef struct
           2189                         ;{
           2190                         ;  TDpaIFaceHeader subHeader;
           2191                         ;  uns8	subPData[DPA_MAX_DATA_LENGTH - sizeof( TDpaIFaceHeader )];
           2192                         ;} STRUCTATTR TPerCoordinatorBridge_Request;
           2193                         ;
           2194                         ;// Structure returned by CMD_COORDINATOR_BRIDGE
           2195                         ;typedef struct
           2196                         ;{
           2197                         ;  TDpaIFaceHeader subHeader;
           2198                         ;  uns8	subRespCode;
           2199                         ;  uns8	subDpaValue;
           2200                         ;  uns8	subPData[DPA_MAX_DATA_LENGTH - sizeof( TDpaIFaceHeader ) - 2 * sizeof( uns8 )];
           2201                         ;} STRUCTATTR TPerCoordinatorBridge_Response;
           2202                         ;
           2203                         ;// Structure for CMD_COORDINATOR_SMART_CONNECT
           2204                         ;typedef struct
           2205                         ;{
           2206                         ;  uns8  ReqAddr;
           2207                         ;  uns8  BondingTestRetries;
           2208                         ;  uns8  IBK[16];
           2209                         ;  uns8  MID[4];
           2210                         ;  uns8  reserved0[2];
           2211                         ;  uns8  VirtualDeviceAddress;
           2212                         ;  uns8  reserved1[9];
           2213                         ;  uns8	UserData[4];
           2214                         ;} STRUCTATTR TPerCoordinatorSmartConnect_Request;
           2215                         ;
           2216                         ;// Structure for CMD_COORDINATOR_SET_MID
           2217                         ;typedef struct
           2218                         ;{
           2219                         ;  uns8  MID[4];
           2220                         ;  uns8	BondAddr;
           2221                         ;} STRUCTATTR TPerCoordinatorSetMID_Request;
           2222                         ;
           2223                         ;// Structure returned by CMD_NODE_READ
           2224                         ;typedef struct
           2225                         ;{
           2226                         ;  uns8  ntwADDR;
           2227                         ;  uns8  ntwVRN;
           2228                         ;  uns8  ntwZIN;
           2229                         ;  uns8  ntwDID;
           2230                         ;  uns8  ntwPVRN;
           2231                         ;  uns16 ntwUSERADDRESS;
           2232                         ;  uns16 ntwID;
           2233                         ;  uns8  ntwVRNFNZ;
           2234                         ;  uns8  ntwCFG;
           2235                         ;  uns8  Flags;
           2236                         ;} STRUCTATTR TPerNodeRead_Response;
           2237                         ;
           2238                         ;// Structures for CMD_NODE_VALIDATE_BONDS
           2239                         ;typedef struct
           2240                         ;{
           2241                         ;  uns8	Address;
           2242                         ;  uns8  MID[4];
           2243                         ;} STRUCTATTR TPerNodeValidateBondsItem;
           2244                         ;
           2245                         ;// Structure for CMD_NODE_VALIDATE_BONDS
           2246                         ;typedef struct
           2247                         ;{
           2248                         ;  TPerNodeValidateBondsItem Bonds[DPA_MAX_DATA_LENGTH / sizeof( TPerNodeValidateBondsItem )];
           2249                         ;} STRUCTATTR TPerNodeValidateBonds_Request;
           2250                         ;
           2251                         ;// Structure returned by CMD_OS_READ
           2252                         ;typedef struct
           2253                         ;{
           2254                         ;  uns8	MID[4];
           2255                         ;  uns8	OsVersion;
           2256                         ;  uns8	McuType;
           2257                         ;  uns16	OsBuild;
           2258                         ;  uns8	Rssi;
           2259                         ;  uns8	SupplyVoltage;
           2260                         ;  uns8	Flags;
           2261                         ;  uns8	SlotLimits;
           2262                         ;  uns8  IBK[16];
           2263                         ;  // Enumerate peripherals part, variable length because of UserPer field
           2264                         ;  uns16	DpaVersion;
           2265                         ;  uns8	UserPerNr;
           2266                         ;  uns8	EmbeddedPers[PNUM_USER / 8];
           2267                         ;  uns16	HWPID;
           2268                         ;  uns16	HWPIDver;
           2269                         ;  uns8	FlagsEnum;
           2270                         ;  uns8	UserPer[( PNUM_MAX - PNUM_USER + 1 + 7 ) / 8];
           2271                         ;} STRUCTATTR TPerOSRead_Response;
           2272                         ;
           2273                         ;// Structure returned by CMD_OS_READ_CFG
           2274                         ;typedef struct
           2275                         ;{
           2276                         ;  uns8	Checksum;
           2277                         ;  uns8	Configuration[31];
           2278                         ;  uns8	RFPGM;
           2279                         ;  uns8	Undocumented[1];
           2280                         ;} STRUCTATTR TPerOSReadCfg_Response;
           2281                         ;
           2282                         ;// Structure for CMD_OS_WRITE_CFG
           2283                         ;typedef struct
           2284                         ;{
           2285                         ;  uns8	Undefined;
           2286                         ;  uns8	Configuration[31];
           2287                         ;  uns8	RFPGM;
           2288                         ;} STRUCTATTR TPerOSWriteCfg_Request;
           2289                         ;
           2290                         ;// Structures for CMD_OS_WRITE_CFG_BYTE
           2291                         ;typedef struct
           2292                         ;{
           2293                         ;  uns8	Address;
           2294                         ;  uns8	Value;
           2295                         ;  uns8	Mask;
           2296                         ;} STRUCTATTR TPerOSWriteCfgByteTriplet;
           2297                         ;
           2298                         ;// Structure for CMD_OS_WRITE_CFG_BYTE
           2299                         ;typedef struct
           2300                         ;{
           2301                         ;  TPerOSWriteCfgByteTriplet Triplets[DPA_MAX_DATA_LENGTH / sizeof( TPerOSWriteCfgByteTriplet )];
           2302                         ;} STRUCTATTR TPerOSWriteCfgByte_Request;
           2303                         ;
           2304                         ;// Structure for CMD_OS_SET_SECURITY
           2305                         ;typedef struct
           2306                         ;{
           2307                         ;  uns8	Type;
           2308                         ;  uns8	Data[16];
           2309                         ;} STRUCTATTR TPerOSSetSecurity_Request;
           2310                         ;
           2311                         ;// Structure for CMD_OS_LOAD_CODE
           2312                         ;typedef struct
           2313                         ;{
           2314                         ;  uns8	Flags;
           2315                         ;  uns16	Address;
           2316                         ;  uns16	Length;
           2317                         ;  uns16	CheckSum;
           2318                         ;} STRUCTATTR TPerOSLoadCode_Request;
           2319                         ;
           2320                         ;// Structure for CMD_OS_SLEEP
           2321                         ;typedef struct
           2322                         ;{
           2323                         ;  uns16	Time;
           2324                         ;  uns8	Control;
           2325                         ;} STRUCTATTR TPerOSSleep_Request;
           2326                         ;
           2327                         ;// Structure for CMD_OS_SELECTIVE_BATCH
           2328                         ;typedef struct
           2329                         ;{
           2330                         ;  uns8	SelectedNodes[30];
           2331                         ;  uns8	Requests[DPA_MAX_DATA_LENGTH - 30];
           2332                         ;} STRUCTATTR TPerOSSelectiveBatch_Request;
           2333                         ;
           2334                         ;// Structure for CMD_OS_TEST_RF_SIGNAL request
           2335                         ;typedef struct
           2336                         ;{
           2337                         ;  uns8  Channel;
           2338                         ;  uns8  RXfilter;
           2339                         ;  uns16 Time;
           2340                         ;} STRUCTATTR TPerOSTestRfSignal_Request;
           2341                         ;
           2342                         ;// Structure for CMD_OS_TEST_RF_SIGNAL response
           2343                         ;typedef struct
           2344                         ;{
           2345                         ;  uns8  Counter;
           2346                         ;} STRUCTATTR TPerOSTestRfSignal_Response;
           2347                         ;
           2348                         ;// Structure for CMD_OS_INDICATE request
           2349                         ;typedef struct
           2350                         ;{
           2351                         ;  uns8  Control;
           2352                         ;} STRUCTATTR TPerOSIndicate_Request;
           2353                         ;
           2354                         ;// Structure for general memory request
           2355                         ;typedef struct
           2356                         ;{
           2357                         ;  // Address of data to write or read
           2358                         ;  uns8	Address;
           2359                         ;
           2360                         ;  union
           2361                         ;  {
           2362                         ;    // Memory read request
           2363                         ;    struct
           2364                         ;    {
           2365                         ;      // Length of data to read
           2366                         ;      uns8	Length;
           2367                         ;    } Read;
           2368                         ;
           2369                         ;    // Size of Address field
           2370                         ;#define	MEMORY_WRITE_REQUEST_OVERHEAD	( sizeof( uns8 ) )
           2371                         ;
           2372                         ;    // Memory write request
           2373                         ;    struct
           2374                         ;    {
           2375                         ;      uns8	PData[DPA_MAX_DATA_LENGTH - MEMORY_WRITE_REQUEST_OVERHEAD];
           2376                         ;    } Write;
           2377                         ;
           2378                         ;  } ReadWrite;
           2379                         ;} STRUCTATTR TPerMemoryRequest;
           2380                         ;
           2381                         ;// Structure for general extended memory request
           2382                         ;typedef struct
           2383                         ;{
           2384                         ;  // Address of data to write or read
           2385                         ;  uns16	Address;
           2386                         ;
           2387                         ;  union
           2388                         ;  {
           2389                         ;    // Memory read request
           2390                         ;    struct
           2391                         ;    {
           2392                         ;      // Length of data to read
           2393                         ;      uns8	Length;
           2394                         ;    } Read;
           2395                         ;
           2396                         ;    // Size of Address field
           2397                         ;#define	XMEMORY_WRITE_REQUEST_OVERHEAD	( sizeof( uns16 ) )
           2398                         ;
           2399                         ;    // Memory write request
           2400                         ;    struct
           2401                         ;    {
           2402                         ;      uns8	PData[DPA_MAX_DATA_LENGTH - XMEMORY_WRITE_REQUEST_OVERHEAD];
           2403                         ;    } Write;
           2404                         ;
           2405                         ;  } ReadWrite;
           2406                         ;} STRUCTATTR TPerXMemoryRequest;
           2407                         ;
           2408                         ;// Structure for CMD_IO requests
           2409                         ;typedef struct
           2410                         ;{
           2411                         ;  uns8  Port;
           2412                         ;  uns8  Mask;
           2413                         ;  uns8  Value;
           2414                         ;} STRUCTATTR TPerIOTriplet;
           2415                         ;
           2416                         ;typedef struct
           2417                         ;{
           2418                         ;  uns8  Header;	// == PNUM_IO_DELAY
           2419                         ;  uns16 Delay;
           2420                         ;} STRUCTATTR TPerIODelay;
           2421                         ;
           2422                         ;// Union for CMD_IO_SET and CMD_IO_DIRECTION requests
           2423                         ;typedef union
           2424                         ;{
           2425                         ;  TPerIOTriplet Triplets[DPA_MAX_DATA_LENGTH / sizeof( TPerIOTriplet )];
           2426                         ;  TPerIODelay   Delays[DPA_MAX_DATA_LENGTH / sizeof( TPerIODelay )];
           2427                         ;} STRUCTATTR TPerIoDirectionAndSet_Request;
           2428                         ;
           2429                         ;// Structure returned by CMD_THERMOMETER_READ
           2430                         ;typedef struct
           2431                         ;{
           2432                         ;  int8  IntegerValue;
           2433                         ;  int16 SixteenthValue;
           2434                         ;} STRUCTATTR TPerThermometerRead_Response;
           2435                         ;
           2436                         ;// Structure for CMD_UART_OPEN
           2437                         ;typedef struct
           2438                         ;{
           2439                         ;  uns8  BaudRate;
           2440                         ;} STRUCTATTR TPerUartOpen_Request;
           2441                         ;
           2442                         ;// Structure for CMD_UART_[CLEAR_]WRITE_READ and CMD_SPI_WRITE_READ
           2443                         ;typedef struct
           2444                         ;{
           2445                         ;  uns8  ReadTimeout;
           2446                         ;  uns8	WrittenData[DPA_MAX_DATA_LENGTH - sizeof( uns8 )];
           2447                         ;} STRUCTATTR TPerUartSpiWriteRead_Request;
           2448                         ;
           2449                         ;// Structure for CMD_FRC_SEND
           2450                         ;typedef struct
           2451                         ;{
           2452                         ;  uns8  FrcCommand;
           2453                         ;  uns8	UserData[30];
           2454                         ;} STRUCTATTR TPerFrcSend_Request;
           2455                         ;
           2456                         ;// Structure for CMD_FRC_SEND_SELECTIVE
           2457                         ;typedef struct
           2458                         ;{
           2459                         ;  uns8  FrcCommand;
           2460                         ;  uns8	SelectedNodes[30];
           2461                         ;  uns8	UserData[25];
           2462                         ;} STRUCTATTR TPerFrcSendSelective_Request;
           2463                         ;
           2464                         ;// Structure returned by CMD_FRC_SEND and CMD_FRC_SEND_SELECTIVE
           2465                         ;typedef struct
           2466                         ;{
           2467                         ;  uns8  Status;
           2468                         ;  uns8	FrcData[DPA_MAX_DATA_LENGTH - sizeof( uns8 )];
           2469                         ;} STRUCTATTR TPerFrcSend_Response;
           2470                         ;
           2471                         ;// Structure for request and response of CMD_FRC_SET_PARAMS
           2472                         ;typedef struct
           2473                         ;{
           2474                         ;  uns8	FRCresponseTime;
           2475                         ;} STRUCTATTR TPerFrcSetParams_RequestResponse;
           2476                         ;
           2477                         ;// Interface and CMD_COORDINATOR_BRIDGE confirmation structure
           2478                         ;typedef struct
           2479                         ;{
           2480                         ;  // Number of hops
           2481                         ;  uns8  Hops;
           2482                         ;  // Time slot length in 10ms
           2483                         ;  uns8  TimeSlotLength;
           2484                         ;  // Number of hops for response
           2485                         ;  uns8  HopsResponse;
           2486                         ;} STRUCTATTR TIFaceConfirmation;
           2487                         ;
           2488                         ;// ---------------------------------------------------------
           2489                         ;
           2490                         ;// DPA Message data structure (packet w/o NADR, PNUM, PCMD, HWPID)
           2491                         ;typedef union
           2492                         ;{
           2493                         ;  // General DPA request
           2494                         ;  struct
           2495                         ;  {
           2496                         ;    uns8	PData[DPA_MAX_DATA_LENGTH];
           2497                         ;  } Request;
           2498                         ;
           2499                         ;  // General DPA response
           2500                         ;  struct
           2501                         ;  {
           2502                         ;    uns8	PData[DPA_MAX_DATA_LENGTH];
           2503                         ;  } Response;
           2504                         ;
           2505                         ;  // Enumerate peripherals structure
           2506                         ;  TEnumPeripheralsAnswer EnumPeripheralsAnswer;
           2507                         ;
           2508                         ;  // Get peripheral info structure (CMD_GET_PER_INFO)
           2509                         ;  TPeripheralInfoAnswer PeripheralInfoAnswer;
           2510                         ;
           2511                         ;  // Get peripheral info structure (CMD_GET_PER_INFO) for more peripherals
           2512                         ;  TPeripheralInfoAnswer PeripheralInfoAnswers[MAX_PERIPHERALS_PER_BLOCK_INFO];
           2513                         ;
           2514                         ;  // Error DPA response (PNUM_ERROR_FLAG)
           2515                         ;  TErrorAnswer ErrorAnswer;
           2516                         ;
           2517                         ;  // Structure returned by CMD_COORDINATOR_ADDR_INFO
           2518                         ;  TPerCoordinatorAddrInfo_Response PerCoordinatorAddrInfo_Response;
           2519                         ;
           2520                         ;  // Structure for CMD_COORDINATOR_BOND_NODE
           2521                         ;  TPerCoordinatorBondNode_Request PerCoordinatorBondNode_Request;
           2522                         ;
           2523                         ;  // Structure returned by CMD_COORDINATOR_BOND_NODE or CMD_COORDINATOR_SMART_CONNECT
           2524                         ;  TPerCoordinatorBondNodeSmartConnect_Response PerCoordinatorBondNodeSmartConnect_Response;
           2525                         ;
           2526                         ;  // Structure for CMD_COORDINATOR_REMOVE_BOND
           2527                         ;  TPerCoordinatorRemoveBond_Request PerCoordinatorRemoveBond_Request;
           2528                         ;
           2529                         ;  // Structure returned by CMD_COORDINATOR_REMOVE_BOND 
           2530                         ;  TPerCoordinatorRemoveBond_Response PerCoordinatorRemoveBond_Response;
           2531                         ;
           2532                         ;  // Structure for CMD_COORDINATOR_DISCOVERY
           2533                         ;  TPerCoordinatorDiscovery_Request PerCoordinatorDiscovery_Request;
           2534                         ;
           2535                         ;  // Structure returned by CMD_COORDINATOR_DISCOVERY
           2536                         ;  TPerCoordinatorDiscovery_Response PerCoordinatorDiscovery_Response;
           2537                         ;
           2538                         ;  // Structure for and also returned by CMD_COORDINATOR_SET_DPAPARAMS
           2539                         ;  TPerCoordinatorSetDpaParams_Request_Response PerCoordinatorSetDpaParams_Request_Response;
           2540                         ;
           2541                         ;  // Structure for and also returned by CMD_COORDINATOR_SET_HOPS
           2542                         ;  TPerCoordinatorSetHops_Request_Response PerCoordinatorSetHops_Request_Response;
           2543                         ;
           2544                         ;  // Structure for CMD_COORDINATOR_BACKUP and CMD_NODE_BACKUP
           2545                         ;  TPerCoordinatorNodeBackup_Request PerCoordinatorNodeBackup_Request;
           2546                         ;
           2547                         ;  // Structure returned by CMD_COORDINATOR_BACKUP and CMD_NODE_BACKUP
           2548                         ;  TPerCoordinatorNodeBackup_Response PerCoordinatorNodeBackup_Response;
           2549                         ;
           2550                         ;  // Structure for CMD_COORDINATOR_RESTORE and CMD_NODE_RESTORE
           2551                         ;  TPerCoordinatorNodeRestore_Request PerCoordinatorNodeRestore_Request;
           2552                         ;
           2553                         ;  // Structure for CMD_COORDINATOR_AUTHORIZE_BOND
           2554                         ;  TPerCoordinatorAuthorizeBond_Request PerCoordinatorAuthorizeBond_Request;
           2555                         ;
           2556                         ;  // Structure returned by CMD_COORDINATOR_AUTHORIZE_BOND
           2557                         ;  TPerCoordinatorAuthorizeBond_Response PerCoordinatorAuthorizeBond_Response;
           2558                         ;
           2559                         ;  // Structure for CMD_COORDINATOR_BRIDGE
           2560                         ;  TPerCoordinatorBridge_Request PerCoordinatorBridge_Request;
           2561                         ;
           2562                         ;  // Structure returned by CMD_COORDINATOR_BRIDGE
           2563                         ;  TPerCoordinatorBridge_Response PerCoordinatorBridge_Response;
           2564                         ;
           2565                         ;  // Structure for CMD_COORDINATOR_SMART_CONNECT
           2566                         ;  TPerCoordinatorSmartConnect_Request PerCoordinatorSmartConnect_Request;
           2567                         ;
           2568                         ;  // Structure for CMD_COORDINATOR_SET_MID
           2569                         ;  TPerCoordinatorSetMID_Request PerCoordinatorSetMID_Request;
           2570                         ;
           2571                         ;  // Structure returned by CMD_NODE_READ
           2572                         ;  TPerNodeRead_Response PerNodeRead_Response;
           2573                         ;
           2574                         ;  // Structure for CMD_NODE_VALIDATE_BONDS
           2575                         ;  TPerNodeValidateBonds_Request PerNodeValidateBonds_Request;
           2576                         ;
           2577                         ;  // Structure returned by CMD_OS_READ
           2578                         ;  TPerOSRead_Response PerOSRead_Response;
           2579                         ;
           2580                         ;  // Structure returned by CMD_OS_READ_CFG
           2581                         ;  TPerOSReadCfg_Response PerOSReadCfg_Response;
           2582                         ;
           2583                         ;  // Structure for CMD_OS_WRITE_CFG
           2584                         ;  TPerOSWriteCfg_Request PerOSWriteCfg_Request;
           2585                         ;
           2586                         ;  // Structure for CMD_OS_WRITE_CFG_BYTE
           2587                         ;  TPerOSWriteCfgByte_Request PerOSWriteCfgByte_Request;
           2588                         ;
           2589                         ;  // Structure for CMD_OS_SET_SECURITY
           2590                         ;  TPerOSSetSecurity_Request PerOSSetSecurity_Request;
           2591                         ;
           2592                         ;  // Structure for CMD_OS_LOAD_CODE
           2593                         ;  TPerOSLoadCode_Request PerOSLoadCode_Request;
           2594                         ;
           2595                         ;  // Structure for CMD_OS_SLEEP
           2596                         ;  TPerOSSleep_Request PerOSSleep_Request;
           2597                         ;
           2598                         ;  // Structure for CMD_OS_SELECTIVE_BATCH
           2599                         ;  TPerOSSelectiveBatch_Request PerOSSelectiveBatch_Request;
           2600                         ;
           2601                         ;  // Structure for CMD_OS_TEST_RF_SIGNAL request
           2602                         ;  TPerOSTestRfSignal_Request PerOSTestRfSignal_Request;
           2603                         ;
           2604                         ;  // Structure for CMD_OS_INDICATE request
           2605                         ;  TPerOSIndicate_Request PerOSIndicate_Request;
           2606                         ;
           2607                         ;  // Structure for CMD_OS_TEST_RF_SIGNAL response
           2608                         ;  TPerOSTestRfSignal_Response PerOSTestRfSignal_Response;
           2609                         ;
           2610                         ;  // Structure for general memory request
           2611                         ;  TPerMemoryRequest MemoryRequest;
           2612                         ;
           2613                         ;  // Structure for general extended memory request
           2614                         ;  TPerXMemoryRequest XMemoryRequest;
           2615                         ;
           2616                         ;  // Structure for CMD_IO requests
           2617                         ;  TPerIoDirectionAndSet_Request PerIoDirectionAndSet_Request;
           2618                         ;
           2619                         ;  // Structure returned by CMD_THERMOMETER_READ
           2620                         ;  TPerThermometerRead_Response PerThermometerRead_Response;
           2621                         ;
           2622                         ;  // Structure for CMD_UART_OPEN
           2623                         ;  TPerUartOpen_Request PerUartOpen_Request;
           2624                         ;
           2625                         ;  // Structure for CMD_UART_[CLEAR_]WRITE_READ and CMD_SPI_WRITE_READ
           2626                         ;  TPerUartSpiWriteRead_Request PerUartSpiWriteRead_Request;
           2627                         ;
           2628                         ;  // Structure for CMD_FRC_SEND
           2629                         ;  TPerFrcSend_Request PerFrcSend_Request;
           2630                         ;
           2631                         ;  // Structure returned by CMD_FRC_SEND and CMD_FRC_SEND_SELECTIVE
           2632                         ;  TPerFrcSend_Response PerFrcSend_Response;
           2633                         ;
           2634                         ;  // Structure for CMD_FRC_SEND_SELECTIVE
           2635                         ;  TPerFrcSendSelective_Request PerFrcSendSelective_Request;
           2636                         ;
           2637                         ;  // Structure for request and response of CMD_FRC_SET_PARAMS
           2638                         ;  TPerFrcSetParams_RequestResponse PerFrcSetParams_RequestResponse;
           2639                         ;
           2640                         ;  // Interface and CMD_COORDINATOR_BRIDGE confirmation structure
           2641                         ;  TIFaceConfirmation IFaceConfirmation;
           2642                         ;} TDpaMessage;
           2643                         ;
           2644                         ;// Custom DPA Handler events
           2645                         ;#define	DpaEvent_DpaRequest				  0
           2646                         ;#define	DpaEvent_Interrupt				  1
           2647                         ;#define	DpaEvent_Idle					  2
           2648                         ;#define	DpaEvent_Init					  3
           2649                         ;#define	DpaEvent_Notification			  4
           2650                         ;#define	DpaEvent_AfterRouting			  5
           2651                         ;#define	DpaEvent_BeforeSleep			  6
           2652                         ;#define	DpaEvent_AfterSleep				  7
           2653                         ;#define	DpaEvent_Reset					  8
           2654                         ;#define	DpaEvent_DisableInterrupts		  9
           2655                         ;#define	DpaEvent_FrcValue				  10
           2656                         ;#define	DpaEvent_ReceiveDpaResponse		  11
           2657                         ;#define	DpaEvent_IFaceReceive			  12
           2658                         ;#define	DpaEvent_ReceiveDpaRequest		  13
           2659                         ;#define	DpaEvent_BeforeSendingDpaResponse 14
           2660                         ;#define	DpaEvent_PeerToPeer				  15
           2661                         ;#define	DpaEvent_UserDpaValue			  17
           2662                         ;#define	DpaEvent_FrcResponseTime		  18
           2663                         ;#define	DpaEvent_BondingButton			  19
           2664                         ;#define	DpaEvent_Indicate    			  20
           2665                         ;
           2666                         ;#define	DpaEvent_LAST					  DpaEvent_Indicate
           2667                         ;
           2668                         ;// Types of the diagnostic DPA Value that is returned inside DPA response 
           2669                         ;typedef enum
           2670                         ;{
           2671                         ;  DpaValueType_RSSI = 0,
           2672                         ;  DpaValueType_SupplyVoltage = 1,
           2673                         ;  DpaValueType_System = 2,
           2674                         ;  DpaValueType_User = 3
           2675                         ;} TDpaValueType;
           2676                         ;
           2677                         ;// Type (color) of LED peripheral
           2678                         ;typedef enum
           2679                         ;{
           2680                         ;  LED_COLOR_RED = 0,
           2681                         ;  LED_COLOR_GREEN = 1,
           2682                         ;  LED_COLOR_BLUE = 2,
           2683                         ;  LED_COLOR_YELLOW = 3,
           2684                         ;  LED_COLOR_WHITE = 4,
           2685                         ;  LED_COLOR_UNKNOWN = 0xff
           2686                         ;} TLedColor;
           2687                         ;
           2688                         ;// Baud rates
           2689                         ;typedef enum
           2690                         ;{
           2691                         ;  DpaBaud_1200 = 0x00,
           2692                         ;  DpaBaud_2400 = 0x01,
           2693                         ;  DpaBaud_4800 = 0x02,
           2694                         ;  DpaBaud_9600 = 0x03,
           2695                         ;  DpaBaud_19200 = 0x04,
           2696                         ;  DpaBaud_38400 = 0x05,
           2697                         ;  DpaBaud_57600 = 0x06,
           2698                         ;  DpaBaud_115200 = 0x07,
           2699                         ;  DpaBaud_230400 = 0x08
           2700                         ;} TBaudRates;
           2701                         ;
           2702                         ;// Useful PNUM_IO definitions
           2703                         ;typedef enum
           2704                         ;{
           2705                         ;  PNUM_IO_PORTA = 0x00,
           2706                         ;  PNUM_IO_TRISA = 0x00,
           2707                         ;  PNUM_IO_PORTB = 0x01,
           2708                         ;  PNUM_IO_TRISB = 0x01,
           2709                         ;  PNUM_IO_PORTC = 0x02,
           2710                         ;  PNUM_IO_TRISC = 0x02,
           2711                         ;  PNUM_IO_PORTE = 0x04,
           2712                         ;  PNUM_IO_TRISE = 0x04,
           2713                         ;  PNUM_IO_WPUB = 0x11,
           2714                         ;  PNUM_IO_DELAY = 0xff
           2715                         ;} PNUM_IO_Definitions;
           2716                         ;
           2717                         ;// To test for enumeration peripherals request
           2718                         ;#define IsDpaEnumPeripheralsRequestNoSize() ( _PNUM == PNUM_ENUMERATION && _PCMD == CMD_GET_PER_INFO )
           2719                         ;
           2720                         ;#if PARAM_CHECK_LEVEL >= 2
           2721                         ;#define IsDpaEnumPeripheralsRequest() ( IsDpaEnumPeripheralsRequestNoSize() && _DpaDataLength == 0 )
           2722                         ;#else
           2723                         ;#define IsDpaEnumPeripheralsRequest() IsDpaEnumPeripheralsRequestNoSize()
           2724                         ;#endif
           2725                         ;
           2726                         ;// To test for peripherals information request
           2727                         ;#define IsDpaPeripheralInfoRequestNoSize()  ( _PNUM != PNUM_ENUMERATION && _PCMD == CMD_GET_PER_INFO )
           2728                         ;
           2729                         ;#if PARAM_CHECK_LEVEL >= 2
           2730                         ;#define IsDpaPeripheralInfoRequest()  ( IsDpaPeripheralInfoRequestNoSize() && _DpaDataLength == 0 )
           2731                         ;#else
           2732                         ;#define IsDpaPeripheralInfoRequest()  IsDpaPeripheralInfoRequestNoSize()
           2733                         ;#endif
           2734                         ;
           2735                         ;// Optimized macro for both testing enumeration peripherals ELSE peripherals information. See examples
           2736                         ;#define	IfDpaEnumPeripherals_Else_PeripheralInfo_Else_PeripheralRequestNoSize() if ( _PCMD == CMD_GET_PER_INFO ) if ( _PNUM == PNUM_ENUMERATION )
           2737                         ;
           2738                         ;#if PARAM_CHECK_LEVEL >= 2
           2739                         ;#define IfDpaEnumPeripherals_Else_PeripheralInfo_Else_PeripheralRequest() if ( _DpaDataLength == 0 && _PCMD == CMD_GET_PER_INFO ) if ( _PNUM == PNUM_ENUMERATION )
           2740                         ;#else
           2741                         ;#define	IfDpaEnumPeripherals_Else_PeripheralInfo_Else_PeripheralRequest() IfDpaEnumPeripherals_Else_PeripheralInfo_Else_PeripheralRequestNoSize()
           2742                         ;#endif
           2743                         ;
           2744                         ;#ifdef __CC5X__
           2745                         ;
           2746                         ;// DPA message at bufferRF
           2747                         ;TDpaMessage DpaRfMessage @bufferRF;
           2748                         ;
           2749                         ;// Actual allocation of the RAM Peripheral memory block @ UserBank_02
           2750                         ;bank12 uns8  PeripheralRam[PERIPHERAL_RAM_LENGTH] @ 0x620;
           2751                         ;
           2752                         ;// Actual DPA message parameters at memory
           2753                         ;#define	_NADR			RX
           2754                         ;#define _NADRhigh		RTAUX
           2755                         ;#define _PNUM			PNUM
           2756                         ;#define _PCMD			PCMD
           2757                         ;#define _DpaDataLength	DLEN
           2758                         ;#define _DpaMessage		DpaRfMessage
           2759                         ;
           2760                         ;// Return actual DPA user routine event
           2761                         ;#define	GetDpaEvent()	userReg0
           2762                         ;
           2763                         ;// Stores DPA Params inside DPA request/response
           2764                         ;#define	_DpaParams		PPAR
           2765                         ;// Get DPA Value type out of the DPA Params
           2766                         ;#define	DpaValueType()	( _DpaParams & 0b11 )
           2767                         ;
           2768                         ;// When TRUE then encryptBufferRF/decryptBufferRF is done by AccessPassord
           2769                         ;bit encryptByAccessPassword @ usedBank0[0x23].7;
           2770                         ;
           2771                         ;// DP2P response time-slot time in 10 ms
           2772                         ;#define DP2P_TIMESLOT   11
           2773                         ;
           2774                         ;// DP2P request packet. Fills out the whole bufferRF.
           2775                         ;typedef struct
           2776                         ;{
           2777                         ;  uns8  Header[3];  // 0x000000
           2778                         ;  uns8  SelectedNodes[30];
           2779                         ;  uns8  SlotLength;
           2780                         ;  uns8  ResponseTxPower;
           2781                         ;  uns8  Reserved;
           2782                         ;  uns16	HWPID;
           2783                         ;  uns8  PDATA[sizeofBufferRF - ( 3 + 30 + 1 + 1 + 1 ) * sizeof( uns8 ) - ( 1 ) * sizeof( uns16 )]; // size is 26 bytes
           2784                         ;} STRUCTATTR TDP2Prequest;
           2785                         ;
           2786                         ;// DP2P invite packet.
           2787                         ;typedef struct
           2788                         ;{
           2789                         ;  uns8  Header[3];  // 0x000001
           2790                         ;  uns8  NADR;
           2791                         ;  uns8  Rand[12];
           2792                         ;} STRUCTATTR TDP2Invite;
           2793                         ;
           2794                         ;// DP2P confirm packet.
           2795                         ;typedef struct
           2796                         ;{
           2797                         ;  uns8  Header[3];  // 0x000003
           2798                         ;  uns8  NADR;
           2799                         ;  uns8  Rand[12];
           2800                         ;} STRUCTATTR TDP2Confirm;
           2801                         ;
           2802                         ;// DP2P response packet.
           2803                         ;typedef struct
           2804                         ;{
           2805                         ;  uns8  Header[3];  // 0xFfFfFf
           2806                         ;  uns8  NADR;
           2807                         ;  uns8  PDATA[DPA_MAX_DATA_LENGTH];
           2808                         ;} STRUCTATTR TDP2Presponse;
           2809                         ;
           2810                         ;// Include assembler definitions
           2811                         ;#include "HexCodes.h"
           2812                         ;
           2813                         ;// Next code must start at the IQRF APPLICATION routine entry point
           2814                         ;#pragma origin __APPLICATION_ADDRESS
     0000  2815         ORG 0x3A00
           2816 
           2817   ; FILE ../../../../Development/include/DPA/DPAcustomHandler.h
           2818                         ;// *********************************************************************
           2819                         ;//   Main Custom DPA Handler header                                    *
           2820                         ;// *********************************************************************
           2821                         ;// Copyright (c) IQRF Tech s.r.o.
           2822                         ;//
           2823                         ;// File:    $RCSfile: DPAcustomHandler.h,v $
           2824                         ;// Version: $Revision: 1.113 $
           2825                         ;// Date:    $Date: 2020/02/27 13:17:18 $
           2826                         ;//
           2827                         ;// Revision history:
           2828                         ;//   2020/02/27  Release for DPA 4.13
           2829                         ;//   2020/01/09  Release for DPA 4.12
           2830                         ;//   2019/12/11  Release for DPA 4.11
           2831                         ;//   2019/10/09  Release for DPA 4.10
           2832                         ;//   2019/06/12  Release for DPA 4.03
           2833                         ;//   2019/06/03  Release for DPA 4.02
           2834                         ;//   2019/03/07  Release for DPA 4.01
           2835                         ;//   2019/01/10  Release for DPA 4.00
           2836                         ;//   2018/10/25  Release for DPA 3.03
           2837                         ;//   2017/11/16  Release for DPA 3.02
           2838                         ;//   2017/08/14  Release for DPA 3.01
           2839                         ;//   2017/03/13  Release for DPA 3.00
           2840                         ;//   2016/09/12  Release for DPA 2.28
           2841                         ;//   2016/04/14  Release for DPA 2.27
           2842                         ;//   2016/03/03  Release for DPA 2.26
           2843                         ;//   2016/01/21  Release for DPA 2.25
           2844                         ;//   2015/12/01  Release for DPA 2.24
           2845                         ;//   2015/10/23  Release for DPA 2.23
           2846                         ;//   2015/09/25  Release for DPA 2.22
           2847                         ;//   2015/09/03  Release for DPA 2.21
           2848                         ;//   2015/08/05  Release for DPA 2.20
           2849                         ;//   2014/10/31  Release for DPA 2.10
           2850                         ;//   2014/04/30  Release for DPA 2.00
           2851                         ;//   2013/10/03  Release for DPA 1.00
           2852                         ;//
           2853                         ;// *********************************************************************
           2854                         ;
           2855                         ;// Online DPA documentation https://doc.iqrf.org/DpaTechGuide/
           2856                         ;// IQRF Standards documentation https://www.iqrfalliance.org/iqrf-interoperability/
           2857                         ;
           2858                         ;#ifndef _CUSTOM_DPA_HANDLER_
           2859                         ;#define _CUSTOM_DPA_HANDLER_
           2860                         ;
           2861                         ;//############################################################################################
           2862                         ;// 1st include 
           2863                         ;
           2864                         ;// Custom DPA Handler routine declaration
           2865                         ;bit CustomDpaHandler();
           2866                         ;
           2867                         ;// Various DPA flags shared between DPA and Custom DPA Handler
           2868                         ;uns8 DpaFlags @ usedBank4[0];
           2869                         ;#ifdef COORDINATOR_CUSTOM_HANDLER
           2870                         ;// [C] TRUE if interface master is not connected (detected)
           2871                         ;bit IFaceMasterNotConnected @ DpaFlags.2;
           2872                         ;#endif
           2873                         ;// [N] [CN] DPA by interface notification is sent also when there was a "reading" like DPA request
           2874                         ;bit EnableIFaceNotificationOnRead @ DpaFlags.3;
           2875                         ;// [N] [NC] TRUE when node was just bonded using default bonding procedure
           2876                         ;bit NodeWasBonded @ DpaFlags.4;
           2877                         ;
           2878                         ;// [C] Ticks (decrementing) counter usable for timing in the coordinator's Customer DPA Handler
           2879                         ;uns16 DpaTicks @ usedBank4[1];
           2880                         ;// [N] [NC] toutRF for LP mode, read from configuration memory after reset
           2881                         ;uns8 LPtoutRF @ usedBank4[3];
           2882                         ;// DPA Request/Response HWPID
           2883                         ;uns16 _HWPID @ usedBank4[4];
           2884                         ;// Identifies type of reset (stored at UserReg0 upon module reset). See Reset chapter at IQRF User's Guide for more information
           2885                         ;uns8 ResetType @ usedBank4[6];
           2886                         ;// User DPA Values to return
           2887                         ;uns8 UserDpaValue @ usedBank4[7];
           2888                         ;// Network depth of the DPA request/response, increases on bridging, decreases on back-bridging
           2889                         ;uns8 NetDepth @ usedBank4[8];
           2890                         ;// TRUE when node was at DPA Service Mode after last boot
           2891                         ;bit DSMactivated @ usedBank4[9].0;
           2892                         ;// If set to TRUE, then LP RX mode in the main loop can be terminated by pin, see _RLPMAT
           2893                         ;bit LpRxPinTerminate @ usedBank4[9].1;
           2894                         ;// If set to TRUE, then [C] executes asynchronous DPA requests received from [N]
           2895                         ;bit AsyncReqAtCoordinator @ usedBank4[9].2;
           2896                         ;// RX filter used at the DPA main loop checkRF call
           2897                         ;uns8 RxFilter @ usedBank4[11];
           2898                         ;// Countdown variable for button bonding before going to deep sleep 
           2899                         ;uns16 BondingSleepCountdown @ usedBank4[12];
           2900                         ;#define BONDING_SLEEP_COUNTDOWN_UNIT  290
           2901                         ;// Non-zero pseudo-random value, read-only, updated on every Reset and Idle event, at [N] only.
           2902                         ;uns16 Random @ usedBank4[14];
           2903                         ;
           2904                         ;// Macro to return an error from the peripheral handler. If the code size is not an issue this macro is the right choice.
           2905                         ;#define DpaApiReturnPeripheralError(error) do { \
           2906                         ;	DpaApiSetPeripheralError( error ); \
           2907                         ;	return Carry; \
           2908                         ;  } while( 0 )
           2909                         ;
           2910                         ;// DPA API functions, see documentation for details
           2911                         ;#define	DpaApiRfTxDpaPacket( dpaValue, netDepthAndFlags ) DpaApiEntry( dpaValue, netDepthAndFlags, DPA_API_RFTX_DPAPACKET )
           2912                         ;#define	DpaApiReadConfigByte( index )					  DpaApiEntry( index, param3.low8, DPA_API_READ_CONFIG_BYTE )
           2913                         ;#define	DpaApiLocalRequest()							  DpaApiEntry( param2, param3.low8, DPA_API_LOCAL_REQUEST )
           2914                         ;#define	DpaApiSetPeripheralError( error )				  DpaApiEntry( error, param3.low8, DPA_API_SET_PERIPHERAL_ERROR )
           2915                         ;#define	DpaApiSendToIFaceMaster( dpaValue, flags )		  DpaApiEntry( dpaValue, flags, DPA_API_SEND_TO_IFACEMASTER )
           2916                         ;#define	DpaApiSetRfDefaults()							  DpaApiEntry( param2, param3.low8, DPA_API_SET_RF_DEFAULTS )
           2917                         ;
           2918                         ;#ifdef COORDINATOR_CUSTOM_HANDLER
           2919                         ;#define	DpaApiRfTxDpaPacketCoordinator()				  DpaApiEntry( param2, param3.low8, DPA_API_COORDINATOR_RFTX_DPAPACKET )
           2920                         ;#endif
           2921                         ;
           2922                         ;#ifdef COORDINATOR_CUSTOM_HANDLER
           2923                         ;#undef	DpaEvent_Interrupt
           2924                         ;#undef	DpaEvent_BeforeSleep
           2925                         ;#undef	DpaEvent_AfterSleep
           2926                         ;#undef	DpaEvent_FrcValue
           2927                         ;#undef	DpaEvent_FrcResponseTime
           2928                         ;#else
           2929                         ;#undef  DpaEvent_ReceiveDpaResponse
           2930                         ;#undef  DpaEvent_IFaceReceive
           2931                         ;#endif
           2932                         ;
           2933                         ;// To detect overlapping code in case someone would put some code before this header by mistake
           2934                         ;#pragma origin __APPLICATION_ADDRESS
     0000  2935         ORG 0x3A00
           2936                         ;#pragma updateBank 0
           2937                         ;
           2938                         ;//############################################################################################
           2939                         ;// Main IQRF entry point jumps to the main DPA entry point
           2940                         ;void APPLICATION()
           2941                         ;//############################################################################################
           2942                         ;{
           2943 APPLICATION
           2944                         ;  #asm
           2945                         ;    DW  __MOVLP( MAIN_DPA_ADDRESS >> 8 );
3A00 31AC  2946         DW    0x31AC
           2947                         ;  DW  __GOTO( MAIN_DPA_ADDRESS );
3A01 2C04  2948         DW    0x2C04
           2949                         ;  #endasm
           2950                         ;
           2951                         ;#ifndef NO_CUSTOM_DPA_HANDLER
           2952                         ;    // Fake call to force CustomDpaHandler() compilation
           2953                         ;    CustomDpaHandler();
3A02 2220  2954         CALL  CustomDpaHandler
           2955                         ;#endif
           2956                         ;
           2957                         ;  // Fake call to force DpaApiEntry() compilation
           2958                         ;  DpaApiEntry( param2, param3.low8, W );
3A03 3204  2959         BRA   DpaApiEntry
           2960                         ;}
           2961                         ;
           2962                         ;//############################################################################################
           2963                         ;// Entry stub to the real DPA API entry
           2964                         ;#pragma origin DPA_API_ADDRESS_ENTRY
     0000  2965         ORG 0x3A08
           2966                         ;uns8  DpaApiEntry( uns8 par1 @ param2, uns8 par2 @ param3.low8, uns8 apiIndex @ W )
           2967                         ;//############################################################################################
           2968                         ;{
           2969 DpaApiEntry
           2970                         ;  #asm
           2971                         ;    DW  __MOVLP( DPA_API_ADDRESS >> 8 );
3A08 31AC  2972         DW    0x31AC
           2973                         ;  DW  __CALL( DPA_API_ADDRESS );
3A09 2400  2974         DW    0x2400
           2975                         ;  DW  __MOVLP( DPA_API_ADDRESS_ENTRY >> 8 );
3A0A 31BA  2976         DW    0x31BA
           2977                         ;  #endasm
           2978                         ;
           2979                         ;    return W;
3A0B 0008  2980         RETURN
           2981                         ;}
           2982                         ;
           2983                         ;//############################################################################################
           2984                         ;#pragma origin DPA_API_ADDRESS_ENTRY + 0x08
     0000  2985         ORG 0x3A10
           2986                         ;
           2987                         ;//############################################################################################
           2988                         ;
           2989                         ;#ifndef NO_CUSTOM_DPA_HANDLER
           2990                         ;// Next comes Custom DPA handler routine
           2991                         ;#pragma origin CUSTOM_HANDLER_ADDRESS
     0000  2992         ORG 0x3A20
           2993                         ;#endif
           2994                         ;
           2995                         ;#pragma updateBank 1
           2996 
           2997   ; FILE D:\DP\IQRF_Startup_Package_OS403D_TR-7xD_200302\IQRF_OS403_7xD\Examples\DPA\CustomDpaHandlerExamples\IQRF_Standard\4802_DDC-RE_LP.c
           2998                         ;// *************************************************************************************
           2999                         ;//   Custom DPA Handler code example - Standard Binary output - DDC-RE-01 - LP version *
           3000                         ;// *************************************************************************************
           3001                         ;// Copyright (c) IQRF Tech s.r.o.
           3002                         ;//
           3003                         ;// File:    $RCSfile: 4802_DDC-RE_LP.c,v $
           3004                         ;// Version: $Revision: 1.6 $
           3005                         ;// Date:    $Date: 2020/02/20 17:18:59 $
           3006                         ;//
           3007                         ;// Revision history:
           3008                         ;//   2019/03/07  Release for DPA 4.01
           3009                         ;//
           3010                         ;// *********************************************************************
           3011                         ;
           3012                         ;// Online DPA documentation https://doc.iqrf.org/DpaTechGuide/
           3013                         ;// IQRF Standards documentation https://www.iqrfalliance.org/iqrf-interoperability/
           3014                         ;
           3015                         ;// This example also implements 2 binary outputs according to the IQRF Binary Outputs standard
           3016                         ;// Index 0 i.e. 1st output is Relay #1 @ DDC-RE-01
           3017                         ;// Index 1 i.e. 2nd output is Relay #2 @ DDC-RE-01
           3018                         ;
           3019                         ;// This example must be compiled without a "-bu" compiler switch in order to fit into available Flash memory
           3020                         ;
           3021                         ;// Default IQRF include (modify the path according to your setup)
           3022                         ;#include "IQRF.h"
           3023                         ;
           3024                         ;// We can save more instructions if needed by the symbol below
           3025                         ;// #define	PARAM_CHECK_LEVEL 1
           3026                         ;
           3027                         ;// Default DPA header (modify the path according to your setup)
           3028                         ;#include "DPA.h"
           3029                         ;// Default Custom DPA Handler header (modify the path according to your setup)
           3030                         ;#include "DPAcustomHandler.h"
           3031                         ;// IQRF standards header (modify the path according to your setup)
           3032                         ;#include "IQRFstandard.h"
           3033                         ;#include "IQRF_HWPID.h"
           3034                         ;
           3035                         ;//############################################################################################
           3036                         ;
           3037                         ;// Define useful macro that saves some code but not preset at DPA < 3.01
           3038                         ;#if DPA_VERSION_MASTER	< 0x0301
           3039                         ;// Optimized macro for both testing enumeration peripherals ELSE peripherals information. See examples
           3040                         ;#define	IfDpaEnumPeripherals_Else_PeripheralInfo_Else_PeripheralRequestNoSize() if ( _PCMD == CMD_GET_PER_INFO ) if ( _PNUM == PNUM_ENUMERATION )
           3041                         ;
           3042                         ;#if PARAM_CHECK_LEVEL >= 2
           3043                         ;#define IfDpaEnumPeripherals_Else_PeripheralInfo_Else_PeripheralRequest() if ( _DpaDataLength == 0 && _PCMD == CMD_GET_PER_INFO ) if ( _PNUM == PNUM_ENUMERATION )
           3044                         ;#else
           3045                         ;#define	IfDpaEnumPeripherals_Else_PeripheralInfo_Else_PeripheralRequest() IfDpaEnumPeripherals_Else_PeripheralInfo_Else_PeripheralRequestNoSize()
           3046                         ;#endif
           3047                         ;#endif
           3048                         ;
           3049                         ;//############################################################################################
           3050                         ;
           3051                         ;// ms per ticks
           3052                         ;#define	TICKS_LEN  10
           3053                         ;
           3054                         ;// Number of implemented binary outputs
           3055                         ;#define	OUTPUTS_COUNT 2
           3056                         ;
           3057                         ;// Sets and Gets state of the indexed binary output
           3058                         ;void SetOutput( uns8 state, uns8 index );
           3059                         ;bit GetOutput( uns8 index );
           3060                         ;
           3061                         ;// DDC-RE-01 relay pins
           3062                         ;//  C.5 = C8 = Relay#1
           3063                         ;#define	RELAY1_LAT	LATC.5 
           3064                         ;#define	RELAY1_TRIS	TRISC.5
           3065                         ;//  C.2 = C2 = Relay#2
           3066                         ;#define	RELAY2_LAT	LATC.2 
           3067                         ;#define	RELAY2_TRIS	TRISC.2
           3068                         ;
           3069                         ;// Must be the 1st defined function in the source code in order to be placed at the correct FLASH location!
           3070                         ;//############################################################################################
           3071                         ;bit CustomDpaHandler()
           3072                         ;//############################################################################################
           3073                         ;{
           3074 CustomDpaHandler
           3075                         ;  // This forces CC5X to wisely use MOVLB instructions (doc says:  The 'default' bank is used by the compiler for loops and labels when the algorithm gives up finding the optimal choice)
           3076                         ;#pragma updateBank default = UserBank_01
           3077                         ;
           3078                         ;  // Handler presence mark
           3079                         ;  clrwdt();
3A20 0064  3080         CLRWDT
           3081                         ;
           3082                         ;  // Timers for outputs. The space must be long enough to fit them all. 2+2 bytes per one binary output. 
           3083                         ;  //  2B timeout
           3084                         ;  //  2B startTicks
           3085                         ;  static uns16	Timers[OUTPUTS_COUNT * 2];
           3086                         ;
           3087                         ;  // Detect DPA event to handle
           3088                         ;  switch ( GetDpaEvent() )
3A21 0870  3089         MOVF  userReg0,W
3A22 3A01  3090         XORLW 0x01
3A23 1903  3091         BTFSC 0x03,Zero_
3A24 320A  3092         BRA   m001
3A25 3A03  3093         XORLW 0x03
3A26 1903  3094         BTFSC 0x03,Zero_
3A27 3208  3095         BRA   m002
3A28 3A01  3096         XORLW 0x01
3A29 1903  3097         BTFSC 0x03,Zero_
3A2A 323B  3098         BRA   m006
3A2B 3A03  3099         XORLW 0x03
3A2C 1903  3100         BTFSC 0x03,Zero_
3A2D 3240  3101         BRA   m007
3A2E 2B39  3102         GOTO  m029
           3103                         ;  {
           3104                         ;    // -------------------------------------------------
           3105                         ;    case DpaEvent_Interrupt:
           3106                         ;      // Do an extra quick background interrupt work
           3107                         ;
           3108                         ;      return Carry;
3A2F 0008  3109 m001    RETURN
           3110                         ;
           3111                         ;      // -------------------------------------------------
           3112                         ;    case DpaEvent_Idle:
           3113                         ;      // Do a quick background work when RF packet is not received
           3114                         ;
           3115                         ;      // Check binary output timers
           3116                         ;    {
           3117                         ;      // Pointer to the timers array
           3118                         ;      FSR1 = (uns16)&Timers[0];
3A30 30CC  3119 m002    MOVLW 0xCC
3A31 0086  3120         MOVWF FSR1
3A32 3005  3121         MOVLW 0x05
3A33 0087  3122         MOVWF FSR1+1
           3123                         ;      // Output index
           3124                         ;      uns8 index;
           3125                         ;      index = 0;
3A34 002B  3126         MOVLB 0x0B
3A35 01C0  3127         CLRF  index
           3128                         ;      do
           3129                         ;      {
           3130                         ;        // Is timer running (is non-zero)?
           3131                         ;        if ( ( FSR1[1] | INDF1 ) != 0 )
3A36 3F41  3132 m003    MOVIW 1[INDF1]
3A37 0401  3133         IORWF INDF1,W
3A38 1903  3134         BTFSC 0x03,Zero_
3A39 3224  3135         BRA   m005
           3136                         ;        {
           3137                         ;          // Get timer value
           3138                         ;          uns16 timer;
           3139                         ;          timer.low8 = FSR1[0];
3A3A 0801  3140         MOVF  INDF1,W
3A3B 002B  3141         MOVLB 0x0B
3A3C 00C1  3142         MOVWF timer
           3143                         ;          timer.high8 = FSR1[1];
3A3D 3F41  3144         MOVIW 1[INDF1]
3A3E 00C2  3145         MOVWF timer+1
           3146                         ;          // Get start time
           3147                         ;          uns16 timerStart;
           3148                         ;          timerStart.low8 = FSR1[2];
3A3F 3F42  3149         MOVIW 2[INDF1]
3A40 00C3  3150         MOVWF timerStart
           3151                         ;          timerStart.high8 = FSR1[3];
3A41 3F43  3152         MOVIW 3[INDF1]
3A42 00C4  3153         MOVWF timerStart+1
           3154                         ;          // Measure elapsed time
           3155                         ;          captureTicks(); // Note: must not modify FSR1
3A43 207C  3156         CALL  captureTicks
           3157                         ;          param3 -= timerStart;
3A44 0844  3158         MOVF  timerStart+1,W
3A45 02F5  3159         SUBWF param3+1,1
3A46 0843  3160         MOVF  timerStart,W
3A47 02F4  3161         SUBWF param3,1
3A48 1C03  3162         BTFSS 0x03,Carry
3A49 03F5  3163         DECF  param3+1,1
           3164                         ;          // It time over?
           3165                         ;          if ( param3 > timer )
3A4A 0875  3166         MOVF  param3+1,W
3A4B 0242  3167         SUBWF timer+1,W
3A4C 1C03  3168         BTFSS 0x03,Carry
3A4D 3206  3169         BRA   m004
3A4E 1D03  3170         BTFSS 0x03,Zero_
3A4F 320E  3171         BRA   m005
3A50 0874  3172         MOVF  param3,W
3A51 0241  3173         SUBWF timer,W
3A52 1803  3174         BTFSC 0x03,Carry
3A53 320A  3175         BRA   m005
           3176                         ;          {
           3177                         ;            // Set output to OFF
           3178                         ;            SetOutput( 0, index );
3A54 002B  3179 m004    MOVLB 0x0B
3A55 01C7  3180         CLRF  state_2
3A56 0840  3181         MOVF  index,W
3A57 233B  3182         CALL  SetOutput
           3183                         ;            // Reset timer
           3184                         ;            setINDF1( 0 );
3A58 3000  3185         MOVLW 0x00
3A59 2134  3186         CALL  setINDF1
           3187                         ;            FSR1++;
3A5A 3141  3188         ADDFSR INDF1,1
           3189                         ;            setINDF1( 0 );
3A5B 3000  3190         MOVLW 0x00
3A5C 2134  3191         CALL  setINDF1
           3192                         ;            FSR1--;
3A5D 317F  3193         ADDFSR INDF1,-1
           3194                         ;          }
           3195                         ;        }
           3196                         ;        // Next timer
           3197                         ;        FSR1 += 2 * sizeof( Timers[0] );
3A5E 3144  3198 m005    ADDFSR INDF1,4
           3199                         ;        // Next index
           3200                         ;      } while ( ++index < OUTPUTS_COUNT );
3A5F 002B  3201         MOVLB 0x0B
3A60 0AC0  3202         INCF  index,1
3A61 3002  3203         MOVLW 0x02
3A62 0240  3204         SUBWF index,W
3A63 1C03  3205         BTFSS 0x03,Carry
3A64 33D1  3206         BRA   m003
           3207                         ;    }
           3208                         ;    break;
3A65 32D3  3209         BRA   m029
           3210                         ;
           3211                         ;    // -------------------------------------------------
           3212                         ;    case DpaEvent_Init:
           3213                         ;      // Do a one time initialization before main loop starts
           3214                         ;
           3215                         ;      // Initialize ticks
           3216                         ;      startCapture();
3A66 2079  3217 m006    CALL  startCapture
           3218                         ;
           3219                         ;      // Initialize relays @ DDC-RE
           3220                         ;      RELAY1_LAT = 0;
3A67 0022  3221         MOVLB 0x02
3A68 128E  3222         BCF   LATC,5
           3223                         ;      RELAY2_LAT = 0;
3A69 110E  3224         BCF   LATC,2
           3225                         ;      RELAY1_TRIS = 0;
3A6A 0021  3226         MOVLB 0x01
3A6B 128E  3227         BCF   TRISC,5
           3228                         ;      RELAY2_TRIS = 0;
3A6C 110E  3229         BCF   TRISC,2
           3230                         ;
           3231                         ;      break;
3A6D 32CB  3232         BRA   m029
           3233                         ;
           3234                         ;      // -------------------------------------------------
           3235                         ;    case DpaEvent_DpaRequest:
           3236                         ;      // Called to interpret DPA request for peripherals
           3237                         ;      // -------------------------------------------------
           3238                         ;      // Peripheral enumeration
           3239                         ;      IfDpaEnumPeripherals_Else_PeripheralInfo_Else_PeripheralRequest()
3A6E 0025  3240 m007    MOVLB 0x05
3A6F 08A1  3241         MOVF  DLEN,1
3A70 1D03  3242         BTFSS 0x03,Zero_
3A71 321D  3243         BRA   m010
3A72 082F  3244         MOVF  PCMD,W
3A73 3A3F  3245         XORLW 0x3F
3A74 1D03  3246         BTFSS 0x03,Zero_
3A75 3219  3247         BRA   m010
3A76 0F2E  3248         INCFSZ PNUM,W
3A77 320A  3249         BRA   m009
           3250                         ;      {
           3251                         ;        // We implement 2 standard peripherals
           3252                         ;        _DpaMessage.EnumPeripheralsAnswer.UserPerNr = 1;
3A78 3001  3253         MOVLW 0x01
3A79 0029  3254         MOVLB 0x09
3A7A 00A2  3255         MOVWF DpaRfMessage+2
           3256                         ;        FlagUserPer( _DpaMessage.EnumPeripheralsAnswer.UserPer, PNUM_STD_BINARY_OUTPUTS );
3A7B 15B1  3257         BSF   DpaRfMessage+17,3
           3258                         ;        _DpaMessage.EnumPeripheralsAnswer.HWPID = HWPID_IQRF_TECH__DEMO_DDC_RE01_LP;
3A7C 3002  3259         MOVLW 0x02
3A7D 00A7  3260         MOVWF DpaRfMessage+7
3A7E 3048  3261         MOVLW 0x48
3A7F 00A8  3262         MOVWF DpaRfMessage+8
           3263                         ;        _DpaMessage.EnumPeripheralsAnswer.HWPIDver |= 0x0000;
           3264                         ;
           3265                         ;DpaHandleReturnTRUE:
           3266                         ;        return TRUE;
3A80 1403  3267 m008    BSF   0x03,Carry
3A81 0008  3268         RETURN
           3269                         ;      }
           3270                         ;      // -------------------------------------------------
           3271                         ;      // Get information about peripherals
           3272                         ;else
           3273                         ;      {
           3274                         ;      switch ( _DpaMessage.PeripheralInfoAnswer.PerT = _PNUM )
3A82 0025  3275 m009    MOVLB 0x05
3A83 082E  3276         MOVF  PNUM,W
3A84 0029  3277         MOVLB 0x09
3A85 00A1  3278         MOVWF DpaRfMessage+1
3A86 3A4B  3279         XORLW 0x4B
3A87 1D03  3280         BTFSS 0x03,Zero_
3A88 32B0  3281         BRA   m029
           3282                         ;      {
           3283                         ;        case PNUM_STD_BINARY_OUTPUTS:
           3284                         ;          // Set standard version
           3285                         ;          _DpaMessage.PeripheralInfoAnswer.Par1 = 4;
3A89 3004  3286         MOVLW 0x04
3A8A 0029  3287         MOVLB 0x09
3A8B 00A2  3288         MOVWF DpaRfMessage+2
           3289                         ;          _DpaMessage.PeripheralInfoAnswer.PerTE = PERIPHERAL_TYPE_EXTENDED_READ_WRITE;
3A8C 3003  3290         MOVLW 0x03
3A8D 00A0  3291         MOVWF DpaRfMessage
           3292                         ;          goto DpaHandleReturnTRUE;
3A8E 33F1  3293         BRA   m008
           3294                         ;      }
           3295                         ;
           3296                         ;      break;
           3297                         ;      }
           3298                         ;
           3299                         ;      {
           3300                         ;      // -------------------------------------------------
           3301                         ;      // Handle peripheral command
           3302                         ;
           3303                         ;      // Supported peripheral number?
           3304                         ;      switch ( _PNUM )
3A8F 0025  3305 m010    MOVLB 0x05
3A90 082E  3306         MOVF  PNUM,W
3A91 3A4B  3307         XORLW 0x4B
3A92 1D03  3308         BTFSS 0x03,Zero_
3A93 32A5  3309         BRA   m029
           3310                         ;      {
           3311                         ;        case PNUM_STD_BINARY_OUTPUTS:
           3312                         ;        {
           3313                         ;          // Supported commands?
           3314                         ;          switch ( _PCMD )
3A94 0025  3315         MOVLB 0x05
3A95 082F  3316         MOVF  PCMD,W
3A96 3A3E  3317         XORLW 0x3E
3A97 1903  3318         BTFSC 0x03,Zero_
3A98 3205  3319         BRA   m012
3A99 3A3E  3320         XORLW 0x3E
3A9A 1903  3321         BTFSC 0x03,Zero_
3A9B 320D  3322         BRA   m014
           3323                         ;          {
           3324                         ;            // Invalid command
           3325                         ;            default:
           3326                         ;              // Return error
           3327                         ;_ERROR_PCMD:
           3328                         ;              W = ERROR_PCMD;
3A9C 3002  3329 m011    MOVLW 0x02
           3330                         ;              goto _ERROR_W;
3A9D 322B  3331         BRA   m019
           3332                         ;
           3333                         ;              // Outputs enumeration
           3334                         ;            case PCMD_STD_ENUMERATE:
           3335                         ;              if ( _DpaDataLength != 0 )
3A9E 0025  3336 m012    MOVLB 0x05
3A9F 08A1  3337         MOVF  DLEN,1
3AA0 1D03  3338         BTFSS 0x03,Zero_
           3339                         ;                goto _ERROR_DATA_LEN;
3AA1 3226  3340         BRA   m018
           3341                         ;
           3342                         ;              // Return number of outputs
           3343                         ;              _DpaMessageIqrfStd.PerStdBinaryOutputEnumerate_Response.Count = OUTPUTS_COUNT;
3AA2 3002  3344         MOVLW 0x02
3AA3 0029  3345         MOVLB 0x09
3AA4 00A0  3346         MOVWF _DpaMessageIqrfStd
           3347                         ;              W = sizeof( _DpaMessageIqrfStd.PerStdBinaryOutputEnumerate_Response );
3AA5 3001  3348         MOVLW 0x01
           3349                         ;_W2_DpaDataLength:
           3350                         ;              _DpaDataLength = W;
3AA6 0025  3351 m013    MOVLB 0x05
3AA7 00A1  3352         MOVWF DLEN
           3353                         ;              goto DpaHandleReturnTRUE;
3AA8 33D7  3354         BRA   m008
           3355                         ;
           3356                         ;              // Supported commands.
           3357                         ;            case PCMD_STD_BINARY_OUTPUTS_SET:
           3358                         ;            {
           3359                         ;              // Pointers FSR01 to data are already set at the DPA
           3360                         ;
           3361                         ;              // As this template implements < 9 outputs the working bitmap is uns8, if more outputs are implemented then uns16, ..., uns32 must be used
           3362                         ;#if OUTPUTS_COUNT < 9
           3363                         ;              uns8 inBitmap = *FSR0--;
3AA9 0013  3364 m014    MOVIW INDF0--
3AAA 002B  3365         MOVLB 0x0B
3AAB 00C0  3366         MOVWF inBitmap
           3367                         ;              uns8 outBitmap @ _DpaMessageIqrfStd.PerStdBinaryOutputSet_Request.Bitmap[0];
           3368                         ;              uns8 bitmapMask = 0b1;
3AAC 3001  3369         MOVLW 0x01
3AAD 00C1  3370         MOVWF bitmapMask
           3371                         ;#else
           3372                         ;#error Not implemented
           3373                         ;#endif
           3374                         ;
           3375                         ;              // Number of selected outputs + bitmap length
           3376                         ;              uns8 outputsCount = sizeof( _DpaMessageIqrfStd.PerStdBinaryOutputSet_Request.Bitmap );
3AAE 3004  3377         MOVLW 0x04
3AAF 00C2  3378         MOVWF outputsCount
           3379                         ;              // Loop bitmap
           3380                         ;              uns8 index = sizeof( _DpaMessageIqrfStd.PerStdBinaryOutputSet_Request.Bitmap );
3AB0 3004  3381         MOVLW 0x04
3AB1 00C3  3382         MOVWF index_2
           3383                         ;              do
           3384                         ;              {
           3385                         ;                // Count bits of next byte
           3386                         ;                uns8 byte = *++FSR0;
3AB2 0010  3387 m015    MOVIW ++INDF0
3AB3 002B  3388         MOVLB 0x0B
3AB4 00C4  3389         MOVWF byte
           3390                         ;                if ( byte != 0 )
3AB5 08C4  3391         MOVF  byte,1
3AB6 1903  3392         BTFSC 0x03,Zero_
3AB7 3206  3393         BRA   m017
           3394                         ;                {
           3395                         ;                  // Brian Kernighan's Algorithm for counting set bits 
           3396                         ;                  do
           3397                         ;                  {
           3398                         ;                    outputsCount++;
3AB8 002B  3399 m016    MOVLB 0x0B
3AB9 0AC2  3400         INCF  outputsCount,1
           3401                         ;                    byte &= byte - 1;
3ABA 0344  3402         DECF  byte,W
3ABB 05C4  3403         ANDWF byte,1
           3404                         ;                  } while ( byte != 0 );
3ABC 1D03  3405         BTFSS 0x03,Zero_
3ABD 33FA  3406         BRA   m016
           3407                         ;                }
           3408                         ;
           3409                         ;                // Reset bitmap
           3410                         ;                setINDF0( 0 );
3ABE 3000  3411 m017    MOVLW 0x00
3ABF 2131  3412         CALL  setINDF0
           3413                         ;              } while ( --index != 0 );
3AC0 0BC3  3414         DECFSZ index_2,1
3AC1 33F0  3415         BRA   m015
           3416                         ;
           3417                         ;              // Check data length
           3418                         ;              if ( _DpaDataLength != outputsCount )
3AC2 0025  3419         MOVLB 0x05
3AC3 0821  3420         MOVF  DLEN,W
3AC4 002B  3421         MOVLB 0x0B
3AC5 0642  3422         XORWF outputsCount,W
3AC6 1903  3423         BTFSC 0x03,Zero_
3AC7 3204  3424         BRA   m020
           3425                         ;              {
           3426                         ;_ERROR_DATA_LEN:
           3427                         ;                W = ERROR_DATA_LEN;
3AC8 3005  3428 m018    MOVLW 0x05
           3429                         ;_ERROR_W:
           3430                         ;                DpaApiReturnPeripheralError( W );
3AC9 00F3  3431 m019    MOVWF par1
3ACA 3005  3432         MOVLW 0x05
3ACB 333C  3433         BRA   DpaApiEntry
           3434                         ;              }
           3435                         ;
           3436                         ;              // Pointer to the timers array
           3437                         ;              FSR1 = (uns16)&Timers[0];
3ACC 30CC  3438 m020    MOVLW 0xCC
3ACD 0086  3439         MOVWF FSR1
3ACE 3005  3440         MOVLW 0x05
3ACF 0087  3441         MOVWF FSR1+1
           3442                         ;              // Output index
           3443                         ;              index = 0;
3AD0 002B  3444         MOVLB 0x0B
3AD1 01C3  3445         CLRF  index_2
           3446                         ;              do
           3447                         ;              {
           3448                         ;                // Output was set?
           3449                         ;                if ( GetOutput( index ) )
3AD2 002B  3450 m021    MOVLB 0x0B
3AD3 0843  3451         MOVF  index_2,W
3AD4 2350  3452         CALL  GetOutput
3AD5 1C03  3453         BTFSS 0x03,Carry
3AD6 3204  3454         BRA   m022
           3455                         ;                  // Yes, set in the output bitmap
           3456                         ;                  outBitmap |= bitmapMask;
3AD7 002B  3457         MOVLB 0x0B
3AD8 0841  3458         MOVF  bitmapMask,W
3AD9 0029  3459         MOVLB 0x09
3ADA 04A0  3460         IORWF outBitmap,1
           3461                         ;
           3462                         ;                // Implemented output selected? Set the state.
           3463                         ;                if ( inBitmap.0 )
3ADB 002B  3464 m022    MOVLB 0x0B
3ADC 1C40  3465         BTFSS inBitmap,0
3ADD 324E  3466         BRA   m028
           3467                         ;                {
           3468                         ;                  // Default is timer off
           3469                         ;                  uns16 time = 0;
3ADE 01C4  3470         CLRF  time
3ADF 01C5  3471         CLRF  time+1
           3472                         ;                  // Desired state
           3473                         ;                  uns8 state = *++FSR0;
3AE0 0010  3474         MOVIW ++INDF0
3AE1 00C6  3475         MOVWF state
           3476                         ;                  if ( state > 1 )
3AE2 3002  3477         MOVLW 0x02
3AE3 0246  3478         SUBWF state,W
3AE4 1C03  3479         BTFSS 0x03,Carry
3AE5 3233  3480         BRA   m027
           3481                         ;                  {
           3482                         ;                    // Get time in units s/min
           3483                         ;                    time = state & 0x7F;
3AE6 01C5  3484         CLRF  time+1
3AE7 307F  3485         MOVLW 0x7F
3AE8 0546  3486         ANDWF state,W
3AE9 00C4  3487         MOVWF time
           3488                         ;                    if ( time == 0 )
3AEA 0844  3489         MOVF  time,W
3AEB 0445  3490         IORWF time+1,W
3AEC 1D03  3491         BTFSS 0x03,Zero_
3AED 3202  3492         BRA   m023
           3493                         ;                    {
           3494                         ;                      // Invalid time
           3495                         ;                      W = ERROR_FAIL;
3AEE 3001  3496         MOVLW 0x01
           3497                         ;_ERROR_FAIL:
           3498                         ;                      goto _ERROR_W;
3AEF 33D9  3499         BRA   m019
           3500                         ;                    }
           3501                         ;
           3502                         ;                    // Conversion coefficient, ready for seconds
           3503                         ;                    uns16 coef = 1000 / TICKS_LEN;
3AF0 3064  3504 m023    MOVLW 0x64
3AF1 002B  3505         MOVLB 0x0B
3AF2 00C7  3506         MOVWF coef
3AF3 01C8  3507         CLRF  coef+1
           3508                         ;                    if ( !state.7 )
3AF4 1BC6  3509         BTFSC state,7
3AF5 3209  3510         BRA   m024
           3511                         ;                    {
           3512                         ;                      // Check for the maximum supported time because of captureTicks method
           3513                         ;                      if ( time.low8 > ( (uns24)0xFFFF * TICKS_LEN / 1000 / 60 ) )
3AF6 300B  3514         MOVLW 0x0B
3AF7 0244  3515         SUBWF time,W
3AF8 1803  3516         BTFSC 0x03,Carry
           3517                         ;                        goto _ERROR_FAIL;
3AF9 33CF  3518         BRA   m019
           3519                         ;
           3520                         ;                      // Convert from minutes
           3521                         ;                      uns16 coef = 60 * ( 1000 / TICKS_LEN );
3AFA 3070  3522         MOVLW 0x70
3AFB 002B  3523         MOVLB 0x0B
3AFC 00C9  3524         MOVWF coef_2
3AFD 3017  3525         MOVLW 0x17
3AFE 00CA  3526         MOVWF coef_2+1
           3527                         ;                    }
           3528                         ;
           3529                         ;                    // Convert to 250 ms
           3530                         ;                    time *= coef;
3AFF 002B  3531 m024    MOVLB 0x0B
3B00 0844  3532         MOVF  time,W
3B01 00CA  3533         MOVWF C2tmp
3B02 0845  3534         MOVF  time+1,W
3B03 00CB  3535         MOVWF C2tmp+1
3B04 3010  3536         MOVLW 0x10
3B05 00C9  3537         MOVWF C1cnt
3B06 1003  3538 m025    BCF   0x03,Carry
3B07 002B  3539         MOVLB 0x0B
3B08 0DC4  3540         RLF   time,1
3B09 0DC5  3541         RLF   time+1,1
3B0A 0DCA  3542         RLF   C2tmp,1
3B0B 0DCB  3543         RLF   C2tmp+1,1
3B0C 1C03  3544         BTFSS 0x03,Carry
3B0D 3206  3545         BRA   m026
3B0E 0848  3546         MOVF  coef+1,W
3B0F 07C5  3547         ADDWF time+1,1
3B10 0847  3548         MOVF  coef,W
3B11 07C4  3549         ADDWF time,1
3B12 1803  3550         BTFSC 0x03,Carry
3B13 0AC5  3551         INCF  time+1,1
3B14 002B  3552 m026    MOVLB 0x0B
3B15 0BC9  3553         DECFSZ C1cnt,1
3B16 33EF  3554         BRA   m025
           3555                         ;                    // Set ON
           3556                         ;                    state = 1;
3B17 3001  3557         MOVLW 0x01
3B18 00C6  3558         MOVWF state
           3559                         ;                  }
           3560                         ;
           3561                         ;                  // Set output
           3562                         ;                  SetOutput( state, index );
3B19 002B  3563 m027    MOVLB 0x0B
3B1A 0846  3564         MOVF  state,W
3B1B 00C7  3565         MOVWF state_2
3B1C 0843  3566         MOVF  index_2,W
3B1D 233B  3567         CALL  SetOutput
           3568                         ;
           3569                         ;                  // Set timer but preserve pointer
           3570                         ;                  setINDF1( time.low8 );
3B1E 002B  3571         MOVLB 0x0B
3B1F 0844  3572         MOVF  time,W
3B20 2134  3573         CALL  setINDF1
           3574                         ;                  FSR1++;
3B21 3141  3575         ADDFSR INDF1,1
           3576                         ;                  setINDF1( time.high8 );
3B22 0845  3577         MOVF  time+1,W
3B23 2134  3578         CALL  setINDF1
           3579                         ;                  FSR1++;
3B24 3141  3580         ADDFSR INDF1,1
           3581                         ;                  // Get start time
           3582                         ;                  captureTicks(); //Note: must not destroy FSR1
3B25 207C  3583         CALL  captureTicks
           3584                         ;                  setINDF1( param3.low8 );
3B26 0874  3585         MOVF  param3,W
3B27 2134  3586         CALL  setINDF1
           3587                         ;                  FSR1++;
3B28 3141  3588         ADDFSR INDF1,1
           3589                         ;                  setINDF1( param3.high8 );
3B29 0875  3590         MOVF  param3+1,W
3B2A 2134  3591         CALL  setINDF1
           3592                         ;                  FSR1 -= 3;
3B2B 317D  3593         ADDFSR INDF1,-3
           3594                         ;                }
           3595                         ;
           3596                         ;                // Pointer to the next timer
           3597                         ;                FSR1 += 2 * sizeof( Timers[0] );
3B2C 3144  3598 m028    ADDFSR INDF1,4
           3599                         ;                // Next bits
           3600                         ;                bitmapMask <<= 1;
3B2D 1003  3601         BCF   0x03,Carry
3B2E 002B  3602         MOVLB 0x0B
3B2F 0DC1  3603         RLF   bitmapMask,1
           3604                         ;                inBitmap >>= 1;
3B30 1003  3605         BCF   0x03,Carry
3B31 0CC0  3606         RRF   inBitmap,1
           3607                         ;                // Next index
           3608                         ;              } while ( ++index < OUTPUTS_COUNT );
3B32 0AC3  3609         INCF  index_2,1
3B33 3002  3610         MOVLW 0x02
3B34 0243  3611         SUBWF index_2,W
3B35 1C03  3612         BTFSS 0x03,Carry
3B36 339B  3613         BRA   m021
           3614                         ;
           3615                         ;              // Return bitmap
           3616                         ;_DpaDataLength4:
           3617                         ;              W = sizeof( _DpaMessageIqrfStd.PerStdBinaryOutputSet_Response.PreviousStates );
3B37 3004  3618         MOVLW 0x04
           3619                         ;              goto _W2_DpaDataLength;
3B38 336D  3620         BRA   m013
           3621                         ;            }
           3622                         ;          }
           3623                         ;        }
           3624                         ;      }
           3625                         ;
           3626                         ;      break;
           3627                         ;      }
           3628                         ;  }
           3629                         ;DpaHandleReturnFALSE:
           3630                         ;  return FALSE;
3B39 1003  3631 m029    BCF   0x03,Carry
3B3A 0008  3632         RETURN
           3633                         ;}
           3634                         ;
           3635                         ;//############################################################################################
           3636                         ;void SetOutput( uns8 state, uns8 index @ W )
           3637                         ;//############################################################################################
           3638                         ;{
           3639 SetOutput
           3640                         ;  // Note: FSRs must not be modified
           3641                         ;  // Note: This method is called in the interrupt too!
           3642                         ;
           3643                         ;  skip( index );
3B3B 002B  3644         MOVLB 0x0B
3B3C 000B  3645         BRW  
           3646                         ;#pragma computedGoto 1
           3647                         ;  goto set0;
3B3D 3209  3648         BRA   m033
           3649                         ;  goto set1;
           3650                         ;#pragma computedGoto 0
           3651                         ;  ;
           3652                         ;  // --------------------------------------
           3653                         ;set1:
           3654                         ;  if ( !state.0 )
3B3E 002B  3655 m030    MOVLB 0x0B
3B3F 1847  3656         BTFSC state_2,0
3B40 3203  3657         BRA   m031
           3658                         ;    RELAY2_LAT = 0;
3B41 0022  3659         MOVLB 0x02
3B42 110E  3660         BCF   LATC,2
           3661                         ;  else
3B43 3202  3662         BRA   m032
           3663                         ;    RELAY2_LAT = 1;
3B44 0022  3664 m031    MOVLB 0x02
3B45 150E  3665         BSF   LATC,2
           3666                         ;
           3667                         ;  return;
3B46 0008  3668 m032    RETURN
           3669                         ;  // --------------------------------------
           3670                         ;set0:
           3671                         ;  if ( !state.0 )
3B47 002B  3672 m033    MOVLB 0x0B
3B48 1847  3673         BTFSC state_2,0
3B49 3203  3674         BRA   m034
           3675                         ;    RELAY1_LAT = 0;
3B4A 0022  3676         MOVLB 0x02
3B4B 128E  3677         BCF   LATC,5
           3678                         ;  else
3B4C 3202  3679         BRA   m035
           3680                         ;    RELAY1_LAT = 1;
3B4D 0022  3681 m034    MOVLB 0x02
3B4E 168E  3682         BSF   LATC,5
           3683                         ;
           3684                         ;  return;
3B4F 0008  3685 m035    RETURN
           3686                         ;  // --------------------------------------
           3687                         ;}
           3688                         ;
           3689                         ;//############################################################################################
           3690                         ;bit GetOutput( uns8 index @ W )
           3691                         ;//############################################################################################
           3692                         ;{
           3693 GetOutput
           3694                         ;  Carry = FALSE; // Note: must not modify W
3B50 1003  3695         BCF   0x03,Carry
           3696                         ;
           3697                         ;  // Note: all below must not modify Carry except when needed
           3698                         ;  skip( index );
3B51 0022  3699         MOVLB 0x02
3B52 000B  3700         BRW  
           3701                         ;#pragma computedGoto 1
           3702                         ;  goto get0;
3B53 3205  3703         BRA   m037
           3704                         ;  goto get1;
           3705                         ;#pragma computedGoto 0
           3706                         ;  ;
           3707                         ;  // --------------------------------------
           3708                         ;get1:
           3709                         ;  if ( RELAY2_LAT )
3B54 0022  3710 m036    MOVLB 0x02
3B55 1D0E  3711         BTFSS LATC,2
3B56 3206  3712         BRA   m038
           3713                         ;    Carry = TRUE;
3B57 1403  3714         BSF   0x03,Carry
           3715                         ;  goto _return;
3B58 3204  3716         BRA   m038
           3717                         ;  // --------------------------------------
           3718                         ;get0:
           3719                         ;  if ( RELAY1_LAT )
3B59 0022  3720 m037    MOVLB 0x02
3B5A 1E8E  3721         BTFSS LATC,5
3B5B 3201  3722         BRA   m038
           3723                         ;    Carry = TRUE;
3B5C 1403  3724         BSF   0x03,Carry
           3725                         ;  goto _return;
           3726                         ;  // --------------------------------------
           3727                         ;
           3728                         ;_return:
           3729                         ;  return Carry;
3B5D 0008  3730 m038    RETURN
           3731 
           3732   ; FILE ../../../../Development/include/DPA/DPAcustomHandler.h
           3733                         ;// *********************************************************************
           3734                         ;//   Main Custom DPA Handler header                                    *
           3735                         ;// *********************************************************************
           3736                         ;// Copyright (c) IQRF Tech s.r.o.
           3737                         ;//
           3738                         ;// File:    $RCSfile: DPAcustomHandler.h,v $
           3739                         ;// Version: $Revision: 1.113 $
           3740                         ;// Date:    $Date: 2020/02/27 13:17:18 $
           3741                         ;//
           3742                         ;// Revision history:
           3743                         ;//   2020/02/27  Release for DPA 4.13
           3744                         ;//   2020/01/09  Release for DPA 4.12
           3745                         ;//   2019/12/11  Release for DPA 4.11
           3746                         ;//   2019/10/09  Release for DPA 4.10
           3747                         ;//   2019/06/12  Release for DPA 4.03
           3748                         ;//   2019/06/03  Release for DPA 4.02
           3749                         ;//   2019/03/07  Release for DPA 4.01
           3750                         ;//   2019/01/10  Release for DPA 4.00
           3751                         ;//   2018/10/25  Release for DPA 3.03
           3752                         ;//   2017/11/16  Release for DPA 3.02
           3753                         ;//   2017/08/14  Release for DPA 3.01
           3754                         ;//   2017/03/13  Release for DPA 3.00
           3755                         ;//   2016/09/12  Release for DPA 2.28
           3756                         ;//   2016/04/14  Release for DPA 2.27
           3757                         ;//   2016/03/03  Release for DPA 2.26
           3758                         ;//   2016/01/21  Release for DPA 2.25
           3759                         ;//   2015/12/01  Release for DPA 2.24
           3760                         ;//   2015/10/23  Release for DPA 2.23
           3761                         ;//   2015/09/25  Release for DPA 2.22
           3762                         ;//   2015/09/03  Release for DPA 2.21
           3763                         ;//   2015/08/05  Release for DPA 2.20
           3764                         ;//   2014/10/31  Release for DPA 2.10
           3765                         ;//   2014/04/30  Release for DPA 2.00
           3766                         ;//   2013/10/03  Release for DPA 1.00
           3767                         ;//
           3768                         ;// *********************************************************************
           3769                         ;
           3770                         ;// Online DPA documentation https://doc.iqrf.org/DpaTechGuide/
           3771                         ;// IQRF Standards documentation https://www.iqrfalliance.org/iqrf-interoperability/
           3772                         ;
           3773                         ;#ifndef _CUSTOM_DPA_HANDLER_
           3774                         ;#define _CUSTOM_DPA_HANDLER_
           3775                         ;
           3776                         ;//############################################################################################
           3777                         ;// 1st include 
           3778                         ;
           3779                         ;// Custom DPA Handler routine declaration
           3780                         ;bit CustomDpaHandler();
           3781                         ;
           3782                         ;// Various DPA flags shared between DPA and Custom DPA Handler
           3783                         ;uns8 DpaFlags @ usedBank4[0];
           3784                         ;#ifdef COORDINATOR_CUSTOM_HANDLER
           3785                         ;// [C] TRUE if interface master is not connected (detected)
           3786                         ;bit IFaceMasterNotConnected @ DpaFlags.2;
           3787                         ;#endif
           3788                         ;// [N] [CN] DPA by interface notification is sent also when there was a "reading" like DPA request
           3789                         ;bit EnableIFaceNotificationOnRead @ DpaFlags.3;
           3790                         ;// [N] [NC] TRUE when node was just bonded using default bonding procedure
           3791                         ;bit NodeWasBonded @ DpaFlags.4;
           3792                         ;
           3793                         ;// [C] Ticks (decrementing) counter usable for timing in the coordinator's Customer DPA Handler
           3794                         ;uns16 DpaTicks @ usedBank4[1];
           3795                         ;// [N] [NC] toutRF for LP mode, read from configuration memory after reset
           3796                         ;uns8 LPtoutRF @ usedBank4[3];
           3797                         ;// DPA Request/Response HWPID
           3798                         ;uns16 _HWPID @ usedBank4[4];
           3799                         ;// Identifies type of reset (stored at UserReg0 upon module reset). See Reset chapter at IQRF User's Guide for more information
           3800                         ;uns8 ResetType @ usedBank4[6];
           3801                         ;// User DPA Values to return
           3802                         ;uns8 UserDpaValue @ usedBank4[7];
           3803                         ;// Network depth of the DPA request/response, increases on bridging, decreases on back-bridging
           3804                         ;uns8 NetDepth @ usedBank4[8];
           3805                         ;// TRUE when node was at DPA Service Mode after last boot
           3806                         ;bit DSMactivated @ usedBank4[9].0;
           3807                         ;// If set to TRUE, then LP RX mode in the main loop can be terminated by pin, see _RLPMAT
           3808                         ;bit LpRxPinTerminate @ usedBank4[9].1;
           3809                         ;// If set to TRUE, then [C] executes asynchronous DPA requests received from [N]
           3810                         ;bit AsyncReqAtCoordinator @ usedBank4[9].2;
           3811                         ;// RX filter used at the DPA main loop checkRF call
           3812                         ;uns8 RxFilter @ usedBank4[11];
           3813                         ;// Countdown variable for button bonding before going to deep sleep 
           3814                         ;uns16 BondingSleepCountdown @ usedBank4[12];
           3815                         ;#define BONDING_SLEEP_COUNTDOWN_UNIT  290
           3816                         ;// Non-zero pseudo-random value, read-only, updated on every Reset and Idle event, at [N] only.
           3817                         ;uns16 Random @ usedBank4[14];
           3818                         ;
           3819                         ;// Macro to return an error from the peripheral handler. If the code size is not an issue this macro is the right choice.
           3820                         ;#define DpaApiReturnPeripheralError(error) do { \
           3821                         ;	DpaApiSetPeripheralError( error ); \
           3822                         ;	return Carry; \
           3823                         ;  } while( 0 )
           3824                         ;
           3825                         ;// DPA API functions, see documentation for details
           3826                         ;#define	DpaApiRfTxDpaPacket( dpaValue, netDepthAndFlags ) DpaApiEntry( dpaValue, netDepthAndFlags, DPA_API_RFTX_DPAPACKET )
           3827                         ;#define	DpaApiReadConfigByte( index )					  DpaApiEntry( index, param3.low8, DPA_API_READ_CONFIG_BYTE )
           3828                         ;#define	DpaApiLocalRequest()							  DpaApiEntry( param2, param3.low8, DPA_API_LOCAL_REQUEST )
           3829                         ;#define	DpaApiSetPeripheralError( error )				  DpaApiEntry( error, param3.low8, DPA_API_SET_PERIPHERAL_ERROR )
           3830                         ;#define	DpaApiSendToIFaceMaster( dpaValue, flags )		  DpaApiEntry( dpaValue, flags, DPA_API_SEND_TO_IFACEMASTER )
           3831                         ;#define	DpaApiSetRfDefaults()							  DpaApiEntry( param2, param3.low8, DPA_API_SET_RF_DEFAULTS )
           3832                         ;
           3833                         ;#ifdef COORDINATOR_CUSTOM_HANDLER
           3834                         ;#define	DpaApiRfTxDpaPacketCoordinator()				  DpaApiEntry( param2, param3.low8, DPA_API_COORDINATOR_RFTX_DPAPACKET )
           3835                         ;#endif
           3836                         ;
           3837                         ;#ifdef COORDINATOR_CUSTOM_HANDLER
           3838                         ;#undef	DpaEvent_Interrupt
           3839                         ;#undef	DpaEvent_BeforeSleep
           3840                         ;#undef	DpaEvent_AfterSleep
           3841                         ;#undef	DpaEvent_FrcValue
           3842                         ;#undef	DpaEvent_FrcResponseTime
           3843                         ;#else
           3844                         ;#undef  DpaEvent_ReceiveDpaResponse
           3845                         ;#undef  DpaEvent_IFaceReceive
           3846                         ;#endif
           3847                         ;
           3848                         ;// To detect overlapping code in case someone would put some code before this header by mistake
           3849                         ;#pragma origin __APPLICATION_ADDRESS
           3850                         ;#pragma updateBank 0
           3851                         ;
           3852                         ;//############################################################################################
           3853                         ;// Main IQRF entry point jumps to the main DPA entry point
           3854                         ;void APPLICATION()
           3855                         ;//############################################################################################
           3856                         ;{
           3857                         ;  #asm
           3858                         ;    DW  __MOVLP( MAIN_DPA_ADDRESS >> 8 );
           3859                         ;  DW  __GOTO( MAIN_DPA_ADDRESS );
           3860                         ;  #endasm
           3861                         ;
           3862                         ;#ifndef NO_CUSTOM_DPA_HANDLER
           3863                         ;    // Fake call to force CustomDpaHandler() compilation
           3864                         ;    CustomDpaHandler();
           3865                         ;#endif
           3866                         ;
           3867                         ;  // Fake call to force DpaApiEntry() compilation
           3868                         ;  DpaApiEntry( param2, param3.low8, W );
           3869                         ;}
           3870                         ;
           3871                         ;//############################################################################################
           3872                         ;// Entry stub to the real DPA API entry
           3873                         ;#pragma origin DPA_API_ADDRESS_ENTRY
           3874                         ;uns8  DpaApiEntry( uns8 par1 @ param2, uns8 par2 @ param3.low8, uns8 apiIndex @ W )
           3875                         ;//############################################################################################
           3876                         ;{
           3877                         ;  #asm
           3878                         ;    DW  __MOVLP( DPA_API_ADDRESS >> 8 );
           3879                         ;  DW  __CALL( DPA_API_ADDRESS );
           3880                         ;  DW  __MOVLP( DPA_API_ADDRESS_ENTRY >> 8 );
           3881                         ;  #endasm
           3882                         ;
           3883                         ;    return W;
           3884                         ;}
           3885                         ;
           3886                         ;//############################################################################################
           3887                         ;#pragma origin DPA_API_ADDRESS_ENTRY + 0x08
           3888                         ;
           3889                         ;//############################################################################################
           3890                         ;
           3891                         ;#ifndef NO_CUSTOM_DPA_HANDLER
           3892                         ;// Next comes Custom DPA handler routine
           3893                         ;#pragma origin CUSTOM_HANDLER_ADDRESS
           3894                         ;#endif
           3895                         ;
           3896                         ;#pragma updateBank 1
           3897                         ;
           3898                         ;//############################################################################################
           3899                         ;#else // _CUSTOM_DPA_HANDLER_
           3900                         ;//############################################################################################
           3901                         ;// 2nd include
           3902                         ;
           3903                         ;#ifndef NO_CUSTOM_DPA_HANDLER
           3904                         ;// Code bumper to detect too long code of Custom DPA handler + other routines
           3905                         ;#pragma origin CUSTOM_HANDLER_ADDRESS_END
     0000  3906         ORG 0x3D80
           3907                         ;// To avoid adding some code after handler by mistake
           3908                         ;#pragma origin __MAX_FLASH_ADDRESS
     0000  3909         ORG 0x3FFF
           3910 
           3911         END
           3912 
           3913 
           3914 ; *** KEY INFO ***
           3915 
           3916 ; 0x0100 P0    5 word(s)  0 % : main
           3917 
           3918 ; 0x3A00 P7    4 word(s)  0 % : APPLICATION
           3919 ; 0x3810 P7    2 word(s)  0 % : dummy
           3920 ; 0x3816 P7    2 word(s)  0 % : iqrfSleep
           3921 ; 0x3819 P7    2 word(s)  0 % : _debug
           3922 ; 0x381C P7    2 word(s)  0 % : moduleInfo
           3923 ; 0x3822 P7    2 word(s)  0 % : pulsingLEDR
           3924 ; 0x3825 P7    2 word(s)  0 % : pulseLEDR
           3925 ; 0x3828 P7    2 word(s)  0 % : stopLEDR
           3926 ; 0x382B P7    2 word(s)  0 % : pulsingLEDG
           3927 ; 0x382E P7    2 word(s)  0 % : pulseLEDG
           3928 ; 0x3831 P7    2 word(s)  0 % : stopLEDG
           3929 ; 0x3834 P7    2 word(s)  0 % : setOnPulsingLED
           3930 ; 0x3837 P7    2 word(s)  0 % : setOffPulsingLED
           3931 ; 0x383A P7    2 word(s)  0 % : eeReadByte
           3932 ; 0x383D P7    2 word(s)  0 % : eeReadData
           3933 ; 0x3840 P7    2 word(s)  0 % : eeWriteByte
           3934 ; 0x3843 P7    2 word(s)  0 % : eeWriteData
           3935 ; 0x3846 P7    2 word(s)  0 % : readFromRAM
           3936 ; 0x384C P7    2 word(s)  0 % : clearBufferINFO
           3937 ; 0x384F P7    2 word(s)  0 % : swapBufferINFO
           3938 ; 0x3852 P7    2 word(s)  0 % : compareBufferINFO2RF
           3939 ; 0x3855 P7    2 word(s)  0 % : copyBufferINFO2COM
           3940 ; 0x3858 P7    2 word(s)  0 % : copyBufferINFO2RF
           3941 ; 0x385B P7    2 word(s)  0 % : copyBufferRF2COM
           3942 ; 0x385E P7    2 word(s)  0 % : copyBufferRF2INFO
           3943 ; 0x3861 P7    2 word(s)  0 % : copyBufferCOM2RF
           3944 ; 0x3864 P7    2 word(s)  0 % : copyBufferCOM2INFO
           3945 ; 0x3867 P7    2 word(s)  0 % : copyMemoryBlock
           3946 ; 0x386A P7    2 word(s)  0 % : startDelay
           3947 ; 0x386D P7    2 word(s)  0 % : startLongDelay
           3948 ; 0x3870 P7    2 word(s)  0 % : isDelay
           3949 ; 0x3873 P7    2 word(s)  0 % : waitDelay
           3950 ; 0x3876 P7    2 word(s)  0 % : waitMS
           3951 ; 0x3879 P7    2 word(s)  0 % : startCapture
           3952 ; 0x387C P7    2 word(s)  0 % : captureTicks
           3953 ; 0x3882 P7    2 word(s)  0 % : waitNewTick
           3954 ; 0x3885 P7    2 word(s)  0 % : enableSPI
           3955 ; 0x3888 P7    2 word(s)  0 % : disableSPI
           3956 ; 0x388B P7    2 word(s)  0 % : startSPI
           3957 ; 0x388E P7    2 word(s)  0 % : stopSPI
           3958 ; 0x3891 P7    2 word(s)  0 % : restartSPI
           3959 ; 0x3894 P7    2 word(s)  0 % : getStatusSPI
           3960 ; 0x3897 P7    2 word(s)  0 % : setRFpower
           3961 ; 0x389A P7    2 word(s)  0 % : setLEDG
           3962 ; 0x389D P7    2 word(s)  0 % : setRFchannel
           3963 ; 0x38A0 P7    2 word(s)  0 % : setRFmode
           3964 ; 0x38A3 P7    2 word(s)  0 % : setRFspeed
           3965 ; 0x38A6 P7    2 word(s)  0 % : setRFsleep
           3966 ; 0x38A9 P7    2 word(s)  0 % : setRFready
           3967 ; 0x38AC P7    2 word(s)  0 % : RFTXpacket
           3968 ; 0x38AF P7    2 word(s)  0 % : RFRXpacket
           3969 ; 0x38B2 P7    2 word(s)  0 % : checkRF
           3970 ; 0x38B8 P7    2 word(s)  0 % : amIBonded
           3971 ; 0x38BB P7    2 word(s)  0 % : removeBond
           3972 ; 0x38BE P7    2 word(s)  0 % : bondNewNode
           3973 ; 0x38C1 P7    2 word(s)  0 % : isBondedNode
           3974 ; 0x38C4 P7    2 word(s)  0 % : removeBondedNode
           3975 ; 0x38C7 P7    2 word(s)  0 % : rebondNode
           3976 ; 0x38CA P7    2 word(s)  0 % : clearAllBonds
           3977 ; 0x38CD P7    2 word(s)  0 % : setNonetMode
           3978 ; 0x38D0 P7    2 word(s)  0 % : setCoordinatorMode
           3979 ; 0x38D3 P7    2 word(s)  0 % : setNodeMode
           3980 ; 0x38D6 P7    2 word(s)  0 % : setNetworkFilteringOn
           3981 ; 0x38D9 P7    2 word(s)  0 % : setNetworkFilteringOff
           3982 ; 0x38DC P7    2 word(s)  0 % : getNetworkParams
           3983 ; 0x38DF P7    2 word(s)  0 % : setRoutingOn
           3984 ; 0x38E2 P7    2 word(s)  0 % : setRoutingOff
           3985 ; 0x38E8 P7    2 word(s)  0 % : answerSystemPacket
           3986 ; 0x38EB P7    2 word(s)  0 % : discovery
           3987 ; 0x38EE P7    2 word(s)  0 % : wasRouted
           3988 ; 0x38F1 P7    2 word(s)  0 % : optimizeHops
           3989 ; 0x38F4 P7    2 word(s)  0 % : getSupplyVoltage
           3990 ; 0x38F7 P7    2 word(s)  0 % : getTemperature
           3991 ; 0x38FA P7    2 word(s)  0 % : clearBufferRF
           3992 ; 0x3910 P7    2 word(s)  0 % : isDiscoveredNode
           3993 ; 0x3913 P7    2 word(s)  0 % : enableRFPGM
           3994 ; 0x3916 P7    2 word(s)  0 % : disableRFPGM
           3995 ; 0x3919 P7    2 word(s)  0 % : setupRFPGM
           3996 ; 0x391C P7    2 word(s)  0 % : runRFPGM
           3997 ; 0x391F P7    2 word(s)  0 % : iqrfDeepSleep
           3998 ; 0x3922 P7    2 word(s)  0 % : wasRFICrestarted
           3999 ; 0x3925 P7    2 word(s)  0 % : eeeWriteData
           4000 ; 0x3928 P7    2 word(s)  0 % : eeeReadData
           4001 ; 0x3931 P7    2 word(s)  0 % : setINDF0
           4002 ; 0x3934 P7    2 word(s)  0 % : setINDF1
           4003 ; 0x3937 P7    2 word(s)  0 % : getRSSI
           4004 ; 0x393A P7    2 word(s)  0 % : removeBondAddress
           4005 ; 0x393D P7    2 word(s)  0 % : sendFRC
           4006 ; 0x3940 P7    2 word(s)  0 % : responseFRC
           4007 ; 0x3943 P7    2 word(s)  0 % : bondRequestAdvanced
           4008 ; 0x3946 P7    2 word(s)  0 % : prebondNodeAtNode
           4009 ; 0x3949 P7    2 word(s)  0 % : nodeAuthorization
           4010 ; 0x394C P7    2 word(s)  0 % : dummy01
           4011 ; 0x3958 P7    2 word(s)  0 % : setAccessPassword
           4012 ; 0x395B P7    2 word(s)  0 % : setUserKey
           4013 ; 0x3961 P7    2 word(s)  0 % : amIRecipientOfFRC
           4014 ; 0x3964 P7    2 word(s)  0 % : setLEDR
           4015 ; 0x3967 P7    2 word(s)  0 % : encryptBufferRF
           4016 ; 0x396A P7    2 word(s)  0 % : decryptBufferRF
           4017 ; 0x396D P7    2 word(s)  0 % : prebondNodeAtCoordinator
           4018 ; 0x3970 P7    2 word(s)  0 % : setFSRs
           4019 ; 0x3973 P7    2 word(s)  0 % : updateCRC16
           4020 ; 0x3976 P7    2 word(s)  0 % : smartConnect
           4021 ; 0x3979 P7    2 word(s)  0 % : addressBitmap
           4022 ; 0x397C P7    3 word(s)  0 % : setServiceChannel
           4023 ; 0x3A08 P7    4 word(s)  0 % : DpaApiEntry
           4024 ; 0x3A20 P7  283 word(s) 13 % : CustomDpaHandler
           4025 ; 0x3B3B P7   21 word(s)  1 % : SetOutput
           4026 ; 0x3B50 P7   14 word(s)  0 % : GetOutput
           4027 
           4028 ; RAM usage: 996 bytes (12 local), 28 bytes free
           4029 ; Maximum call level: 3
           4030 ;  Codepage 0 has    6 word(s) :   0 %
           4031 ;  Codepage 1 has    0 word(s) :   0 %
           4032 ;  Codepage 2 has    0 word(s) :   0 %
           4033 ;  Codepage 3 has    0 word(s) :   0 %
           4034 ;  Codepage 4 has    0 word(s) :   0 %
           4035 ;  Codepage 5 has    0 word(s) :   0 %
           4036 ;  Codepage 6 has    0 word(s) :   0 %
           4037 ;  Codepage 7 has  535 word(s) :  26 %
           4038 ; Total of 541 code words (3 %)
