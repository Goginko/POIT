// *******************************************************************************
//   Custom DPA Handler code example - Demonstrates using of custom FRC commands *
// *******************************************************************************
// Copyright (c) IQRF Tech s.r.o.
//
// File:    $RCSfile: CustomDpaHandler-FRC.c,v $
// Version: $Revision: 1.44 $
// Date:    $Date: 2020/02/20 17:18:58 $
//
// Revision history:
//   2017/03/13  Release for DPA 3.00
//   2015/08/05  Release for DPA 2.20
//   2014/10/31  Release for DPA 2.10
//   2014/04/30  Release for DPA 2.00
//
// *******************************************************************************

// Online DPA documentation https://doc.iqrf.org/DpaTechGuide/

// Default IQRF include (modify the path according to your setup)
#include "IQRF.h"

// Default DPA header (modify the path according to your setup)
#include "DPA.h"
// Default Custom DPA Handler header (modify the path according to your setup)
#include "DPAcustomHandler.h"

//############################################################################################

// Divides 16bit value by 255
void DivMod255( uns16 value );

// Application implements 4 FCR commands
// 0x40 - bit command, result bit.0 == 1, result bit.1 == 1 when button is pressed, otherwise bit.1 == 0
// 0x41 - bit command, result bit.0 == 1, result bit.1 == 1 when LEDG is on, otherwise bit.1 == 0
// 0xC0 - byte command, result byte=VRN
// 0xF0	- shows how to return 16bit value even having its bytes equal 0. This command does not do sleeping, but UserData is used to specify which byte of 16bit value to return)
//
// FRC user data specify time to sleep after RFC data is collected, 0 means no sleeping
// Sleeping after FRC can be easily implemented using acknowledged broadcast FRC commands

// Must be the 1st defined function in the source code in order to be placed at the correct FLASH location!
//############################################################################################
bit CustomDpaHandler()
//############################################################################################
{
  // Handler presence mark
  clrwdt();

  // Go sleep on next Idle
  static uns16 sleepTime;

  // Detect DPA event to handle
  switch ( GetDpaEvent() )
  {
    // -------------------------------------------------
    case DpaEvent_Interrupt:
      // Do an extra quick background interrupt work
      // ! The time spent handling this event is critical.If there is no interrupt to handle return immediately otherwise keep the code as fast as possible.
      // ! Make sure the event is the 1st case in the main switch statement at the handler routine.This ensures that the event is handled as the 1st one.
      // ! It is desirable that this event is handled with immediate return even if it is not used by the custom handler because the Interrupt event is raised on every MCU interrupt and the “empty” return handler ensures the shortest possible interrupt routine response time.
      // ! Only global variables or local ones marked by static keyword can be used to allow reentrancy.
      // ! Make sure race condition does not occur when accessing those variables at other places.
      // ! Make sure( inspect.lst file generated by C compiler ) compiler does not create any hidden temporary local variable( occurs when using division, multiplication or bit shifts ) at the event handler code.The name of such variable is usually Cnumbercnt.
      // ! Do not call any OS functions except setINDFx().
      // ! Do not use any OS variables especially for writing access.
      // ! All above rules apply also to any other function being called from the event handler code, although calling any function from Interrupt event is not recommended because of additional MCU stack usage.

DpaHandleReturnTRUE:
      return TRUE;

      // -------------------------------------------------
    case DpaEvent_Init:
      // Do a one time initialization before main loop starts

      // Enable LED during special system actions (discovery, FRC)
      _systemLEDindication = TRUE;
      break;

      // -------------------------------------------------
    case DpaEvent_FrcResponseTime:
      // Called to get FRC response time

      switch ( DataOutBeforeResponseFRC[0] )
      {
        case FRC_USER_BIT_FROM + 0:
        case FRC_USER_BIT_FROM + 1:
        case FRC_USER_BYTE_FROM + 0:
        case FRC_USER_BYTE_FROM + 1:
          responseFRCvalue = _FRC_RESPONSE_TIME_40_MS;
          break;
      }
      break;

      // -------------------------------------------------
    case DpaEvent_FrcValue:
      // Called to get FRC value
      uns16 FRC16bData @ DataOutBeforeResponseFRC;
      sleepTime = FRC16bData;

      switch ( _PCMD )
      {
        // This example is sensitive to the bit FRCommand 0x40
        case FRC_USER_BIT_FROM + 0:
          // bit.1 is set only when button is pressed
          if ( buttonPressed )
            responseFRCvalue.1 = 1;
          break;

          // This example is sensitive to the bit FRCommand 0x41
        case FRC_USER_BIT_FROM + 1:
          // bit.1 is set only when LEDG is on
          if ( _LEDG == 1 )
            responseFRCvalue.1 = 1;
          break;

          // This example is sensitive to the byte FRCommand 0xF0
        case FRC_USER_2BYTE_FROM:
          // It returns 2 bytes from getTemperature()

          // Temperature measurement error?
          if ( getTemperature() == -128 )
            param3 = 0x8000;

          // Is temperature 0?
          if ( param3 == 0 )
            // Return 0x7FFF instead
            param3 = 0x7FFF;

          responseFRCvalue2B = param3;
          break;

          // This example is sensitive to the byte FRCommand 0xC0
        case FRC_USER_BYTE_FROM + 0:
          // Return node's VRN
          responseFRCvalue = ntwVRN;
          break;

          // This example is sensitive to the byte FRCommand 0xC1
        case FRC_USER_BYTE_FROM + 1:
        {
          // This FRC shows how to return 16 bit value keeping in mind that returned bytes must not be 0
          // It converts 16 bit value into 255 radix and increments both quotient and reminder by 1 thus eliminating 0
          // It means that the highest value that can be actually returned is 255 * 254 + 254 = 0xFE00 (hex) = 65024 (decimal)
          // To compose the original 16b value just do: ( 1stByte - 1 ) + 255 * ( 2ndByte - 1 )

          static uns8 hiByte;

          // Return 1st lower "byte"
          if ( FRC16bData == 0 )
          {
            // Example value to return is 0xABCD
            DivMod255( 0xABCD );
            // Quotient /255
            hiByte = param3.low8 + 1;
            // Return reminder /255
            responseFRCvalue = param4.low8 + 1;
          }
          else
            // Return quotient
            responseFRCvalue = hiByte;

          // fall through to reset sleeping
        }

        default:
          sleepTime = 0;
          break;
      }

      break;

      // -------------------------------------------------
    case DpaEvent_Idle:
      // Do a quick background work when RF packet is not received

      // Go sleep?
      if ( sleepTime != 0 )
      {
        // Prepare OS Sleep DPA Request
        _PNUM = PNUM_OS;
        _PCMD = CMD_OS_SLEEP;
        // Time in 2.097s units
        _DpaMessage.PerOSSleep_Request.Time = sleepTime;
        sleepTime = 0;
        // LEDG flash after wake up & pin wakeup
        _DpaMessage.PerOSSleep_Request.Control = 0b1101;
        _DpaDataLength = sizeof( _DpaMessage.PerOSSleep_Request );
        // Perform local DPA Request
        DpaApiLocalRequest();
      }
      break;

    case DpaEvent_DpaRequest:
      // Called to interpret DPA request for peripherals
      // -------------------------------------------------
      // Peripheral enumeration
      if ( IsDpaEnumPeripheralsRequest() )
      {
        // We implement no user peripheral
        _DpaMessage.EnumPeripheralsAnswer.HWPID = 0x000F;
        _DpaMessage.EnumPeripheralsAnswer.HWPIDver = 0x0000;
        goto DpaHandleReturnTRUE;
      }
  }

  return FALSE;
}

//############################################################################################
/*
* Divides 16bit value by 255
* Input:
*	Dividend: value @ param3:16
* Output:
*	Quotient: @ param3:16
*	Remainder: @ param4.low8:8
* Assumes: param4:16 is adjacent to param3:16
*
* Based on http://www.piclist.com/techref/microchip/math/div/24by8-jah.htm
*/
void DivMod255( uns16 value @ param3 )
//############################################################################################
{
  #asm
    clrf	  param4 + 0;

  movlw	  16;
  movwf	  param4 + 1;

loop:
  rlf	  value + 0, W;
  rlf	  value + 1, f;
  rlf	  param4 + 0, f;
  rlf	  value + 0, f;

  movlw	  255;
  subwf	  param4 + 0, f;

  btfsc	  Carry;
  bsf	  value + 0, 0;

  btfss	  value + 0, 0;
  addwf	  param4 + 0, f;

  decfsz  param4 + 1, f;
  goto	  loop;
  #endasm
}

//############################################################################################
// Default Custom DPA Handler header; 2nd include to implement Code bumper to detect too long code of the Custom DPA Handler (modify the path according to your setup) 
#include "DPAcustomHandler.h"
//############################################################################################
