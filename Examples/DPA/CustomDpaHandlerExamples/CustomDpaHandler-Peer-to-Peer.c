// *********************************************************************
//   Custom DPA Handler code example - Peer-to-peer receiver           *
// *********************************************************************
// Copyright (c) IQRF Tech s.r.o.
//
// File:    $RCSfile: CustomDpaHandler-Peer-to-Peer.c,v $
// Version: $Revision: 1.22 $
// Date:    $Date: 2020/01/03 13:56:50 $
//
// Revision history:
//   2019/01/10  Release for DPA 4.00
//   2017/03/13  Release for DPA 3.00
//   2015/08/05  Release for DPA 2.20
//
// *********************************************************************

// Online DPA documentation https://doc.iqrf.org/DpaTechGuide/

// Default IQRF include (modify the path according to your setup)
#include "IQRF.h"

// Uncomment to compile Custom DPA Handler for Coordinator
//#define COORDINATOR_CUSTOM_HANDLER

// Default DPA header (modify the path according to your setup)
#include "DPA.h"
// Default Custom DPA Handler header (modify the path according to your setup)
#include "DPAcustomHandler.h"

// This example receives peer-to-peer packets sent from Peer-to-Peer-Transmitter.c example using build-in DPA support of peer-to-peer packets (event DpaEvent_PeerToPeer).
// The example also shows fully user programmed implementation of peer-to-peer packet at the different channel (event DpaEvent_Idle). This approach requires more code but avoids radio jamming of the main network traffic.
// !!! It is highly recommended to use additional security techniques (e.g. encryption, rolling code, checksum, CRC) against packet sniffing, spoofing and eavesdropping. 
// !!!  It is also recommended to use listen-before-talk technique to minimize the risk of RF collision that might cause the main network RF traffic to fail.

void HandlerPeer2PeerPacket();

// Must be the 1st defined function in the source code in order to be placed at the correct FLASH location!
//############################################################################################
bit CustomDpaHandler()
//############################################################################################
{
  // Handler presence mark
  clrwdt();

  // Detect DPA event to handle
  switch ( GetDpaEvent() )
  {
#ifdef	DpaEvent_Interrupt
    // -------------------------------------------------
    case DpaEvent_Interrupt:
      // Do an extra quick background interrupt work
      // ! The time spent handling this event is critical.If there is no interrupt to handle return immediately otherwise keep the code as fast as possible.
      // ! Make sure the event is the 1st case in the main switch statement at the handler routine.This ensures that the event is handled as the 1st one.
      // ! It is desirable that this event is handled with immediate return even if it is not used by the custom handler because the Interrupt event is raised on every MCU interrupt and the “empty” return handler ensures the shortest possible interrupt routine response time.
      // ! Only global variables or local ones marked by static keyword can be used to allow reentrancy.
      // ! Make sure race condition does not occur when accessing those variables at other places.
      // ! Make sure( inspect.lst file generated by C compiler ) compiler does not create any hidden temporary local variable( occurs when using division, multiplication or bit shifts ) at the event handler code.The name of such variable is usually Cnumbercnt.
      // ! Do not call any OS functions except setINDFx().
      // ! Do not use any OS variables especially for writing access.
      // ! All above rules apply also to any other function being called from the event handler code, although calling any function from Interrupt event is not recommended because of additional MCU stack usage.

      return Carry;
#endif
      // -------------------------------------------------
    case DpaEvent_PeerToPeer:
      // Called when peer-to-peer (non-networking) packet is received

      // Handle peer-to-peer packet received by the build-in DPA support. Those packets are sent at the same channel the main network work at.
      HandlerPeer2PeerPacket();
      break;

      // -------------------------------------------------
    case DpaEvent_Idle:
    {
      // Do a quick background work when RF packet is not received

      // Try to receive peer-to-peer packets at the secondary main network channel. This avoids RF jamming of the main network but it is not 100% reliable as 2 channels must be scanned.

      // Save state of the filtering.
      bit saveFiltering = _filterCurrentNetwork;
      // Packet not received yet
      bit handlePacket = FALSE;
      // Change the channel
      uns8 saveRFchannel = RFchannel;
      setRFchannel( DpaApiReadConfigByte( CFGIND_CHANNEL_B ) );
      // Disable filtering to allow receiving of peer-to-peer packets
      setNetworkFilteringOff();

      // Try to receive packet
      if ( checkRF( DpaApiReadConfigByte( CFGIND_RXFILTER ) ) && RFRXpacket() )
        // Some packet received!
        handlePacket = TRUE;

      // Before handling the packet restore RF settings (there might be needed for the correct DPA command, that is stored in the packet, execution)
      // Restore channel
      setRFchannel( saveRFchannel );
      // Restore network filtering
      if ( saveFiltering )
        setNetworkFilteringOn();

      // If packet was received, handle it
      if ( handlePacket )
        HandlerPeer2PeerPacket();

      break;
    }
  }

  return FALSE;
}

//############################################################################################
void HandlerPeer2PeerPacket()
//############################################################################################
{
  // Peer-to-peer "DPA" packet?
#pragma warning Remove this branch
  if ( _DPAF )
  {
    // Is my local address matched?
    if ( _DpaParams == ntwADDR )
    {
      // Just execute the DPA request
      DpaApiLocalRequest();
      // Make sure LED is visible at LP mode
      waitMS( 20 );
    }
  }
  else
  {
    // Pure peer-to-peer packet

    // Is my peer-to-peer packet (check length and content)
    if ( DLEN == 2 && bufferRF[0] == 'P' && bufferRF[1] == ntwADDR )
    {
      // Pulse red LED
      pulseLEDR();
      // Make sure LED is visible at LP mode
      waitMS( 20 );
    }
  }
}
//############################################################################################
// Default Custom DPA Handler header; 2nd include to implement Code bumper to detect too long code of the Custom DPA Handler (modify the path according to your setup) 
#include "DPAcustomHandler.h"
//############################################################################################
